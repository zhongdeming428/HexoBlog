{"meta":{"title":"D.M","subtitle":"D.M's Blog","description":null,"author":"DM Zhong","url":"http://zhongdeming.fun"},"pages":[{"title":"About","date":"2018-10-31T13:27:31.000Z","updated":"2021-05-07T21:21:43.640Z","comments":false,"path":"about/index.html","permalink":"http://zhongdeming.fun/about/index.html","excerpt":"","text":"E-mail: zhongdeming428@gmail.com GitHub: https://github.com/zhongdeming428 Twitter: https://twitter.com/zhongdeming428 Location: ShenZhen, Guangdong"},{"title":"Comments","date":"2018-10-31T13:38:30.000Z","updated":"2021-05-07T21:21:43.640Z","comments":true,"path":"comments/index.html","permalink":"http://zhongdeming.fun/comments/index.html","excerpt":"","text":"有什么想说的，都写在这里吧！"}],"posts":[{"title":"从源码学习 node-delegates","slug":"从源码学习-node-delegates","date":"2019-06-22T09:02:09.000Z","updated":"2021-05-07T21:21:43.640Z","comments":true,"path":"2019/06/22/从源码学习-node-delegates/","link":"","permalink":"http://zhongdeming.fun/2019/06/22/从源码学习-node-delegates/","excerpt":"node-delegates 是 TJ 大神所写的一个简单的小工具，源码只有 157 行，作用在于将外部对象接受到的操作委托到内部属性进行处理，也可以理解为讲对象的内部属性暴露到外部，简化我们所需要书写的代码。 安装和使用的代码在源码仓库都可以找到，这里主要先讲一下 API。 APIDelegate(proto, prop)用于创建一个 delegator 实例，用于把 proto 接收到的一些操作委托给它的 prop 属性进行处理。 Delegate.auto(proto, targetProto, targetProp)根据 targetProp 所包含的键，自动判断类型，把 targetProto 上的对应属性代理到 proto。可以是 getter、setter、value 或者 method。 Delegate.prototype.method(name)在 proto 对象上新增一个名为 name 的函数，调用该函数相当于调用 proto 的 prop 属性上的 name 函数。 Delegate.prototype.getter(name)新增一个 getter 到 proto 对象，访问该 getter 即可访问 proto 的 prop 的对应 getter。 Delegate.prototype.setter(name)同 getter。","text":"node-delegates 是 TJ 大神所写的一个简单的小工具，源码只有 157 行，作用在于将外部对象接受到的操作委托到内部属性进行处理，也可以理解为讲对象的内部属性暴露到外部，简化我们所需要书写的代码。 安装和使用的代码在源码仓库都可以找到，这里主要先讲一下 API。 APIDelegate(proto, prop)用于创建一个 delegator 实例，用于把 proto 接收到的一些操作委托给它的 prop 属性进行处理。 Delegate.auto(proto, targetProto, targetProp)根据 targetProp 所包含的键，自动判断类型，把 targetProto 上的对应属性代理到 proto。可以是 getter、setter、value 或者 method。 Delegate.prototype.method(name)在 proto 对象上新增一个名为 name 的函数，调用该函数相当于调用 proto 的 prop 属性上的 name 函数。 Delegate.prototype.getter(name)新增一个 getter 到 proto 对象，访问该 getter 即可访问 proto 的 prop 的对应 getter。 Delegate.prototype.setter(name)同 getter。 Delegate.prototype.access(name)在 proto 上同时新增一个 getter 和一个 setter，指向 proto.prop 的对应属性。 Delegate.prototype.fluent(name)access 的特殊形式。 12345678910delegate(proto, 'request') .fluent('query')// gettervar q = request.query();// setter (chainable)request .query(&#123; a: 1 &#125;) .query(&#123; b: 2 &#125;); 源码阅读123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180/** * Expose `Delegator`. */// 暴露 Delegator 构造函数module.exports = Delegator;/** * Initialize a delegator. * 构造一个 delegator 实例 * @param &#123;Object&#125; proto 外部对象，供外部调用 * @param &#123;String&#125; target 外部对象的某个属性，包含具体处理逻辑 * @api public */function Delegator(proto, target) &#123; // 如果没有使用 new 操作符调用构造函数，则使用 new 构造 if (!(this instanceof Delegator)) return new Delegator(proto, target); // 构造实例属性 this.proto = proto; this.target = target; this.methods = []; this.getters = []; this.setters = []; this.fluents = [];&#125;/** * Automatically delegate properties * from a target prototype * 根据 targetProp 自动委托，绑定一个属性到 Delegator 构造函数 * @param &#123;Object&#125; proto 接受请求的外部对象 * @param &#123;object&#125; targetProto 处理具体逻辑的内部对象 * @param &#123;String&#125; targetProp 包含要委托的属性的对象 * @api public */Delegator.auto = function(proto, targetProto, targetProp)&#123; var delegator = Delegator(proto, targetProp); // 根据 targetProp 获取要委托的属性 var properties = Object.getOwnPropertyNames(targetProto); // 遍历所有要委托的属性 for (var i = 0; i &lt; properties.length; i++) &#123; var property = properties[i]; // 获取 targetProto 上对应属性的 descriptor var descriptor = Object.getOwnPropertyDescriptor(targetProto, property); // 如果当前属性的 get 被重写过，就作为 getter 委托（使用 __defineGetter__ 或者 Object.defineProperty 指定 getter 都会重写 descriptor 的 get 属性） if (descriptor.get) &#123; delegator.getter(property); &#125; // 同 get，如果 set 被重写过，那就作为 setter 委托 if (descriptor.set) &#123; delegator.setter(property); &#125; // 如果当前 property 具有 value，那么判断是函数还是普通值 if (descriptor.hasOwnProperty('value')) &#123; // could be undefined but writable var value = descriptor.value; if (value instanceof Function) &#123; // 是函数就进行函数委托 delegator.method(property); &#125; else &#123; // 是普通值就作为 getter 委托 delegator.getter(property); &#125; // 如果这个值可以重写，那么继续进行 setter 委托 if (descriptor.writable) &#123; delegator.setter(property); &#125; &#125; &#125;&#125;;/** * Delegate method `name`. * * @param &#123;String&#125; name * @return &#123;Delegator&#125; self * @api public */Delegator.prototype.method = function(name)&#123; var proto = this.proto; var target = this.target; this.methods.push(name); // 在 proto 上定义一个 name 的方法 proto[name] = function()&#123; // 实际还是调用的 proto[target][name]，内部的 this 还是指向 proto[target] return this[target][name].apply(this[target], arguments); &#125;; return this;&#125;;/** * Delegator accessor `name`. * * @param &#123;String&#125; name * @return &#123;Delegator&#125; self * @api public */Delegator.prototype.access = function(name)&#123; // 同时定义 getter 和 setter return this.getter(name).setter(name);&#125;;/** * Delegator getter `name`. * 委托 name getter * @param &#123;String&#125; name * @return &#123;Delegator&#125; self * @api public */Delegator.prototype.getter = function(name)&#123; var proto = this.proto; var target = this.target; this.getters.push(name); // 使用 __defineGetter__ 绑定 name getter 到 proto proto.__defineGetter__(name, function()&#123; // 注意 this 指向 proto 本身，所以 proto[name] 最终访问的还是 proto[target][name] return this[target][name]; &#125;); // 此处 this 指向 delegator 实例，构造链式调用 return this;&#125;;/** * Delegator setter `name`. * 在 proto 上委托一个 name setter * @param &#123;String&#125; name * @return &#123;Delegator&#125; self * @api public */Delegator.prototype.setter = function(name)&#123; var proto = this.proto; var target = this.target; this.setters.push(name); // 通过 __defineSetter__ 方法指定一个 setter 到 proto proto.__defineSetter__(name, function(val)&#123; // 注意 this 指向 proto 本身，所以对 proto[name] 设置值即为为 proto[target][name] 设置值 return this[target][name] = val; &#125;); // 返回自身实现链式调用 return this;&#125;;/** * Delegator fluent accessor * * @param &#123;String&#125; name * @return &#123;Delegator&#125; self * @api public */Delegator.prototype.fluent = function (name) &#123; var proto = this.proto; var target = this.target; this.fluents.push(name); proto[name] = function(val)&#123; // 如果 val 不为空，那么就作为 setter 使用 if ('undefined' != typeof val) &#123; this[target][name] = val; // 完事后返回 proto 自身，实现链式调用 return this; &#125; else &#123; // 如果 val 未定义，那么作为 getter 使用，返回具体的值 return this[target][name]; &#125; &#125;; return this;&#125;; 具体案例之所以会研究一下这个库是因为在看 koa 源码的时候看到使用了这个库，在 koa 中通过使用 node-delegates 把 context.request 和 context.response 上的属性都委托到了 context 自身。所以我们可以直接使用 context.query、context.status 来进行操作，简化了我们所写的代码。 koa 源码位置链接：https://github.com/koajs/koa/blob/b7fc526ea49894f366153bd32997e02568c0b8a6/lib/context.js#L191 总结 通过 __defineGetter__ 和 __defineSetter__ 可以设置 getter 和 setter，但是 MDN 显示这两个 API 已被 deprecated，github 也已经有人提了 issue 和 pr。另外，通过这两个 API 设置 getter 和 setter 时，传递的函数的内部 this 指向原来的属性，比如： 1234let a = &#123; nickName: 'HotDog' &#125;a.__defineGetter__('name', function() &#123; return this.nickName // 此处 this 仍然指向 a&#125;) 学习了委托模式，可以把外部对象接收到的操作委托给内部属性（或其他对象）进行具体的处理。","categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://zhongdeming.fun/categories/Nodejs/"},{"name":"JavaScript","slug":"Nodejs/JavaScript","permalink":"http://zhongdeming.fun/categories/Nodejs/JavaScript/"}],"tags":[]},{"title":"从源码看 Vue 中的 Mixin","slug":"从源码看Vue中的Mixin","date":"2019-05-19T09:54:38.000Z","updated":"2021-05-07T21:21:43.640Z","comments":true,"path":"2019/05/19/从源码看Vue中的Mixin/","link":"","permalink":"http://zhongdeming.fun/2019/05/19/从源码看Vue中的Mixin/","excerpt":"最近在做项目的时候碰到了一个奇怪的问题，通过 Vue.mixin 方法注入到 Vue 实例的一个方法不起作用了，后来经过仔细排查发现这个实例自己实现了一个同名方法，导致了 Vue.mixin 注入方法的失效。后来查阅资料发现 Vue.mixin 注入到实例的 methods 方法会被实例中的同名方法替换，而不会依次执行。于是我就有了查看源码的想法，进而诞生了这篇文章～ 本文所用源码版本为 2.2.6 首先从 Vue.mixin 这个方法入手，打开 src 目录不难找到 mixin 所在的文件：src/core/global-api/mixin.js，其内容如下：","text":"最近在做项目的时候碰到了一个奇怪的问题，通过 Vue.mixin 方法注入到 Vue 实例的一个方法不起作用了，后来经过仔细排查发现这个实例自己实现了一个同名方法，导致了 Vue.mixin 注入方法的失效。后来查阅资料发现 Vue.mixin 注入到实例的 methods 方法会被实例中的同名方法替换，而不会依次执行。于是我就有了查看源码的想法，进而诞生了这篇文章～ 本文所用源码版本为 2.2.6 首先从 Vue.mixin 这个方法入手，打开 src 目录不难找到 mixin 所在的文件：src/core/global-api/mixin.js，其内容如下： 可以看到这只是一层简单的封装，核心内容基本都在 mergeOptions 方法中，所以下面打开这个方法所在的文件：src/core/util/options.js。注意 mergeOptions 方法是通过 src/core/util/index.js 引入导出的，其源码在 options.js 中，直接看 options.js 就好了。 在 options.js 中找到 mergeOptions 方法，内容如下： 其主流程大致如下： 如果是非生产环境下，首先调用 checkComponents 检查传入参数的合法性，后面再讲具体实现。 调用 normalizeProps 方法和 normalizeDirectives 方法对这两个属性进行规范化。 检查传入参数是否具有 extends 属性，这个属性表示扩展其它 Vue 实例，具体参考官方文档。这里为什么要检查这个属性呢？因为当传入对象具有该属性时，表示所有的 Vue 实例都要扩展它所指定的实例（Vue.mixin 的功能即是如此），那么我们在合并之前，需要先把 extends 进行合并，如果 extends 是一个 Vue 构造函数（也可能是扩展后的 Vue 构造函数），那么合并参数变为其 options 选项了；否则直接合并 extends。 检查完传入参数的 extends 属性之后，我们还要检查其 mixins 属性，这个属性的功能参考官方文档。因为如果传入的 Vue 配置对象仍然指定了 mixins 的话，我们需要递归的进行 merge。 做完以上的工作之后，就可以开始合并单纯的 mixin 参数了。可以看到通过 mergeField 函数进行了合并，先遍历合并的目标对象，进行合并了；随后遍历要合并的对象，只对目标对象上不存在的属性进行合并操作。那么合并的重点就到了 mergeFiled 函数了。 继续看 mergeField 函数： 1234function mergeField (key) &#123; const strat = strats[key] || defaultStrat options[key] = strat(parent[key], child[key], vm, key)&#125; 该函数通过 key 值在 strats 中选取合并的具体函数，这是一种典型的策略模式，所以我们看 strats是如何定义的。 options.js 中关于 strats 的定义如下： 123456/** * Option overwriting strategies are functions that handle * how to merge a parent option value and a child option * value into the final value. */const strats = config.optionMergeStrategies 其中 config 对象来自于 src/core/config.js，它定义了 config 的所有类型及初始值，当然初始值都还是一些空数组之类的，所以我们要在 options.js 中看具体的实现。 下面根据 Vue 的配置属性分开讲解不同的合并方式。 一、elel 的合并方式比较简单，因为它本身 源码如下： 1234567891011121314/** * Options with restrictions */if (process.env.NODE_ENV !== 'production') &#123; strats.el = strats.propsData = function (parent, child, vm, key) &#123; if (!vm) &#123; warn( `option \"$&#123;key&#125;\" can only be used during instance ` + 'creation with the `new` keyword.' ) &#125; return defaultStrat(parent, child) &#125;&#125; 可以看到这里有个条件，只有在开发环境下才会定义 strats.el 方法以及 propsData 方法（propsData 文档），这是因为这两个属性比较特殊，尤其是 propsData 只在开发环境下才使用，方便测试而已。另外一个比较特殊的地方是这两者只能在 new 操作符调用 Vue 构造函数所构造的 Vue 实例中才能存在，所以当 vm 未传递时，会弹出一个警告。 这两个属性的合并方法都是 defaultStrat，其源码如下： 12345678/** * Default strategy. */const defaultStrat = function (parentVal: any, childVal: any): any &#123; return childVal === undefined ? parentVal : childVal&#125; 可以看出在 childVal 已定义的时候直接替代 parentVal。 这个方法在后边还会用到。 二、datadata选项的合并是重中之重，因为 data 在子组件中是一个函数，它返回的也是一个特殊的响应式对象。 其源码如下： 这里分了两种情况，一种是传递了 vm 参数，一种是没传递。 当没传递 vm 参数的时候，需要校验 childVal 是否是函数，而 parentVal 不需要校验，因为它必须是函数才能通过之前的 merge 校验，到达现在这一步。确定都是函数之后，就调用这两个函数，再然后对返回的两个 data 对象通过 mergeData 做处理，这里后面再讲。 当传递了 vm 参数的时候，需要用其他方式处理，当是函数的时候，使用返回值做下一步合并；当是其他值的时候，直接使用其值进行下一步合并。 这一步要校验 childVal和 parentVal 是否为函数。正是因为这一步校验了，所以前面所讲的情况就不再需要校验，为什么呢？ 我们可以回头看 mergeOptions 的源码，发现其第三个参数 vm 是可选的，在递归的时候它会把 vm 传递给自身，这就导致当我们一开始调用 mergeOptions 的时候传递了 vm，则其后所有递归都会传递 vm；当我们一开始未传递 vm 值的时候，其后所有的递归也不会传递 vm 参数。那么是否有 vm 就取决于我们最开始调用该函数时所传递的参数是否包含 vm 了。 全局查找 mergeOptions 函数的调用，可以看到有两处： 第一处位于 src/core/instance/init.js，该文件也定义了 initMixin 方法，用于初始化 Vue 把传递给 Vue 构造函数的配置对象合并到 vm.$options 中。这种情况下会传递 vm，其值为当前正在构造的 Vue 实例。 第二处位于之前一直在讲的 src/core/global-api/mixin.js，这处才是定义的全局 API。 简而言之，Vue 构造函数构造 Vue 实例时，会调用 mergeOptions 并且传递 vm 实例作为第三个参数；当我们调用 Vue.mixin 进行全局混淆时是不会传递 vm 的。前者对应第二种情况，后者对应第一种情况。 当我们先构造 Vue 实例的时候，vm 被传递进而执行第二种情况，parentVal 会被校验，所以之后再调用 Vue.mixin 时第一种情况不再需要校验。 当我们先不实例化 Vue 而先调用 Vue.mixin 时，会先执行第一种情况的代码，那么会导致 bug 出现吗？答案肯定是不会，因为此时 parentVal 为 undefined，因为 Vue.mixin 调用时 parentVal 的初始值为 Vue.options，这个对象根本不包含 data 属性。 那么 data 合并的任务主要在 mergeData 函数中了，查看其源码： 可以看到这里遍历了要合并的 data 的所有属性，然后根据不同情况进行合并： 当目标 data 对象不包含当前属性时，调用 set 方法进行合并，后面讲 set。 当目标 data 对象包含当前属性并且当前值为纯对象时，递归合并当前对象值，这样做是为了防止对象存在新增属性。 继续看 set 函数： 可以看到 set 也对 target 分了两种情况进行处理。首先判断了 target 是数组的情况，然后如果 target 包含当前属性，那么就直接赋值。接下来判断了 target 是否是响应式对象，如果是的话就会在开发环境下弹出警告，最好不要让 data 函数返回一个响应式对象，因为会造成性能浪费。如果不是响应式对象也可以直接赋值返回，其他情况下就会进一步转化 target 为响应式对象，并收集依赖。 以上大概就是 data 的合并方式，可以看出来如果实例指定了与 mixins 相同名称的 data 值，那么以实例中的为准，mixin 中执行的 data 会失效，如果都是对象但是 mixin 中新增了属性的话，还是会被添加到实例 data 中去的。 三、生命周期钩子（Hooks）Hooks 的合并函数定义为 mergeHook 钩子，其源码如下： 123456789101112131415/** * Hooks and props are merged as arrays. */function mergeHook ( parentVal: ?Array&lt;Function&gt;, childVal: ?Function | ?Array&lt;Function&gt;): ?Array&lt;Function&gt; &#123; return childVal ? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal] : parentVal&#125; 这个比较简单，代码注释也写得很清楚了，Vue 实例的生命周期钩子被合并为一个数组。具体有哪些钩子可以被合并被写在 src/core/config.js 中： 123456789101112131415/** * List of lifecycle hooks. */_lifecycleHooks: [ 'beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeUpdate', 'updated', 'beforeDestroy', 'destroyed', 'activated', 'deactivated'], 合并 assets （components、filters、directives）的方法也比较简单，下面跳过了。 四、watch合并 watch 的函数源码如下： 这一段源码也很简单，注释也很明了，跟生命周期的钩子一样，Vue.mixin 会把所有同名的 watch 合并到一个数组中去，在触发的时候依次执行就好了。 五、props、methods、computed这三项的合并都使用了相同的策略，源代码如下： 这里的处理也比较简单，可以看出来当多次调用 Vue.mixin 混淆时，同名的 props、methods、computed 会被后来者替代；但是当 Vue 构造函数传递了同名的属性时，会以构造函数所接受的配置对象为准。因为 Vue 实例化时也会调用 mergeOptions 第二个参数即为 Vue 构造函数所接受的配置对象，正如前文所述。 六、一些辅助函数前文有讲到几个辅助函数，比如：checkComponents、normalizeProps、normalizeDirectives。这里简单贴一下源码： checkComponents 这个函数是为了检查 components 属性是否符合要求的，主要是防止自定义组件使用 HTML 内置标签。 normalizeProps 这个函数主要是对 props 属性进行整理。包括把字符串数组形式的 props 转换为对象形式，对所有形式的 props 进行格式化整理。 normalizeDirectives 这个函数也主要是对 directives 属性进行格式化整理的，把原来的对象整理成一个新的符合标准格式的对象。 七、自定义合并策略看到 Vue 的官方文档：自定义选项合并策略，它允许我们自定义合并策略，具体方式就是替换 Vue.config.optionsMergeStrategies，也就是前文所提到的那个定义在 src/core/config.js 中的属性。我们也可以看一下源代码，这一功能在 src/core/global-api/index.js 文件中的 initGlobalAPI 定义。 12345678910const configDef = &#123;&#125;configDef.get = () =&gt; configif (process.env.NODE_ENV !== 'production') &#123; configDef.set = () =&gt; &#123; warn( 'Do not replace the Vue.config object, set individual fields instead.' ) &#125;&#125;Object.defineProperty(Vue, 'config', configDef) 可以看到最后一句给 Vue 函数定义了一个 config 属性，其 property 定义为 configDef。在生产环境下不允许设置其值，但是在开发环境下，我们可以直接设置 Vue.config。那么通过设置 Vue.config.optionsMergeStrategies，我们可以改变合并策略，在后面再进行合并操作时，都会读取 config 对象中的属性，这时就可以使用我们自定义的合并策略进行合并了。 八、总结看了这些属性的合并方式以后，对 Vue.mixin 的工作方式也有了一定的了解了。个人认为基本上可以把 Vue.mixin 合并属性的方式分为三类，一类是替换式、一类是合并式、还有一类是队列式。 替换式的有 el、props、methods 和 computed，这一类的行为是新的参数替代旧的参数。 合并式的有 data，这一类的行为是新传入的参数会被合并到旧的参数中。 队列式合并的有 watch、所有的生命周期钩子（hooks），这一类的行为是所有的参数会被合并到一个数组中，必要时再依次取出。 所以对于 Vue.mixin 的使用我们也需要小心，尤其是替换式合并的属性，当你在 mixins 里面指定了以后，就不要再实例中再指定同名属性了，那样的话你的 mixins 中的属性会被替代导致失效。 作者水平有限，文章难免存在纰漏，敬请大家指正。","categories":[{"name":"Vue","slug":"Vue","permalink":"http://zhongdeming.fun/categories/Vue/"},{"name":"JavaScript","slug":"Vue/JavaScript","permalink":"http://zhongdeming.fun/categories/Vue/JavaScript/"}],"tags":[]},{"title":"常见 Web 性能优化方式","slug":"WebPerf101","date":"2019-05-06T15:39:01.000Z","updated":"2021-05-07T21:21:43.640Z","comments":true,"path":"2019/05/06/WebPerf101/","link":"","permalink":"http://zhongdeming.fun/2019/05/06/WebPerf101/","excerpt":"这篇文章是我阅读 Web Performance 101 之后的进行的粗糙的翻译作为笔记，英语还行的童鞋可以直接看原文。 这篇文章主要介绍了现代 web 加载性能（注意不涉及代码算法等），学习为什么加载性能很重要、有哪些优化的方法以及有哪些工具可以帮助我们对网站进行优化。 为什么性能优化很重要？ 首先，加载缓慢的网站让人很不舒服！ 最明显的例子就是当一个移动网站加载太慢的时候，用户体验如同观看一部恐怖电影。","text":"这篇文章是我阅读 Web Performance 101 之后的进行的粗糙的翻译作为笔记，英语还行的童鞋可以直接看原文。 这篇文章主要介绍了现代 web 加载性能（注意不涉及代码算法等），学习为什么加载性能很重要、有哪些优化的方法以及有哪些工具可以帮助我们对网站进行优化。 为什么性能优化很重要？ 首先，加载缓慢的网站让人很不舒服！ 最明显的例子就是当一个移动网站加载太慢的时候，用户体验如同观看一部恐怖电影。 图片来源： Luke Wroblewski 第二，网站性能直接影响你的产品质量。 —— 2016 年，AliExpress 将他们网站的性能提升了三分之一，然后他们收到的订单增加了 10.5%！ ——2006 年，谷歌曾经尝试将他们的搜索放慢 0.5 秒然后发现用户的搜索（请求）次数减少了 25%。 ——2008 年，Aberdeen 集团发现将网站放慢 1s，会导致用户满意度下降 16%。 此外还有一系列如上的数据，不管是新的还是旧的：(wpostats.com · pwastats.com)。 这就是为什么网站性能很重要。 现在，我们需要弄懂当我们说一个网站很快意味着什么。 在什么情况下可以说一个网站很快？ ——它必须加载很快（文件下载、界面渲染）， ——然后，在加载之后，它必须很快的执行（比如动画不跳帧、滚动很丝滑）。 网站加载很快意味着： ——服务器对于客户端请求响应很快， ——网站自身加载渲染很快。 在这篇文章中，我们将会讨论这个因素：如何让网站快速加载以及渲染。 有哪些性能优化方式？JavaScript一、压缩代码先从 JavaScript 开始吧。通常情况下，JavaScript 是网站加载缓慢的根源。 第一种 JavaScript 优化方式是压缩，如果你已经知道了的话，直接跳过吧。 什么是压缩？在一般情况下，人们写 JavaScript 代码会使用一种方便的格式，包含缩进、富有含义的长变量名、写注释等等。因为这种方式，代码具有很高的可读性，但是多余的空格和注释会使得 JavaScript 文件变得很大。 为了解决这个问题，人们想到了代码压缩。在压缩的过程中，代码会被去掉所有不必要的字母，替换成短的变量名，去掉注释等等。在最后，代码文件变得比之前更小，但是代码的功能并不受影响。 代码压缩可以将代码文件减小大约 30% ～ 40%。 主流的代码打包工具都支持代码压缩： —— mode: production in webpack, —— babel-preset-minify in Babel, —— gulp-uglify in Gulp 二、使用 async 和 defer 接下来，你写了一个 JavaScript 脚本，然后进行了压缩，现在想要在页面中加载它。该如何做呢？ 最简单的方式就是写一个 script 标签，然后 src 属性指向你所写脚本的路径，然后它就可以照常开始工作啦！ 但是，你知道这种方法有什么问题吗？ 问题就在于 JavaScript 会阻塞渲染。 这是什么意思？ 当你的浏览器加载页面的时候，它会转换 HTML 文档成为标签，然后构建 DOM 树。随后它会使用 DOM 树渲染页面。 问题在于，JavaScript 代码可以改变 DOM 树的构建方式。 例如，JavaScript 可以通过 document.write 写一个 HTML 注释的起始标签到文档中，然后整个 DOM 树都会被毁掉。 这就是为什么浏览器在碰到 script 标签的时候会停止渲染页面，这样做可以防止 document 做多余的工作。 从浏览器的角度来看： ——浏览器遍历文档，然后会解析它 ——在某些时刻，浏览器遇到了 script 标签，然后停止了 HTML 转换，它开始下载并执行那些 script 代码 ——一旦代码执行完毕，浏览器继续遍历 HTML 文档，然后渲染页面 实际上，这意味着当你添加一个 script 标签到页面中时，它后面的内容在它下载并执行完毕之前都是不可见的。如果你添加一个 script 到 head 标签中，所有的内容都会变得不可见——直到 script 被下载执行完毕。 那我们该怎么办呢？应该使用 async 和 defer 属性。 这些属性让浏览器直到 script 脚本可以在后台下载，不必阻塞文档渲染，下面是详细的介绍： ——async 让浏览器异步下载（在后台）script 代码，然后继续解析渲染 HTML。（如果在页面渲染完毕之前，script 代码已经下载好了，那么就先停止渲染，先执行 script 代码。由于下载所消耗的时间通常大于 HTML 转化，所以这种情况实际上不多见）。 ——defer会告诉浏览器在后台异步下载 script 代码，直到 HTML 转化渲染完毕才开始执行这些 script 代码。 这里有两大不同点： ——async script 标签会在下载之后尽快地执行，它们的执行顺序没有规律。这就意味着有 async 属性的 React bundle script 和 app bundle script 在同一时刻开始下载，由于 app bundle 更小所以会先下载完毕，导致 app 的 bundle script 先执行。然后网站就崩掉了～ ——defer 不像 async，会在加载以及文档渲染完毕之后按照 script 标签的顺序开始执行，因此，defer 是更适合的优化方案。 三、代码切割 继续。 很多时候，应用都是打包到一个 bundle 里面，然后每次请求都发送到客户端。但是这样做的问题在于有些页面我们见到的场景很少，但是它们的代码同样被打包到了我们的 bundle 中，这样每次页面加载的代码多于实际需要，造成了性能浪费。 这个问题通常使用代码切割进行解决，把大的 bundle 切割成一个个小的。 通过代码切割，我们把不同功能的代码打包到了不同的文件，只在必要的时候加载必要的代码。由于使用这样的做法，用户再也不会下载他们不需要用到的代码了。 那么我们怎么切割代码呢？ 首先，你需要一个代码打包工具，比如 Webpack、Parcel 或者 Rollup。所有的这几个工具都支持一个特殊函数 import()。 在浏览器中，import() 接受传递给它的 JS 文件并异步下载该文件。这可以用于加载应用程序一开始不需要但是接下来可能会用到的库。 但是在打包工具中，import() 的功能又有所不同。如果你在代码中传递了一个文件给 import() 并且在之后进行打包，打包工具会把这个文件以及其所有的依赖打包到一个单独的文件中。app 运行到 import 函数时会单独下载这个文件。 因此，在上方的例子中，webpack 会把 ChangeAvatarModal.js 及其依赖打包到单独文件中。在代码执行到 import 时，这个单独文件会被下载。 这就是实际的代码切割。 第二，在 React 和 Vuejs 中，会有基于 import() 的工具能够让你的代码切割工作更加轻松。 例如，react-loadable 是一个组件，用于等待其他组件加载，在其他组件加载时，它会进行占位。React 16.6 添加了一个相似的内置功能组件，叫做 Suspense。此外 Vuejs 也已经支持异步组件一段时间了。 如果优化得很好的话，我们可以减少很多不必要的数据的下载，代码切割能够成为最重要的流量优化工具。 如果你的 app 只能做一种优化的话，那就是代码切割。 四、移除依赖中的未使用代码 另外一个重要的优化点在于包的依赖。 ——例如，momentjs 这个库，用于进行时间操作，它包含了大约 160 kb 大小的不同语言的文件包。 ——React 甚至把 propTypes 包含在生产环境的包中，尽管这不是必要的。 ——Lodash，你很有可能引入了整个完整的包，尽管你可能只需要其中的一两个方法。 上面这些就是把不必要的代码引入打包的情况。 为了帮助开发者移除多余的代码，作者和谷歌一起维护了一个 repo 收集关于如何在 webpack 中优化你的依赖，使用这些建议可以让你的 app 更快更轻巧！ → GoogleChromeLabs/webpack-libs-optimizations 五、总结 以上都是 JavaScript 的优化方式，总结起来就是： ——压缩你的 js 代码 ——使用 async 和 defer 加载 script ——切割你的代码，让应用只加载必须的代码 ——移除依赖中实际未使用的代码 CSS接下来是如何优化 css 代码。 一、压缩 CSS 代码首先，压缩 CSS，就像 JavaScript 代码一样。删除不必要的空格和字母来使你的代码更小。 这些工具可以帮助你压缩 CSS 代码： —— webpack’s postcss-loader with cssnano —— PostCSS’s cssnano —— Gulp’s gulp-clean-css 二、提取 Critical CSS 第二、styles 阻塞渲染，就像之前 script 那样。 因为没有样式的网站看起来很奇怪。 如果浏览器在样式加载之前渲染页面，那么用户就会看到上面那样的情况。 然后页面就会闪烁，然后就会看到上面截图这样子，很难说是一种好的用户体验。 这就是为什么样式加载的时候页面会是空白的。 现在有一种比较机智的优化方式。浏览器在加载样式之前保持空白页是很有理由的，我们不必从这一点下手。但是我们仍然可以想办法让页面渲染更快——让页面只加载渲染初始界面所必要的样式，剩余的样式在之后加载，这些渲染初始界面所必要的样式称为“Critical CSS”。 让我们看看是怎么做的。 1、把页面样式分为 critical 的和 non-critical 的。 2、把 critical CSS 嵌入到 HTML，真能够让它们尽快地被加载。 现在，当你加载页面的时候，页面能够很快地被渲染，但是你仍然得加载那些不重要的 CSS。 有多种方式可以加载剩余的 CSS，下面的方式是我所倾向的： 3、使用&lt;link rel=&quot;preload&quot;&gt; 获取非必要的 CSS。 4、一旦文件被加载到缓存以后，把 rel 属性从 preload 切换为 stylesheet。这可以让浏览器从缓存中获取 CSS 并应用到页面中。 那我们怎么知道哪些 CSS 是必须的，哪些 CSS 是不必须的呢？通常情况下，规则如下： 1移除 CSS 样式知道页面看起来变得滑稽，那么剩下的 CSS 就是必要的。 例如，页面的布局样式或者文章的文本样式是必须的，因为缺少它们会使得页面看起来很烂。而 JavaScript 弹出窗或者页脚的样式是非必须的，因为用户不会在一开始就看到它们，缺少那些样式，页面看起来仍然十分完美。 听起来可能比较复杂，但是有很多自动化工具可以帮助我们完成这项工作。 —— styled-components. It’s a CSS-in-JS library that extracts and returns critical styles during server-side rendering. It works only if you already write styles using styled-components, but if you do, it works really well. ——critical. It’s a utility that takes an HTML page, renders it in a headless browser and extracts styles for above-the-fold content. Because critical runs only over a single page, it might not work well for complex single-page apps. —— penthouse. It’s similar to critical but works with URLs instead of HTML pages. 这种做法一般可以节约 200 ～ 500 ms 左右的首屏渲染时间。 了解更多 Critical CSS 的知识，阅读 the amazing Smashing Magazine’s guide. 三、总结 这就是 CSS 优化的主要策略，总结起来就是： ——压缩 CSS 代码 ——提取必要的 CSS，让页面首先加载它们 HTTP现在让我们看看 HTTP 的优化。 一、压缩代码让 HTTP 传输较少数据的方式仍然是压缩代码，本节主要说压缩 HTML 代码，JS、CSS 的代码压缩在之前已经讲过了。 二、GZIP 压缩 压缩代码的第二种方式是 GZIP 压缩。 Gzip 是一种算法，它可以使用复杂的归档算法压缩你发送到客户端的数据。在压缩之后，你的文件看起来像是无法打开的二进制文件，但是它们的体积会减小 60% 到 80%。浏览器接受这些文件之后会自动进行解压缩。 基本上，使用 Gzip 已经是生产环境的标准，因此如果你使用一些流行的服务器软件比如 Apache 或者 Nginx，你就可以修改配置文件开启 Gzip 压缩。 Apache instructions · Nginx instructions 注意： 使用这些说明启用 Gzip 将会导致服务器动态压缩资源，这会增加服务器响应时间。在大多数情况下你不需要关心这一点，但如果你希望提高响应时间，可以在构建的时候进行资源预压缩。 注意： 不要对文本文件之外的文件进行 Gzip 压缩！ 图像、字体、视频或者其他二进制文件通常已经被压缩过了，因此对它们进行 Gzip 压缩只会延长响应时间。SVG 图片是唯一的例外，因为它也是文本。 三、Brotli 压缩 Gzip 有一个替代品，一种叫 Brotli 的算法。 Brotli 的优点：同样的 CPU 载荷下，它压缩效率比 Gzip 高 20% 到 30%。就是说可以减少 30% 下载量！ Brotli 的缺点：它很年轻，浏览器以及服务器的支持度还不够，所以你不能用它来替代 Gzip。但是可以针对不同的浏览器使用 Gzip 或者 Brotli。 Apache 从 2.4.26 开始支持 Brotli，Nginx 有外部模块支持 Brotli。 Apache instructions · Nginx module 注意： 不要把 Brotli 的压缩等级设置到最大，那样会让它压缩得比 Gzip 慢。设置为 4 是最好的，可以让 Brotli 压缩得比 Gzip 更小更快。 四、CDN 现在，我们聊聊 CDN。 什么是 CDN？假设你在美国假设了一个应用。如果你的用户来自华沙，他们的请求不得不从波兰发出，一路颠簸来到美国，然后又得回到波兰。这个请求过程将会消耗很多时间： ——网络请求要跨越很长的一段距离 ——网络请求要经过很多路由或者类似设备（每个设备都有一段处理时间） 如果用户想要获取 app 数据，而且只有美国的服务器知道如何处理数据，那上面这些过程好像都是必要的。但对于静态内容而言，上面的请求过程完全没有必要，因为它们请求的只是一些静态内容，完全可以部署到任何服务器上。 CDN 服务就是用来解决这个问题的。CDN 代表“Content Delivery Network（静态内容分发）”，CDN 服务在全世界提供许多服务器来 “serve” 静态文件。如果要使用的话，只需要在一个 CDN 服务注册，然后上传你的静态文件，然后更新 app 中引用的文件的地址，然后每个用户都会引用离他们最近的服务器上的静态文件了。 根据我们的经验，CDN 基本上能把每个请求的延迟从上百毫秒减少到 5-10 毫秒。考虑到当页面打开时有很多资源要加载，CDN 的优化效果是很惊人的。 五、资源预加载 你知道吗？谷歌在你开始点击搜索之前已经在加载搜索结果的第一项了。这是因为三分之一的用户会首先点击第一个搜索结果，预加载内容可以让用户更快的看到目标页面。 如果你确定你的页面或者资源会在不久之后被用到，浏览器允许你进行预加载。 有五种方法可以实现预加载，它们每一种的适用场景都不同： ——&lt;link rel=&quot;dns-prefetch&quot;&gt; 提示浏览器对一个 IP 地址提前进行 DNS 请求。这对于 CDN 请求很有用，此外一些你知道域名但是不知道具体地址的资源的预加载也可以使用。 ——&lt;link rel=&quot;preconnect&quot;&gt; 提示浏览器提前连接到某台服务器。在 dns-prefetch 适用的场景同样适用，但它可以建立完整的连接并节约很多时间。缺点是打开新的连接很消耗资源，因此不要过度使用。 ——&lt;link rel=&quot;prefetch&quot;&gt; 会在后台对资源进行低优先级预加载然后缓存，这个比较有用，比如在进入 SPA 的下一个页面之前加载 bundle。 ——&lt;link rel=&quot;preload&quot;&gt; 会在后台对资源进行高优先级的预加载。这对于加载短时间内即将用到的资源而言比较有用。 ——&lt;link rel=&quot;prerender&quot;&gt; 会在后台预加载特定页面，然后在不可见的 tab 中渲染页面。当用户进入这个页面时，页面可以立马呈现在用户面前。这是谷歌用于预加载第一条搜索结果的方案。 注意： 不要过度使用预加载，虽然预加载能够提升用户体验、加速应用，但是会导致不必要的流量消耗；尤其是在移动端，用户会消耗过多的不要的流量，这同样会降低用户体验。 阅读更多：Preload, prefetch and priorities in Chrome · Prefetching, preloading, prebrowsing 六、总结 HTTP 优化方式: —— 压缩 HTML 代码，就像其它资源那样 —— 使用 Gzip and Brotli 压缩文本资源 —— 使用 CDN 节省静态资源的下载时间 —— 预加载一会将要用到的资源 图片 继续，说说图片优化。 一、合适的格式 图片消耗了大量的流量，但庆幸的是图片加载不阻塞渲染。但图片优化仍然是必要的，我们需要让图片加载更快、消耗更少的流量。 第一，也是最重要的一点，选择合适的图片格式。 最常见的图片格式是：svg、jpg、png、webp和 gif。 svg 最适合矢量图，比如 icon 和 logo。 jpg 最适合照片，因为它压缩图片时质量损耗最小，以至于肉眼难以发现。 png 适合没有任何质量损失的光栅图形 - 例如光栅图标或像素艺术。 webp 最适合照片或者光栅图片，因为它支持有损或者无损压缩。它的压缩比也比 jpg 和 png 更优秀。 不幸的是 webp 只能在 chrome 使用，但是你仍然可以使用 jpg 和 png 来实现一个 fallback。 上面就是具体实现。 这样写的话，支持 webp 的浏览器会加载 webp 格式的图片，不支持 webp 格式的浏览器会加载 jpg 最为备用方案。 最后是 gif。 不要使用 gif，它非常笨重。超过 1M 的 gif 最好使用视频文件代替，可以更好的压缩内容。 See also: Replace Animated GIFs with Video at WebFundamentals 二、图片压缩 除了使用合适的图片格式以外，图片压缩也可以是优化方案。下面是几种图片压缩方式： 首先是 svg： ——压缩。因为 svg 图片是文本，所以可以移除空格和注释 ——简化 path，如果 svg 是自动工具生成的，其内部的 path 可能会很复杂，这种情况下，移除那些不影响 svg 样式的 path ——简化 svg 文件结构，如果 svg 是自动工具生成的，通常会包含很多多余的 meta 元素，移除它们可以减小文件体积 这些优化方式都可以直接使用 svgo 实现，它还有 UI 界面：a great UI for svgo 第二个：jpg。 ——减小图片维度。根据我的经验，这是一个开发人员使用 jpg 常犯的错误 这种情况常发生于我们把一张大尺寸的图片塞进一个小尺寸的容器中时。比如我们把一张 2560 1440 px 的图片放到一个 533 300 px 的容器中。 当这种情况发生时，浏览器会加载过大的文件，然后还要花时间缩小图片，知道能够塞进去那个小小的容器，这些都是无用功。 要解决这个问题，可以直接在你的 PS 或者其他工具中对图片进行编辑；或者你也可以使用 webpack loader（比如 responsive-loader）。如果要使用大尺寸图片适配高分屏，可以通过 &lt;picture&gt; 或者 &lt;img srcset&gt; 代替。 还可以对 jpg 进行图片降维压缩，图片质量压缩到原来的 70 ～ 80，图片压缩导致的质量损失会很难发现。 上面可以看出压缩后图片质量损失不大。 但是我们可以看到图片的大小减小了很多。这就是为什么推荐对 jpg 图片进行 70-80 水平的压缩，因为图片信息损失很小，但是体积压缩很大。 除了以上方式外，我们还可以使用渐进式图片。 上方是非渐进式图片加载的方法。 这是一张渐进式的图片的加载方式。 可以通过 PS 或者 Gimp 制作渐进式图片。也可以使用 webpack-loader（比如 image-webpack-loader）或者其他工具。 注意： 渐进式图片可能比常规图片更大，而且解码更慢。 第三，png。 ——使用隔行扫描 PNG。 隔行扫描 PNG 的工作方式与渐进式 JPEG 相同：它从低质量开始渲染，但在加载时进行改进。 但它不是适合所有场景。例如，逐步加载 PNG 图标看起来很奇怪 - 但它可能适用于其他某些图像。 ——使用索引颜色。 通过使用索引颜色，PNG 图片将其所有颜色放入调色板中并使用它来引用每种颜色。 这使得每个像素所需的字节数更小，并且可能有助于降低整体图像权重。 由于调色板大小有限（最多256种颜色），因此此解决方案不适用于具有大量颜色的图像。 这两种方式都可以通过图片编辑器或者 image-webpack-loader 或者其他工具实现。 以上的所有优化都可以使用自动化工具完成，之前都已经提到过，但是这里再总结一下： — webpack has image-webpack-loader which runs on every build and does pretty much every optimization from above. Its default settings are OK — For you need to optimize an image once and forever, there’re apps like ImageOptim and sites like TinyPNG. — If you can’t plug a webpack loader into your build process, there’re also a number of CDNs and services that host and optimize images for you (e.g., Akamai, Cloudinary, or imgix). 三、总结 图片优化总结： ——选择合适的图片格式 ——通过图片降维、质量压缩或者使用渐进式图片优化图片加载时间 字体 最后一个优化方式就是字体了。 有时候页面加载好了，所有的样式、布局都已经可见了，但是字体还没有出现或者显示异常，这就是字体问题所导致的，自定义字体尚未下载完毕，这个时候浏览器会等待几秒，如果仍然未下载，浏览器才会使用备用字体作为替代。 这种行为在某种程度上避免了字体的闪烁，但是在缓慢的网络条件下，这种行为使得页面加载变得缓慢。 一、指定 fallback 字体我们需要了解一下如何优化这种情况。 首先，要记得设置 fallback 字体。 fallback 字体会在自定义字体无法下载或者下载时间过长时被使用。它在 CSS 的 font 或者 font-family 的第一个指定字体后面指定，比如上方的Arial, sans-serif。 fallback 字体应当是比较流行的内置字体（比如 Georgia）；也可以是比较通用的字体系列（如 serif 或者 sans-serif）；通常情况下，即使你指定了内置的字体作为 fallback，但是你仍然需要添加一个通用的字体系列——因为内置字体可能也会在某些设备上缺失。 没有 fallback 字体的话，一旦自定义字体缺失，浏览器会使用默认的 serif font 进行渲染。这样可能会导致页面比较难看。 使用 fallback 字体，至少你有机会定义一个和你的自定义字体相近的字体作为备用方案。 二、使用 font-display 第二点优化，使用 CSS 的 font-display 属性指定自定义字体。 font-display 属性会调整自定义字体的应用方式。默认情况下，它会设置为 auto，在大部分主流浏览器中，意味着浏览器会等待自定义字体加载 3s。这意味着如果网络太慢的话，用户需要等待 3s 后字体才会显示。 这很不好，为了优化这一点，指定 font-display。 Note: in Microsoft Edge, the font-display: auto behavior is different. With it, if the custom font is not cached, Edge immediately renders the text in the fallback font and substitutes the custom font later when it’s loaded. This is not a bug because font-display: auto lets browsers define the loading strategy. 有两个 font-display 的值我认为比较适用于大部分情况。 第一个是 font-display: fallback。这样指定的话，浏览器会使用最早能够获得的字体立即渲染，不管是已经缓存的自定义字体还是 fallback 字体。如果自定义字体没有被缓存的话，浏览器会下载它。如果下载得足够快（通常是 3s 内），浏览器会使用自定义字体替换 fallback 字体。 这种情况下，用户可能会在读 fallback 字体的文本时，浏览器突然进行字体替换，这对于用户体验而言并不是很差，总比不显示任何字体要强。 第二个适用的 font-display 值是 optional。使用这个值，浏览器同样会立即使用可获得的字体进行文本渲染：不管是已缓存的自定义字体还是 fallback 字体。但是当自定义字体未缓存时，在下载好自定义字体后，浏览器不会立即替换已有的 fallback 字体，直到页面下一次刷新。 这种行为意味着用户始终只会看到一种字体，不会出现字体替换的情况。 那我们该如何选择这两个值呢？ 我相信这是一个品味问题。 我个人更喜欢用自定义字体展示文本，因此我选择 font-display：fallback 值。 如果你觉得访问者第一次访问时看到 fallback 字体的页面没有什么关系，那么 font-display：optional 对您来说非常有用。 Note: this font-display trick is not applicable to icon fonts. In icon fonts, each icon is usually encoded by a rarely used Unicode character. Using font-display to render icons with a fallback font will make random characters appear in their place. 三、总结 字体优化方案的总结： —— 指定合适的 fallback（备用）字体 (还有通用的字体系列) —— 使用 font-display 来配置自定义字体的应用方式。 有哪些可用的优化工具 最后是一些有助于页面性能优化的工具。 第一个是 Google PageSpeed Insights。 第二个是 Lighthouse。 第三个是 WebPageTest。 最后一个是 webpack 插件：webpack-bundle-analyzer。 具体的介绍就没写了，点进去直接用就知道啦。 感谢阅读！ 原作者推特：@iamakulov。 Thanks to Arun, Anton Korzunov, Matthew Holloway, Bradley Few, Brian Rosamilia,Rafael Keramidas, Viktor Karpov, and Artem Miroshnyk (in no particular order) for providing feedback on drafts. 水平有限，难免存在纰漏，敬请大家斧正！","categories":[{"name":"Web 性能优化","slug":"Web-性能优化","permalink":"http://zhongdeming.fun/categories/Web-性能优化/"}],"tags":[]},{"title":"解密虚拟 DOM——snabbdom 核心源码解读","slug":"snabbdom","date":"2019-04-27T09:18:03.000Z","updated":"2021-05-07T21:21:43.640Z","comments":true,"path":"2019/04/27/snabbdom/","link":"","permalink":"http://zhongdeming.fun/2019/04/27/snabbdom/","excerpt":"本文源码地址：https://github.com/zhongdeming428/snabbdom 对很多人而言，虚拟 DOM 都是一个很高大上而且远不可及的专有名词，以前我也这么认为，后来在学习 Vue 源码的时候发现 Vue 的虚拟 DOM 方案衍生于本文要讲的 snabbdom 工具，经过阅读源码之后才发现，虚拟 DOM 原来就是这么回事，并没有想象中那么难以理解嘛～ 这篇文章呢，就单独从 snabbdom 这个库讲起，不涉及其他任何框架，单独从这个库的源码来聊一聊虚拟 DOM。 在讲 snabbdom 之前，需要先学习 TypeScript 知识，以及 snabbdom 的基本使用方法。 一、snabbdom 核心概念在学习 snabbdom 源码之前，最好先学会用 snabbdom，至少要掌握 snabbdom 的核心概念，这是阅读框架源码之前基本都要做的准备工作。 以下内容可以直接到 snabbdom 官方文档了解。","text":"本文源码地址：https://github.com/zhongdeming428/snabbdom 对很多人而言，虚拟 DOM 都是一个很高大上而且远不可及的专有名词，以前我也这么认为，后来在学习 Vue 源码的时候发现 Vue 的虚拟 DOM 方案衍生于本文要讲的 snabbdom 工具，经过阅读源码之后才发现，虚拟 DOM 原来就是这么回事，并没有想象中那么难以理解嘛～ 这篇文章呢，就单独从 snabbdom 这个库讲起，不涉及其他任何框架，单独从这个库的源码来聊一聊虚拟 DOM。 在讲 snabbdom 之前，需要先学习 TypeScript 知识，以及 snabbdom 的基本使用方法。 一、snabbdom 核心概念在学习 snabbdom 源码之前，最好先学会用 snabbdom，至少要掌握 snabbdom 的核心概念，这是阅读框架源码之前基本都要做的准备工作。 以下内容可以直接到 snabbdom 官方文档了解。 snabbdom 的一些优点snabbdom 主要具有一下优点： 核心部分的源代码只有两百多行（其实不止），容易读懂。 通过 modules 可以很容易地扩展。 钩子函数很丰富，用户可以通过钩子函数直接干涉 Vnode 到 DOM 挂载到最终销毁的全过程。 性能很棒。 容易集成。 modules 的一些优点 通过 h 函数，可以很容易地创建 Vnode。 通过 h 函数可以创建 SVG 元素。 事件处理能力强大。 可以通过 Thunks 优化 DOM Diff 和事件。 第三方支持很多的优点通过一些第三方的插件，可以很容易地支持 JSX、服务端 HTML 输出等等…… 核心 API较为核心的 API 其实就四个：init、patch、 h和tovnode，通过这四个 API 就可以玩转虚拟 DOM 啦！ 下面简单介绍一下这四个核心函数： init：这是 snabbdom 暴露出来的一个核心函数，通过它我们才能开始使用许多重要的功能。该函数接受一个数组作为参数，数组内都是 module，通过 init 注册了一系列要使用的 module 之后，它会给我们返回一个 patch 函数。 patch： 该函数是我们挂载或者更新 vnode 的重要途径。它接受两个参数，第一个参数可以是 HTML 元素或者 vnode，第二个元素只能是 vnode。通过 patch 函数，可以对第一个 vnode 进行更新，或者把 vnode 挂载/更新到 DOM 元素上。 tovnode： 用于把真实的 DOM 转化为 vnode，适合把 SSR 生成的 DOM 转化成 vnode，然后进行 DOM 操作。 h： 该函数用于创建 vnode，在许多地方都能见到它的身影。它接受三个参数： 123@param &#123;string&#125; selector|tag 标签名或者选择器@param &#123;object&#125; data 数据对象，结构在后面讲@param &#123;vNode[]|string&#125; children 子节点，可以是文本节点 Module 模块Module 是 snabbdom 的一个核心概念，snabbdom 的核心主干代码只实现了元素、id、class（不包含动态赋值）、元素内容（包括文本节点在内的子节点）这四个方面；而其他诸如 style 样式、class 动态赋值、attr 属性等功能都是通过 Module 扩展的，它们写成了 snabbdom 的内部默认 Module，在需要的时候引用就行了。 那么 Module 究竟是什么呢？ snabbdom 的官方文档已经讲得很清楚了，Module 的本质是一个对象，对象的键由一些钩子（Hooks）的名称组成，键值都是函数，这些函数能够在特定的 vnode/DOM 生命周期触发，并接受规定的参数，能够对周期中的 vnode/DOM 进行操作。 由于 snabbdom 使用 TypeScript 编写，所以在之后看代码的时候，我们可以非常清楚地看到 Module 的组成结构。 内置 Module 有如下几种： class：动态控制元素的 class。 props：设置 DOM 的一些属性（properties）。 attributes：同样用于设置 DOM 属性，但是是 attributes，而且 properties。 style：设置 DOM 的样式。 dataset：设置自定义属性。 customProperties：CSS 的变量，使用方法参考官方文档。 delayedProperties：延迟的 CSS 样式，可用于创建动画之类。 Hooks 钩子snabbdom 提供了丰富的生命周期钩子： 钩子名称 触发时机 Arguments to callback pre patch 开始之前。 none init 已经创建了一个 vnode。 vnode create 已经基于 vnode 创建了一个 DOM，但尚未挂载。 emptyVnode, vnode insert 创建的 DOM 被挂载了。 vnode prepatch 一个元素即将被 patch。 oldVnode, vnode update 元素正在被更新。 oldVnode, vnode postpatch 元素已经 patch 完毕。 oldVnode, vnode destroy 一个元素被直接或间接地移除了。间接移除的情况是指被移除元素的子元素。 vnode remove 一个元素被直接移除了（卸载）。 vnode, removeCallback post patch 结束。 none 如何使用钩子呢？ 在创建 vnode 的时候，把定义的钩子函数传递给 data.hook 就 OK 了；当然还可以在自定义 Module 中使用钩子，同理定义钩子函数并赋值给 Module 对象就可以了。 注意 Module 中只能使用以下几种钩子：pre, create, update, destroy, remove, post。 而在 vnode 创建中定义的钩子只能是以下几种：init, create, insert, prepatch, update, postpatch, destroy, remove。为什么 pre 和 post 不能使用呢？因为这两个钩子不在 vnode 的生命周期之中，在 vnode 创建之前，pre 已经执行完毕，在 vnode 卸载完毕之后，post 钩子才开始执行。 EventListenersnabbdom 提供 DOM 事件处理功能，创建 vnode 时，定义好 data.on 即可。比如： 12345678h( 'div', &#123; on: &#123; click: function() &#123; /*...*/&#125; &#125; &#125;) 如上，就定义了一个 click 事件处理函数。 那么如果我们要预先传入一些自定义的参数那该怎么做呢？此时我们应该通过数组定义 handler： 1234567891011h( 'div', &#123; on: &#123; click: [ function(data) &#123;/*...*/&#125;, data ] &#125; &#125;) 那我们的事件对象如何获取呢？这一点 snabbdom 已经考虑好了，event 对象和 vnode 对象会附加在我们的自定义参数后传入到 handler。 Thunk根据官方文档的说明，Thunk 是一种优化策略，可以防止创建重复的 vnode，然后对实际未发生变化的 vnode 做替换或者 patch，造成不必要的性能损耗。在后面的源码分析中，再做详细说明吧。 二、源码目录结构在首先查看源代码之前，先分析一下源码的目录结构，好有的放矢的进行阅读，下面是 src 目录下的文件结构： 1234567891011121314151617181920212223.├── helpers│ └── attachto.ts├── hooks.ts // 定义了钩子函数的类型├── htmldomapi.ts // 定义了一系列 DOM 操作的 API├── h.ts // 主要定义了 h 函数├── is.ts // 主要定义了一个类型判断辅助函数├── modules // 定义内置 module 的目录│ ├── attributes.ts│ ├── class.ts│ ├── dataset.ts│ ├── eventlisteners.ts│ ├── hero.ts│ ├── module.ts│ ├── props.ts│ └── style.ts├── snabbdom.bundle.ts // 导出 h 函数和 patch 函数（注册了所有内置模块）。├── snabbdom.ts // 导出 init，允许自定义注册模块├── thunk.ts // 定义了 thunk├── tovnode.ts // 定义了 tovnode 函数└── vnode.ts // 定义了 vnode 类型2 directories, 18 files 所以看完之后，我们应该有了一个大致的概念，要较好的了解 vnode，我们可以先从 vnode 下手，结合文档的介绍，可以详细了解虚拟 DOM 的结构。 此外还可以从我们使用 snabbdom 的入口处入手，即 snabbdom.ts。 三、虚拟 DOM 结构这一小节先了解 vnode 的结构是怎么样的，由于 snabbdom 使用 TypeScript 编写，所以关于变量的结构可以一目了然，打开 vnode.ts，可以看到关于 vnode 的定义： 12345678export interface VNode &#123; sel: string | undefined; data: VNodeData | undefined; children: Array&lt;VNode | string&gt; | undefined; elm: Node | undefined; text: string | undefined; key: Key | undefined;&#125; 可以看到 vnode 的结构其实比较简单，只有 6 个属性。关于这六个属性，官网已经做了介绍： sel：是一种 CSS 选择器，vnode 挂载为 DOM 时，会基于这个属性构造 HTML 元素。 data：构造 vnode 的数据属性，在构造 DOM 时会用到里面的数据，data 的结构在 vnode.ts 中可以找到定义，稍后作介绍。 children：这是一个 vnode 数组，在 vnode 挂载为 DOM 时，其 children 内的所有 vnode 会被构造为 HTML 元素，进一步挂载到上一级节点下。 elm：这是根据当前 vnode 构造的 DOM 元素。 text： 当前 vnode 的文本节点内容。 key：snabbdom 用 key 和 sel 来区分不同的 vnode，如果两个 vnode 的 sel 和 key 属性都相等，那么可以认为两个 vnode 完全相等，他们之间的更新需要进一步比对。 往下翻可以看到 VNodeData 的类型定义： 12345678910111213141516export interface VNodeData &#123; props?: Props; attrs?: Attrs; class?: Classes; style?: VNodeStyle; dataset?: Dataset; on?: On; hero?: Hero; attachData?: AttachData; hook?: Hooks; key?: Key; ns?: string; // for SVGs fn?: () =&gt; VNode; // for thunks args?: Array&lt;any&gt;; // for thunks [key: string]: any; // for any other 3rd party module&#125; 可以看出来这些属性基本上都是在 Module 中所使用的，用于对 DOM 的一些数据、属性进行定义，后面再进行介绍。 四、Hooks 结构打开 hooks.ts，可以看到源码如下： 12345678910111213141516171819202122232425import &#123;VNode&#125; from './vnode';export type PreHook = () =&gt; any;export type InitHook = (vNode: VNode) =&gt; any;export type CreateHook = (emptyVNode: VNode, vNode: VNode) =&gt; any;export type InsertHook = (vNode: VNode) =&gt; any;export type PrePatchHook = (oldVNode: VNode, vNode: VNode) =&gt; any;export type UpdateHook = (oldVNode: VNode, vNode: VNode) =&gt; any;export type PostPatchHook = (oldVNode: VNode, vNode: VNode) =&gt; any;export type DestroyHook = (vNode: VNode) =&gt; any;export type RemoveHook = (vNode: VNode, removeCallback: () =&gt; void) =&gt; any;export type PostHook = () =&gt; any;export interface Hooks &#123; pre?: PreHook; init?: InitHook; create?: CreateHook; insert?: InsertHook; prepatch?: PrePatchHook; update?: UpdateHook; postpatch?: PostPatchHook; destroy?: DestroyHook; remove?: RemoveHook; post?: PostHook;&#125; 这些代码定义了所有钩子函数的结构类型（接受的参数、返回的参数），然后定义了 Hooks 类型，这与我们前面介绍的钩子类型和所接受的参数是一致的。 五、Module 结构打开 module.ts，看到源码如下： 12345678910import &#123;PreHook, CreateHook, UpdateHook, DestroyHook, RemoveHook, PostHook&#125; from '../hooks';export interface Module &#123; pre: PreHook; create: CreateHook; update: UpdateHook; destroy: DestroyHook; remove: RemoveHook; post: PostHook;&#125; 可以看到，该模块先引用了上一节代码定义的一系列钩子的类型，然后用这些类型进一步定义了 Module。能够看出来 module 实际上就是几种钩子函数组成的一个对象，用于干涉 DOM 的构造。 六、h 函数h 函数是一个大名鼎鼎的函数，在各个框架中都有这个函数的身影。它的愿意是 hyperscript，意思是创造 HyperText 的 JavaScript，当然包括创造 HTML 的 JavaScript。在 snabbdom 中也不例外，h 函数旨在接受一系列参数，然后构造对应的 vnode，其返回的 vnode 最终会被渲染成 HTML 元素。 看看源代码： 1234567891011121314151617181920212223242526272829303132export function h(sel: string): VNode;export function h(sel: string, data: VNodeData): VNode;export function h(sel: string, children: VNodeChildren): VNode;export function h(sel: string, data: VNodeData, children: VNodeChildren): VNode;export function h(sel: any, b?: any, c?: any): VNode &#123; var data: VNodeData = &#123;&#125;, children: any, text: any, i: number; if (c !== undefined) &#123; data = b; if (is.array(c)) &#123; children = c; &#125; else if (is.primitive(c)) &#123; text = c; &#125; else if (c &amp;&amp; c.sel) &#123; children = [c]; &#125; &#125; else if (b !== undefined) &#123; if (is.array(b)) &#123; children = b; &#125; else if (is.primitive(b)) &#123; text = b; &#125; else if (b &amp;&amp; b.sel) &#123; children = [b]; &#125; else &#123; data = b; &#125; &#125; if (children !== undefined) &#123; for (i = 0; i &lt; children.length; ++i) &#123; if (is.primitive(children[i])) children[i] = vnode(undefined, undefined, undefined, children[i], undefined); &#125; &#125; if ( sel[0] === 's' &amp;&amp; sel[1] === 'v' &amp;&amp; sel[2] === 'g' &amp;&amp; (sel.length === 3 || sel[3] === '.' || sel[3] === '#') ) &#123; addNS(data, children, sel); &#125; return vnode(sel, data, children, text, undefined);&#125;;export default h; 可以看到前面很大一段都是函数重载，所以不用太关注，只用关注到最后一行： 1return vnode(sel, data, children, text, undefined); 在适配好参数之后，h函数调用了 vnode 函数，实现了 vnode 的创建，而 vnode 函数更简单，就是一个工厂函数： 123456789export function vnode(sel: string | undefined, data: any | undefined, children: Array&lt;VNode | string&gt; | undefined, text: string | undefined, elm: Element | Text | undefined): VNode &#123; let key = data === undefined ? undefined : data.key; return &#123;sel: sel, data: data, children: children, text: text, elm: elm, key: key&#125;;&#125; 它来自于 vnode.ts。 总之我们知道 h 函数接受相应的参数，返回一个 vnode 就行了。 七、snabbdom.ts 在讲 snabbdom.ts 之前，本来应该先了解 htmldomapi.ts 的，但是这个模块全都是对于 HTML 元素 API 的封装，没有讲解的必要，所以阅读本章之前，读者自行阅读 htmldomapi.ts 源码即可。 这是整个项目的核心所在，也是定义入口函数的重要文件，这个文件大概有接近 400 行，主要定义了一些工具函数以及一个入口函数。 打开 snabbdom.ts ，最早看到的就是一些简单的类型定义，我们也先来了解一下： 12345678910111213141516171819202122232425262728293031function isUndef(s: any): boolean &#123; return s === undefined; &#125; // 判断 s 是否为 undefined。// 判断 s 是否已定义（不为 undefined）。function isDef(s: any): boolean &#123; return s !== undefined; &#125;// 一个 VNodeQueue 队列，实际上是 vnode 数组，代表要挂载的 vnode。type VNodeQueue = Array&lt;VNode&gt;;// 一个空的 vnode，用于传递给 craete 钩子（查看第一节）。const emptyNode = vnode('', &#123;&#125;, [], undefined, undefined);// 判断两个 vnode 是否重复，依据是 key 和 sel。function sameVnode(vnode1: VNode, vnode2: VNode): boolean &#123; return vnode1.key === vnode2.key &amp;&amp; vnode1.sel === vnode2.sel;&#125;// 判断是否是 vnode。function isVnode(vnode: any): vnode is VNode &#123; return vnode.sel !== undefined;&#125;// 一个对象，用于映射 childen 数组中 vnode 的 key 和其 index 索引。type KeyToIndexMap = &#123;[key: string]: number&#125;;// T 是一个对象，其中的每一个键都被映射到 ArraysOf 类型，键值是 T 键值的数组集合。type ArraysOf&lt;T&gt; = &#123; [K in keyof T]: (T[K])[];&#125;// 参照上面的注释。type ModuleHooks = ArraysOf&lt;Module&gt;; 看完了基本类型的定义，可以继续看 init 函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657export function init(modules: Array&lt;Partial&lt;Module&gt;&gt;, domApi?: DOMAPI) &#123; let i: number, j: number, cbs = (&#123;&#125; as ModuleHooks); const api: DOMAPI = domApi !== undefined ? domApi : htmlDomApi; for (i = 0; i &lt; hooks.length; ++i) &#123; cbs[hooks[i]] = []; for (j = 0; j &lt; modules.length; ++j) &#123; const hook = modules[j][hooks[i]]; if (hook !== undefined) &#123; (cbs[hooks[i]] as Array&lt;any&gt;).push(hook); &#125; &#125; &#125; // 这中间定义了一大堆工具函数，稍后做选择性分析……此处省略。 // init 函数返回的 patch 函数，用于挂载或者更新 DOM。 return function patch(oldVnode: VNode | Element, vnode: VNode): VNode &#123; let i: number, elm: Node, parent: Node; const insertedVnodeQueue: VNodeQueue = []; // 先执行完钩子函数对象中的所有 pre 回调。 for (i = 0; i &lt; cbs.pre.length; ++i) cbs.pre[i](); if (!isVnode(oldVnode)) &#123; // 如果不是 VNode，那此时以旧的 DOM 为模板构造一个空的 VNode。 oldVnode = emptyNodeAt(oldVnode); &#125; if (sameVnode(oldVnode, vnode)) &#123; // 如果 oldVnode 和 vnode 是同一个 vnode（相同的 key 和相同的选择器），那么更新 oldVnode。 patchVnode(oldVnode, vnode, insertedVnodeQueue); &#125; else &#123; // 如果 vnode 不同于 oldVnode，那么直接替换掉 oldVnode 对应的 DOM。 elm = oldVnode.elm as Node; parent = api.parentNode(elm); // oldVnode 对应 DOM 的父节点。 createElm(vnode, insertedVnodeQueue); if (parent !== null) &#123; // 如果 oldVnode 的对应 DOM 有父节点，并且有同级节点，那就在其同级节点之后插入 vnode 的对应 DOM。 api.insertBefore(parent, vnode.elm as Node, api.nextSibling(elm)); // 在把 vnode 的对应 DOM 插入到 oldVnode 的父节点内后，移除 oldVnode 的对应 DOM，完成替换。 removeVnodes(parent, [oldVnode], 0, 0); &#125; &#125; for (i = 0; i &lt; insertedVnodeQueue.length; ++i) &#123; // 执行 insert 钩子。因为 module 不包括 insert 钩子，所以不必执行 cbs... (((insertedVnodeQueue[i].data as VNodeData).hook as Hooks).insert as any)(insertedVnodeQueue[i]); &#125; // 执行 post 钩子，代表 patch 操作完成。 for (i = 0; i &lt; cbs.post.length; ++i) cbs.post[i](); // 最终返回 vnode。 return vnode; &#125;;&#125; 可以看到 init 函数其实不仅可以接受一个 module 数组作为参数，还可以接受一个 domApi 作为参数，这在官方文档上是没有说明的。可以理解为 snabbdom 允许我们自定义 dom 的一些操作函数，在这个过程中对 DOM 的构造进行干预，只需要我们传递的 domApi 的结构符合预定义就可以了，此处不再细表。 然后可以看到的就是两个嵌套着的循环，大致意思是遍历 hooks 和 modules，构造一个 ModuleHooks 类型的 cbs 变量，那这是什么意思呢？ hooks 定义如下： 1const hooks: (keyof Module)[] = ['create', 'update', 'remove', 'destroy', 'pre', 'post']; 那就是把每个 module 中对应的钩子函数整理到 cbs 钩子名称对应的数组中去，比如： 1234567891011121314const module1 = &#123; create() &#123; /*...*/ &#125;, update() &#123; /*...*/ &#125;&#125;;const module2 = &#123; create() &#123; /*...*/ &#125;, update() &#123; /*...*/ &#125;&#125;;// 经过整理之后……// cbs 如下：&#123; create: [create1, create2], update: [update1, update2]&#125; 这种结构类似于发布——订阅模式的事件中心，以事件名作为键，键值是事件处理函数组成的数组，在事件发生时，数组中的函数会依次执行，与此处一致。 在处理好 hooks 之后，init 内部定义了一系列工具函数，此处暂不讲解，先往后看。 init 处理到最后返回的使我们预期的 patch 函数，该函数是我们使用 snabbdom 的重要入口，其具体定义如下： 123456789101112131415161718192021222324252627282930313233343536373839// init 函数返回的 patch 函数，用于挂载或者更新 DOM。return function patch(oldVnode: VNode | Element, vnode: VNode): VNode &#123; let i: number, elm: Node, parent: Node; const insertedVnodeQueue: VNodeQueue = []; // 先执行完钩子函数对象中的所有 pre 回调。 for (i = 0; i &lt; cbs.pre.length; ++i) cbs.pre[i](); if (!isVnode(oldVnode)) &#123; // 如果不是 VNode，那此时以旧的 DOM 为模板构造一个空的 VNode。 oldVnode = emptyNodeAt(oldVnode); &#125; if (sameVnode(oldVnode, vnode)) &#123; // 如果 oldVnode 和 vnode 是同一个 vnode（相同的 key 和相同的选择器），那么更新 oldVnode。 patchVnode(oldVnode, vnode, insertedVnodeQueue); &#125; else &#123; // 如果 vnode 不同于 oldVnode，那么直接替换掉 oldVnode 对应的 DOM。 elm = oldVnode.elm as Node; parent = api.parentNode(elm); // oldVnode 对应 DOM 的父节点。 createElm(vnode, insertedVnodeQueue); if (parent !== null) &#123; // 如果 oldVnode 的对应 DOM 有父节点，并且有同级节点，那就在其同级节点之后插入 vnode 的对应 DOM。 api.insertBefore(parent, vnode.elm as Node, api.nextSibling(elm)); // 在把 vnode 的对应 DOM 插入到 oldVnode 的父节点内后，移除 oldVnode 的对应 DOM，完成替换。 removeVnodes(parent, [oldVnode], 0, 0); &#125; &#125; for (i = 0; i &lt; insertedVnodeQueue.length; ++i) &#123; // 执行 insert 钩子。因为 module 不包括 insert 钩子，所以不必执行 cbs... (((insertedVnodeQueue[i].data as VNodeData).hook as Hooks).insert as any)(insertedVnodeQueue[i]); &#125; // 执行 post 钩子，代表 patch 操作完成。 for (i = 0; i &lt; cbs.post.length; ++i) cbs.post[i](); // 最终返回 vnode。 return vnode;&#125;; 可以看到在 patch 执行的一开始，就遍历了 cbs 中的所有 pre 钩子，也就是所有 module 中定义的 pre 函数。执行完了 pre 钩子，代表 patch 过程已经开始了。 接下来首先判断 oldVnode 是不是 vnode 类型，如果不是，就代表 oldVnode 是一个 HTML 元素，那我们就要把他转化为一个 vnode，方便后面的更新，更新完毕之后再进行挂载。转化为 vnode 的方式很简单，直接将其 DOM 结构挂载到 vnode 的 elm 属性，然后构造好 sel 即可。 随后，通过 sameVnode 判断是否是同一个 “vnode”。如果不是，那么就可以直接把两个 vnode 代表的 DOM 元素进行直接替换；如果是“同一个” vnode，那么就需要进行下一步对比，看看到底有哪些地方需要更新，可以看做是一个 DOM Diff 过程。所以这里出现了 snabbdom 的一个小诀窍，通过 sel 和 key 区分 vnode，不相同的 vnode 可以直接替换，不进行下一步的替换。这样做在很大程度上避免了一些没有必要的比较，节约了性能。 完成上面的步骤之后，就已经把 vnode 挂载到 DOM 上了，完成这个步骤之后，需要执行 vnode 的 insert 钩子，告诉所有的模块：一个 DOM 已经挂载了！ 最后，执行所有的 post 钩子并返回 vnode，通知所有模块整个 patch 过程已经结束啦！ 不难发现重点在于当 oldVnode 和 vnode 是同一个 vnode 时如何进行更新。这就自然而然的涉及到了 patchVnode 函数，该函数结构如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950function patchVnode(oldVnode: VNode, vnode: VNode, insertedVnodeQueue: VNodeQueue) &#123; let i: any, hook: any; if (isDef(i = vnode.data) &amp;&amp; isDef(hook = i.hook) &amp;&amp; isDef(i = hook.prepatch)) &#123; // 如果 vnode.data.hook.prepatch 不为空，则执行 prepatch 钩子。 i(oldVnode, vnode); &#125; const elm = vnode.elm = (oldVnode.elm as Node); let oldCh = oldVnode.children; let ch = vnode.children; // 如果两个 vnode 是真正意义上的相等，那完全就不用更新了。 if (oldVnode === vnode) return; if (vnode.data !== undefined) &#123; // 如果 vnode 的 data 不为空，那么执行 update。 for (i = 0; i &lt; cbs.update.length; ++i) cbs.update[i](oldVnode, vnode); i = vnode.data.hook; // 执行 vnode.data.hook.update 钩子。 if (isDef(i) &amp;&amp; isDef(i = i.update)) i(oldVnode, vnode); &#125; if (isUndef(vnode.text)) &#123; // 如果 vnode.text 未定义。 if (isDef(oldCh) &amp;&amp; isDef(ch)) &#123; // 如果都有 children，那就更新 children。 if (oldCh !== ch) updateChildren(elm, oldCh as Array&lt;VNode&gt;, ch as Array&lt;VNode&gt;, insertedVnodeQueue); &#125; else if (isDef(ch)) &#123; // 如果 oldVnode 是文本节点，而更新后 vnode 包含 children； // 那就先移除 oldVnode 的文本节点，然后添加 vnode。 if (isDef(oldVnode.text)) api.setTextContent(elm, ''); addVnodes(elm, null, ch as Array&lt;VNode&gt;, 0, (ch as Array&lt;VNode&gt;).length - 1, insertedVnodeQueue); &#125; else if (isDef(oldCh)) &#123; // 如果 oldVnode 有 children，而新的 vnode 只有文本节点； // 那就移除 vnode 即可。 removeVnodes(elm, oldCh as Array&lt;VNode&gt;, 0, (oldCh as Array&lt;VNode&gt;).length - 1); &#125; else if (isDef(oldVnode.text)) &#123; // 如果更新前后，vnode 都没有 children，那么就添加空的文本节点，因为大前提是 vnode.text === undefined。 api.setTextContent(elm, ''); &#125; &#125; else if (oldVnode.text !== vnode.text) &#123; // 定义了 vnode.text，并且 vnode 的 text 属性不同于 oldVnode 的 text 属性。 if (isDef(oldCh)) &#123; // 如果 oldVnode 具有 children 属性（具有 vnode），那么移除所有 vnode。 removeVnodes(elm, oldCh as Array&lt;VNode&gt;, 0, (oldCh as Array&lt;VNode&gt;).length - 1); &#125; // 设置文本内容。 api.setTextContent(elm, vnode.text as string); &#125; if (isDef(hook) &amp;&amp; isDef(i = hook.postpatch)) &#123; // 完成了更新，调用 postpatch 钩子函数。 i(oldVnode, vnode); &#125;&#125; 该函数是用于更新 vnode 的主要函数，所以 vnode 的主要生命周期都在这个函数内完成。首先执行的钩子就是 prepatch，表示元素即将被 patch。然后会判断 vnode 是否包含 data 属性，如果包含则说明需要先更新 data，这时候会调用所有的 update 钩子（包括模块内的和 vnode 自带的 update 钩子），在 update 钩子内完成 data 的合并更新。在 children 更新之后，还会调用 postpatch 钩子，表示 patch 过程已经执行完毕。 接下来从 text 入手，这一大块的注释都在代码里面写得很清楚了，这里不再赘述。重点在于 oldVnode 和 vnode 都有 children 属性的时候，如何更新 children？接下来看 updateChildren： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182function updateChildren(parentElm: Node, oldCh: Array&lt;VNode&gt;, newCh: Array&lt;VNode&gt;, insertedVnodeQueue: VNodeQueue) &#123; let oldStartIdx = 0, newStartIdx = 0; let oldEndIdx = oldCh.length - 1; let oldStartVnode = oldCh[0]; let oldEndVnode = oldCh[oldEndIdx]; let newEndIdx = newCh.length - 1; let newStartVnode = newCh[0]; let newEndVnode = newCh[newEndIdx]; let oldKeyToIdx: any; let idxInOld: number; let elmToMove: VNode; let before: any; // 从两端开始开始遍历 children。 while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123; if (oldStartVnode == null) &#123; oldStartVnode = oldCh[++oldStartIdx]; // Vnode might have been moved left &#125; else if (oldEndVnode == null) &#123; oldEndVnode = oldCh[--oldEndIdx]; &#125; else if (newStartVnode == null) &#123; newStartVnode = newCh[++newStartIdx]; &#125; else if (newEndVnode == null) &#123; newEndVnode = newCh[--newEndIdx]; &#125; else if (sameVnode(oldStartVnode, newStartVnode)) &#123; // 如果是同一个 vnode。 patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue); // 更新旧的 vnode。 oldStartVnode = oldCh[++oldStartIdx]; newStartVnode = newCh[++newStartIdx]; &#125; else if (sameVnode(oldEndVnode, newEndVnode)) &#123; // 同上，但是是从尾部开始的。 patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue); oldEndVnode = oldCh[--oldEndIdx]; newEndVnode = newCh[--newEndIdx]; &#125; else if (sameVnode(oldStartVnode, newEndVnode)) &#123; // Vnode moved right patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue); api.insertBefore(parentElm, oldStartVnode.elm as Node, api.nextSibling(oldEndVnode.elm as Node)); oldStartVnode = oldCh[++oldStartIdx]; newEndVnode = newCh[--newEndIdx]; &#125; else if (sameVnode(oldEndVnode, newStartVnode)) &#123; // Vnode moved left patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue); api.insertBefore(parentElm, oldEndVnode.elm as Node, oldStartVnode.elm as Node); oldEndVnode = oldCh[--oldEndIdx]; newStartVnode = newCh[++newStartIdx]; &#125; else &#123; if (oldKeyToIdx === undefined) &#123; // 创造一个 hash 结构，用键映射索引。 oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); &#125; idxInOld = oldKeyToIdx[newStartVnode.key as string]; // 通过 key 来获取对应索引。 if (isUndef(idxInOld)) &#123; // New element // 如果找不到索引，那就是新元素。 api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm as Node); newStartVnode = newCh[++newStartIdx]; &#125; else &#123; // 找到对应的 child vnode。 elmToMove = oldCh[idxInOld]; if (elmToMove.sel !== newStartVnode.sel) &#123; // 如果新旧 vnode 的选择器不能对应，那就直接插入到旧 vnode 之前。 api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm as Node); &#125; else &#123; // 选择器匹配上了，可以直接更新。 patchVnode(elmToMove, newStartVnode, insertedVnodeQueue); oldCh[idxInOld] = undefined as any; // 已更新的旧 vnode 赋值为 undefined。 api.insertBefore(parentElm, (elmToMove.elm as Node), oldStartVnode.elm as Node); &#125; newStartVnode = newCh[++newStartIdx]; &#125; &#125; &#125; if (oldStartIdx &lt;= oldEndIdx || newStartIdx &lt;= newEndIdx) &#123; // 没匹配上的多余的就直接插入到 DOM 咯。 if (oldStartIdx &gt; oldEndIdx) &#123; // newCh 里面有新的 vnode，直接插入到 DOM。 before = newCh[newEndIdx+1] == null ? null : newCh[newEndIdx+1].elm; addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx, insertedVnodeQueue); &#125; else &#123; // newCh 里面的 vnode 比 oldCh 里面的少，说明有元素被删除了。 removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx); &#125; &#125;&#125; updateVnode 函数在一开始就从 children 数组的首尾两端开始遍历。可以看到在遍历开始的时候会有一堆的 null 判断，为什么呢？因为后面会把已经更新的 vnode children 赋值为 undefined。 判断完 null 之后，会比较新旧 children 内的节点是否“相同”（排列组合共有四种比较方式），如果相同，那就继续调用 patchNode 更新节点，更新完之后就可以插入 DOM 了；如果四中情况都匹配不到，那么就通过之前建立的 key 与索引之间的映射来寻找新旧 children 数组中对应 child vnode 的索引，找到之后再进行具体操作。关于具体的操作，代码中已经注释了～ 对于遍历之后多余的 vnode，再分情况进行比较；如果 oldCh 多于 newCh，那说明该操作删除了部分 DOM。如果 oldCh 少于 newCh，那说明有新增的 DOM。 关于 updateChildren 函数的讲述，这篇文章的讲述更为详细：vue的Virtual Dom实现- snabbdom解密 ，大家可以去读一下～ 讲完最重要的这个函数，整个核心部分基本上是弄完了，不难发现 snabbdom 的秘诀就在于使用： 使用虚拟 DOM 模拟真实 DOM，JavaScript 内存操作性能大大优于 DOM 操作，所以性能比较好。 Diff 算法比较好，只比较同级 vnode，不会循环遍历去比较，而且采用 key 和 sel 标记 vnode，大大优化比较速度。这一做法类似于 Immutable，使用 hash 比较代替对象的循环递归比较，大大降低时间复杂度。 最后还有一个小问题，这个贯穿许多函数的 insertedVnodeQueue 数组是干嘛的？它只在 createElm 函数中进行 push 操作，然后在最后的 insert 钩子中进行遍历。仔细一想就可以发现，这个插入 vnode 队列存起来的是一个 children 的左右子 children，看下面一段代码： 123456789h( 'div', &#123;&#125;, [ h(/*...*/), h(/*...*/), h(/*...*/) ]) 可以看到 div 下面包含了三个 children，那么当这个 div 元素被插入到 DOM 时，它的三个子 children 也会触发 insert 事件，所以在插入 vnode 时，会遍历其所有 children，然后每个 vnode 都会放入到队列中，在插入之后再统一执行 insert 钩子。 以上，就写这么多吧～多的也没时间写了。 八、参考文章 vue的Virtual Dom实现- snabbdom解密","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://zhongdeming.fun/categories/JavaScript/"}],"tags":[]},{"title":"浅谈 JSONP","slug":"浅谈-JSONP","date":"2019-04-13T09:54:06.000Z","updated":"2021-05-07T21:21:43.640Z","comments":true,"path":"2019/04/13/浅谈-JSONP/","link":"","permalink":"http://zhongdeming.fun/2019/04/13/浅谈-JSONP/","excerpt":"说起跨域的解决方案，总是会说到 JSONP，但是很多时候都没有仔细去了解过 JSONP，可能是因为现在 JSONP 用的不是很多（多数时候都是配置响应头实现跨域），也可能是因为用 JSONP 的场景一般都是用 jQuery 来实现，所以对 JSONP 知之甚少。 JSONP 的本意是 JSON with Padding，即填充式 JSON。为什么叫填充式呢？因为服务端不会直接返回 JSON 格式数据给客户端，它会拼接成一个字符串，这个字符串被拿到客户端执行。这是对于 JSON 的一种应用。 JSONP 的原理是什么？发明 JSONP 的老头子们发现虽然同源策略（CORS）限制了 ajax 对于其它服务器的访问，但是并不能限制 HTML 的资源请求。","text":"说起跨域的解决方案，总是会说到 JSONP，但是很多时候都没有仔细去了解过 JSONP，可能是因为现在 JSONP 用的不是很多（多数时候都是配置响应头实现跨域），也可能是因为用 JSONP 的场景一般都是用 jQuery 来实现，所以对 JSONP 知之甚少。 JSONP 的本意是 JSON with Padding，即填充式 JSON。为什么叫填充式呢？因为服务端不会直接返回 JSON 格式数据给客户端，它会拼接成一个字符串，这个字符串被拿到客户端执行。这是对于 JSON 的一种应用。 JSONP 的原理是什么？发明 JSONP 的老头子们发现虽然同源策略（CORS）限制了 ajax 对于其它服务器的访问，但是并不能限制 HTML 的资源请求。 比如在 HTML 中，img、script、link 等标签完全可以访问任何地址的资源。而其中的 script 标签为跨域请求提供了一种新的思路，因为 script 请求的是一段可执行的 JavaScript 代码。我们可以把之前直接从服务器返回的数据封装到 JavaScript 代码中，然后在前端再使用这些数据。这就是 JSONP 的实现原理。 为什么 JSONP 只能使用 GET 方法？使用 jQuery 的 $.ajax 进行 JSONP 请求时，type 属性总是选择为 GET，如果填为 POST，就会报错，这是为什么呢？其实理解 JSONP 的原理之后，这就很好理解了。原因就是 script 标签的资源请求只能是 GET 类型，目前为止我还没有见过 POST 类型的资源请求～ 如何实现 JSONP？前端小白不理解 JSONP 的另一个原因就在于 JSONP 不只是前端这一块的任务，只靠前端是无法实现的，后端也必须做相应处理。 前端请求一个专用的接口获取数据，请求的数据会以 JavaScript 代码的形式返回，假如数据如下： 1234&#123; \"name\": \"russ\", \"age\": 20&#125; 那要构造成什么样的 JavaScript 代码才能被前端使用到呢？最容易想到的就是把数据赋值给一个全局变量，或者把数据扔到函数里面。扔给全局变量的话会导致一些问题（全局暴露、命名冲突、数据处理逻辑分散……），所以把数据扔给一个专门处理数据的函数比较合适。这也是 JSONP 所采用的方案。所以拼接出来的字符串（也是后端返回的 js 代码）基本如下： 1234callback(&#123; \"name\": \"russ\", \"age\": 20&#125;) 那么前端就需要在 script 请求返回之前定义好 callback 这个函数，以便在 script 返回之后可以顺利加载执行。这里需要前后端约定好回调函数的名称。当然可以前端传递回调的名称给后端，后端根据前端传递的名称进行 JavaScript 代码拼接，jQuery.ajax 就有这种实现,允许前端自定义回调的名称。 先讲讲后端实现，因为后端实现起来比较简单～ 后端处理 以下实现均使用 Nodejs。 Nodejs 实现代码如下： 12345678910111213141516171819202122232425262728const http = require('http');const &#123; parse &#125; = require('url');// 假设这是在数据库中找到的数据~const data = &#123; name: 'russ', age: 20, gender: 'male'&#125;;const server = http.createServer((req, res) =&gt; &#123; const url = parse(req.url, true); // 解析 url // 只有路由为 `/user` 的 GET 请求会被响应 if (req.method === 'GET' &amp;&amp; url.pathname === '/user') &#123; const &#123; callback &#125; = url.query; // 获取 callback 回调名称 if (callback) // 如果传递了 callback 参数，说明是 JSONP 请求 return res.end(`$&#123;callback&#125;($&#123;JSON.stringify(data)&#125;)`); else // 没传递 callback，直接当做不跨域的 GET 请求返回数据 return res.end(JSON.stringify(data)); &#125; return res.end('Not Found'); // 不匹配的路由返回错误&#125;);server.listen(3000, () =&gt; &#123; console.log('Server listening at port 3000...');&#125;); 可以直接在浏览器中请求查看结果～ 前端处理伴随着很多功能强大的 api 的出现，我们在很多场景下都可以直接弃用 jQuery（参考nefe/You-Dont-Need-jQuery ）。而如果我们的页面没有使用 jQuery 的时候，我们就需要手动实现 JSONP 了～ 前面说过 JSONP 的原理是 script 标签的资源请求，所以前端的处理就是构造 script 标签发起请求。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;JSONP&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 点击的时候调用 fetchJSON --&gt; &lt;button onclick=\"fetchJSON()\"&gt;Fetch&lt;/button&gt;&lt;/body&gt;&lt;script&gt; // 定义了 fetchJSON 函数。 function fetchJSON() &#123; // 内部调用 jsonp 函数实现接口的 jsonp 访问。 jsonp('http://localhost:3000/user?').then(data =&gt; &#123; console.log(data); &#125;).catch(err =&gt; &#123; console.log(err); &#125;) &#125; function jsonp(url) &#123; let $script = document.createElement('script'), // 先构造一个 script 元素 callbackName = `callback_$&#123;Date.now()&#125;`; // 先定义回调名称，加时间戳防止缓存 // 返回 promise 对象，方便后续处理 return new Promise((resolve, reject) =&gt; &#123; // 在发起请求之前，先定义好回调函数 window[callbackName] = (res) =&gt; &#123; // 请求结束之后清除全局变量 window[callbackName] = undefined; // 移除之前挂载的 script 元素 document.head.removeChild($script); // 清空 $script $script = undefined; resolve(res); &#125;; // 绑定 src，及请求地址 $script.src = `$&#123;url&#125;callback=$&#123;callbackName&#125;`; // 绑定 error 处理函数 $script.onerror = err =&gt; &#123; reject(err); &#125;; // 挂在 script 元素到 head，此时才开始发起请求～ document.head.appendChild($script); // 开始请求 &#125;); &#125;&lt;/script&gt;&lt;/html&gt; 当然上面的代码没有做兼容性处理，在低级浏览器使用时需要做一下处理，但是其他原理是一样的。 JSONP 有什么缺点呢？大致有两点： 一、安全性问题 JSONP 会从其它域加载 JavaScript 脚本并直接执行，如果 JavaScript 脚本中包含恶意攻击代码，那我们的网站将会受到威胁。所以当我们访问非自己维护的服务器的 JSONP 接口时，需要留心。 二、错误处理 script 标签的 onerror 函数在 HTML5 才定义，并且即使我们定义了 onerror 处理函数，我们也不容易捕捉到错误发生的原因。所以这也是一大缺点，至于具体表现可以单独运行上面的前端代码试试，看看错误发生时（后端服务未启动），前端控制台打印出来的错误对象是什么样的。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://zhongdeming.fun/categories/JavaScript/"}],"tags":[]},{"title":"预检请求与 Hapijs 的对应配置","slug":"预检请求与-Hapijs-的对应配置","date":"2019-01-15T14:49:19.000Z","updated":"2021-05-07T21:21:43.640Z","comments":true,"path":"2019/01/15/预检请求与-Hapijs-的对应配置/","link":"","permalink":"http://zhongdeming.fun/2019/01/15/预检请求与-Hapijs-的对应配置/","excerpt":"不久前在公司写了一个基于 Hapijs 的后端项目，感觉这个框架很有自己的特点，跟 Express 和 Koa 的区别比较大，体现了配置大于编码的思想。用起来很方便，据说 Walmart 团队用这个框架扛住了黑五的流量，看起来在实际项目中也有可用性，推荐大家尝试一下～ 有点跑题了，这篇文章主要写我在开发过程中所遇到的一个问题，以及我从这个问题所学习到的东西，然后我是怎么解决这个问题的。","text":"不久前在公司写了一个基于 Hapijs 的后端项目，感觉这个框架很有自己的特点，跟 Express 和 Koa 的区别比较大，体现了配置大于编码的思想。用起来很方便，据说 Walmart 团队用这个框架扛住了黑五的流量，看起来在实际项目中也有可用性，推荐大家尝试一下～ 有点跑题了，这篇文章主要写我在开发过程中所遇到的一个问题，以及我从这个问题所学习到的东西，然后我是怎么解决这个问题的。 一、问题我的项目需求是写一个 App 版本管理器，前后端都由我开发。前端分为两个部分：运营人员写版本更新说明的内部系统和 App 访问的产品页；后端就是对 App 版本进行管理的 CURD 接口。重点在于三个部分的程序部署在三台服务器上，前端的两个系统在不同的服务器对第三个服务器上的接口进行数据请求，这就不可避免的涉及到了跨域。 当然，只是跨域的话也不难解决，添加 Access-Control-Allow-Origin 为要跨域的域名就 OK 了，或者直接赋值为 *。但是我的部分接口涉及鉴权，通过 JWT 进行校验，如果 JWT 不合法，那么会返回 401 Unauthorized 错误；而我的 JWT 是通过请求头的自定义字段 authorization 带到服务器的，这就导致一个更加麻烦的问题出现了 —— 预检请求。 二、收获什么是预检请求？预检请求（preflight request），是一个跨域请求，用来校验当前跨域请求能否被理解。 它使用 HTTP 的 OPTIONS 请求，一般会包括一下请求头：Access-Control-Request-Method，Access-Control-Request-Headers 和 Origin。 预检请求通常在必要的时候由浏览器自动发起，不需要程序员进行干预。 如果我们想要知道服务器是否支持一个 DELETE 请求，在发送 DELETE 请求之前，服务器通常会发送一个如下的预检请求： 1234OPTIONS /resource/foo Access-Control-Request-Method: DELETE Access-Control-Request-Headers: origin, x-requested-withOrigin: https://foo.bar.org 如果服务器允许使用 DELETE 方法的话，会返回如下响应头；其中 Access-Control-Allow-Methods 会列出 DELETE 方法，代表服务器支持这个方法。 123456HTTP/1.1 200 OKContent-Length: 0Connection: keep-aliveAccess-Control-Allow-Origin: https://foo.bar.orgAccess-Control-Allow-Methods: POST, GET, OPTIONS, DELETEAccess-Control-Max-Age: 86400 以上资料来源于 MDN 由此可知，预检请求是一个用于校验服务器是否支持当前方法以及是否能够理解当前请求的一种请求，它区别于一般的请求，不由代码发起，而在必要的时候由浏览器自动发出。 所以这里就出问题了，如果我们不知道什么时候浏览器会发出预检请求，那么服务器没有做处理的话就会导致 CORS 报错的出现。 接下来再深入一点。 预检请求与普通请求的区别满足以下条件的请求就是简单请求： 一、请求方法属于下面三种方法之一： HEAD POST GET 二、HTTP 的请求头信息超出一下范围： Accept Accept-Language Content-Language Last-Event-ID Content-Type：超出这三个的范围： application/x-www-form-urlencoded multipart/form-data text/plain 不满足以上条件的请求就是非简单请求。 如果是简单的 CORS 请求，浏览器会自动在请求头中添加一个 Origin 请求头字段，如果响应头对应的 Access-Control-Allow-Origin 没有包含 Origin 所指定的域，那么就会报 CORS 错误，请求失败。所以服务器的响应要添加对应的响应头。 如果是非简单的 CORS 请求，那么会有一次预检请求，在正是请求之前发出一个 OPTIONS 请求对服务器进行检测。 除了有 Origin 以外，预检请求的请求头还包括一下两个特殊字段： Access-Control-Request-Method：表示 CORS 请求要用到的请求方法。 Access-Control-Request-Headers：这是一个用逗号分割的字符串，指出 CORS 请求要附加的请求头。 服务器的响应可以包含以下字段： Access-Control-Allow-Methods：逗号分割的字符串，表示允许的跨域请求方法。 比如： 1Access-Control-Allow-Methods: PUT, POST, GET, OPTIONS Access-Control-Allow-Headers：如果浏览器请求包含 Access-Control-Request-Headers 字段，那么服务器中该响应头也是必须的，也是一个由逗号分隔的字符串，表示服务器支持的请求头。 比如： 1Access-Control-Allow-Headers: authorization Access-Control-Max-Age：可选字段，设置当前预检请求的有效期，单位为秒。 Access-Control-Allow-Credentials：可选字段。默认情况下，CORS 请求不携带 cookie，如果服务器想要 cookie，需要指定该请求头为 true。 三、解决方法 避免出现预检请求，需要使得你的请求满足简单请求的两个条件。 比如在使用 JWT 鉴权时，可能会把你的 token 放在请求头的 authorization 字段，因为这个字段超出了简单请求的范围，所以请求会变成非简单请求。这时可以不把 token 放在 authorization 请求头中。 出现预检请求后，进行服务器配置，分别设置好 Access-Control-Allow-Origin、Access-Control-Allow-Methods 和 Access-Control-Allow-Headers，使得你的非简单请求能够通过预检请求。 如果使用 Hapijs 的话，只需要在路由配置中增加 cors: true 配置即可。 参考 MDN 跨域资源共享 CORS 详解 cors跨域之简单请求与预检请求（发送请求头带令牌token）","categories":[{"name":"HTTP","slug":"HTTP","permalink":"http://zhongdeming.fun/categories/HTTP/"},{"name":"Hapijs","slug":"HTTP/Hapijs","permalink":"http://zhongdeming.fun/categories/HTTP/Hapijs/"}],"tags":[]},{"title":"React 异步组件","slug":"React-异步组件","date":"2019-01-12T05:13:09.000Z","updated":"2021-05-07T21:21:43.640Z","comments":true,"path":"2019/01/12/React-异步组件/","link":"","permalink":"http://zhongdeming.fun/2019/01/12/React-异步组件/","excerpt":"之前写过一篇 Vue 异步组件的文章，最近在做一个简单项目的时候又想用到 React 异步组件，所以简单地了解了一下使用方法，这里做下笔记。 传统的 React 异步组件基本都靠自己实现，自己写一个专门的 React 组件加载函数作为异步组件的实现工具，通过 import() 动态导入，实现异步加载，可以参考【翻译】基于 Create React App路由4.0的异步组件加载（Code Splitting）这篇文章。这样做的话还是要自己写一个单独的加载组件，有点麻烦。于是想找个更简单一点的方式，没想到真给找到了：Async React using React Router &amp; Suspense，这篇文章讲述了如何基于 React Router 4 和 React 的新特性快速实现异步组件按需加载。 2018 年 10 月 23 号，React 发布了 v16.6 版本，新版本中有个新特性叫 lazy，通过 lazy 和 Suspense 组件我们就可以实现异步组件，如果你使用的是 React v16.6 以上版本：","text":"之前写过一篇 Vue 异步组件的文章，最近在做一个简单项目的时候又想用到 React 异步组件，所以简单地了解了一下使用方法，这里做下笔记。 传统的 React 异步组件基本都靠自己实现，自己写一个专门的 React 组件加载函数作为异步组件的实现工具，通过 import() 动态导入，实现异步加载，可以参考【翻译】基于 Create React App路由4.0的异步组件加载（Code Splitting）这篇文章。这样做的话还是要自己写一个单独的加载组件，有点麻烦。于是想找个更简单一点的方式，没想到真给找到了：Async React using React Router &amp; Suspense，这篇文章讲述了如何基于 React Router 4 和 React 的新特性快速实现异步组件按需加载。 2018 年 10 月 23 号，React 发布了 v16.6 版本，新版本中有个新特性叫 lazy，通过 lazy 和 Suspense 组件我们就可以实现异步组件，如果你使用的是 React v16.6 以上版本： 最简单的实现方法： 123456789101112// codes from https://react.docschina.orgimport React, &#123; lazy, Suspense &#125; from 'react';const OtherComponent = lazy(() =&gt; import('./OtherComponent'));function MyComponent() &#123; return ( &lt;Suspense fallback=&#123;&lt;div&gt;Loading...&lt;/div&gt;&#125;&gt; &lt;OtherComponent /&gt; &lt;/Suspense&gt; );&#125; 从 React 中引入 lazy 方法和 Suspense 组件，然后用 lazy 方法处理我们的组件，lazy 会返回一个新的React 组件，我们可以直接在 Suspense 标签内使用，这样组件就会在匹配的时候才加载。 lazy 接受一个函数作为参数，函数内部使用 import() 方法异步加载组件，加载的结果返回。 Suspense 组件的 fallback 属性是必填属性，它接受一个组件，在内部的异步组件还未加载完成时显示，所以我们通常传递一个 Loading 组件给它，如果没有传递的话，就会报错。 所以在使用 React Router 4 的时候，我们可以这样写： 12345678910111213141516171819202122232425262728import React, &#123; lazy, Suspense &#125; from 'react';import &#123; HashRouter, Route, Switch &#125; from 'react-router-dom';const Index = lazy(() =&gt; import('components/Index'));const List = lazy(() =&gt; import('components/List'));class App extends React.Component &#123; render() &#123; return &lt;div&gt; &lt;HashRouter&gt; &lt;Suspense fallback=&#123;Loading&#125;&gt; &lt;Switch&gt; &lt;Route path=\"/index\" exact component=&#123;Index&#125;/&gt; &lt;Route path=\"/list\" exact component=&#123;List&#125;/&gt; &lt;/Switch&gt; &lt;/Suspense&gt; &lt;/HashRouter&gt; &lt;/div&gt; &#125;&#125;function Loading() &#123; return &lt;div&gt; Loading... &lt;/div&gt;&#125;export default App; 在某些 React 版本中，lazy 函数还有 bug，会导致 React Router 的 component 属性接受 lazy 函数返回结果时报错：React.lazy makes Route’s proptypes fail。 我也遇到了这种 bug，具体的依赖版本如下： 123\"react\": \"^16.7.0\",\"react-dom\": \"^16.7.0\",\"react-router-dom\": \"^4.3.1\" 首次安装依赖后就再也没有更新过，所以小版本应该也是上面的小版本，不存在更新。 解决方法可以把 lazy 的结果放在函数的返回结果中： 12345678910111213141516171819202122232425262728import React, &#123; lazy, Suspense &#125; from 'react';import &#123; HashRouter, Route, Switch &#125; from 'react-router-dom';const Index = lazy(() =&gt; import('components/Index'));const List = lazy(() =&gt; import('components/List'));class App extends React.Component &#123; render() &#123; return &lt;div&gt; &lt;HashRouter&gt; &lt;Suspense fallback=&#123;Loading&#125;&gt; &lt;Switch&gt; &lt;Route path=\"/index\" exact component=&#123;props =&gt; &lt;Index &#123;...props&#125;/&gt;&#125;/&gt; &lt;Route path=\"/list\" exact component=&#123;props =&gt; &lt;List &#123;...props&#125;/&gt;&#125;/&gt; &lt;/Switch&gt; &lt;/Suspense&gt; &lt;/HashRouter&gt; &lt;/div&gt; &#125;&#125;function Loading() &#123; return &lt;div&gt; Loading... &lt;/div&gt;&#125;export default App; 上面代码和之前唯一的不同就是把 lazy 返回的组件包裹在匿名函数中传递给 Route 组件的 component 属性。 这样我们的组件都会在路由匹配的时候才开始加载，Webpack 也会自动代码进行 code split，切割成很多小块，减小了首页的加载时间以及单独一个 js 文件的体积。在工作中已经实践过了，确实好用： 如果没有使用 React v16.6 以上版本，也可以自己实现，我们可以写一个专门用于异步加载的函数： 1234567891011121314151617function asyncComponent(importComponent) &#123; class AsyncComponent extends React.Component &#123; render() &#123; return this.state.component; &#125; state = &#123; component: null &#125; async componentDidMount() &#123; const &#123; default: Component &#125; = await importComponent(); this.setState(&#123; component: &lt;Component/&gt; &#125;); &#125; &#125; return AsyncComponent;&#125; 使用的方法与 React.lazy 相同，传入一个异步加载的函数即可，上面这个函数需要注意的地方就是 import() 进来的组件被包裹在 default 属性里，结构时要用 const { default: Component } = ... 这种形式。 效果如下： 总的来说： 新版 React 使用起来更加简便～ 异步组件按需加载这些操作都是基于打包工具的特性，比如 Webpack 的 import ～","categories":[{"name":"React","slug":"React","permalink":"http://zhongdeming.fun/categories/React/"},{"name":"React-Router","slug":"React/React-Router","permalink":"http://zhongdeming.fun/categories/React/React-Router/"}],"tags":[]},{"title":"React & TypeScript","slug":"React-TypeScript","date":"2019-01-06T05:56:40.000Z","updated":"2021-05-07T21:21:43.640Z","comments":true,"path":"2019/01/06/React-TypeScript/","link":"","permalink":"http://zhongdeming.fun/2019/01/06/React-TypeScript/","excerpt":"之前看了一下 TypeScript 的知识，但是一直没有上手，最近开始结合 React 和 TypeScript 一起尝试了一下，感受还是很好的，所以写一下笔记。 环境配置没有参考其他东西，就是看了下 Webpack 和 TypeScript 的官方文档，使用 Webpack 进行构建还是比较简单的。 环境构建创建一个项目目录，然后切换当前目录到项目目录下： 1$ mkdir tsc &amp;&amp; cd ./tsc 然后使用 npm 初始化项目： 1$ npm init -y 然后创建一些项目文件： 12$ mkdir build src$ touch build/webpack.base.conf.js build/webpack.dev.conf.js build/webpack.prod.conf.js index.html src/index.tsx tsconfig.json 接下来，就可以安装一些依赖了： 123$ npm i webpack webpack-cli webpack-merge webpack-dev-server -D$ npm i html-webpack-plugin clean-webpack-plugin typescript ts-loader style-loader css-loader @types/react @types/react-dom -D$ npm i react react-dom -S 可以注意到我们没有安装 babel 转译器，如果我们只写 .ts 或者 .tsx 文件，可以不安装 babel。如果要转译处理 .js 文件的话，还是要使用到 babel。","text":"之前看了一下 TypeScript 的知识，但是一直没有上手，最近开始结合 React 和 TypeScript 一起尝试了一下，感受还是很好的，所以写一下笔记。 环境配置没有参考其他东西，就是看了下 Webpack 和 TypeScript 的官方文档，使用 Webpack 进行构建还是比较简单的。 环境构建创建一个项目目录，然后切换当前目录到项目目录下： 1$ mkdir tsc &amp;&amp; cd ./tsc 然后使用 npm 初始化项目： 1$ npm init -y 然后创建一些项目文件： 12$ mkdir build src$ touch build/webpack.base.conf.js build/webpack.dev.conf.js build/webpack.prod.conf.js index.html src/index.tsx tsconfig.json 接下来，就可以安装一些依赖了： 123$ npm i webpack webpack-cli webpack-merge webpack-dev-server -D$ npm i html-webpack-plugin clean-webpack-plugin typescript ts-loader style-loader css-loader @types/react @types/react-dom -D$ npm i react react-dom -S 可以注意到我们没有安装 babel 转译器，如果我们只写 .ts 或者 .tsx 文件，可以不安装 babel。如果要转译处理 .js 文件的话，还是要使用到 babel。 我们先写基础配置： webpack.base.conf.js 123456789101112131415161718192021222324252627282930313233const path = require('path');const htmlWebpackPlugin = require('html-webpack-plugin');const cleanWebpackPlugin = require('clean-webpack-plugin');module.exports = &#123; entry: path.resolve(__dirname, '../src/index.tsx'), output: &#123; filename: '[name].[hash].js' &#125;, resolve: &#123; extensions: ['*', '.js', '.json', '.ts', '.tsx'] &#125;, module: &#123; rules: [ &#123; test: /\\.tsx?$/, use: 'ts-loader', exclude: /node_modules/ &#125;, &#123; test: /\\.css$/, use: ['style-loader', 'css-loader'] &#125; ] &#125;, plugins: [ new htmlWebpackPlugin(&#123; inject: true, template: path.resolve(__dirname, '../index.html') &#125;), new cleanWebpackPlugin(['dist']) ]&#125;; 然后可以构造开发环境下的配置文件： webpack.dev.conf.js 12345678910111213const merge = require('webpack-merge');const path = require('path');const baseConfig = require('./webpack.base.conf');module.exports = merge(baseConfig, &#123; mode: 'development', devtool: 'source-map', devServer: &#123; port: 9999, open: true, contentBase: path.resolve(__dirname, '../dist') &#125;&#125;); 然后添加 npm 脚本到 package.json 中： 1234\"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"dev\": \"webpack-dev-server --config ./build/webpack.dev.conf.js\"&#125; 然后添加我们的 ts 配置到 tsconfig.json： 123456789101112&#123; \"compilerOptions\": &#123; \"outDir\": \"./dist/\", // 打包输出目录 \"noImplicitAny\": true, // 默认必须为变量指定类型 \"module\": \"es6\", // 使用 ESM 模块化方案 \"target\": \"es5\", // 代码编译成 ES 5 \"jsx\": \"react\", // 开启 JSX，使用 react 方式编译，如果要使用 babel 编译，那就将 jsx 设置为 ‘preserve’ \"allowJs\": true, // 允许编译 js 代码 \"sourceMap\": true, // 编译后同时产出 map 文件 \"removeComments\": true // 移除注释 &#125;&#125; 更多的配置项解释，参考：翻译 | 开始使用 TypeScript 和 React。 写完了以后我们就可以添加内容到我们的开发文件中了： index.html 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"root\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; src/index.tsx 1234567import * as React from &apos;react&apos;;import * as ReactDOM from &apos;react-dom&apos;;ReactDOM.render( &lt;h1&gt;Hello TSX!&lt;/h1&gt;, document.getElementById(&apos;root&apos;) as HTMLElement); 可以注意到引入 React 和 ReactDOM 的方式和之前有一些不同。另外由于 TypeScript 的强制转换符 &lt;&gt; 和 JSX 的元素相冲突，所以使用 as 作为强制转换符。 运行 npm run dev，可以查看效果。 使用 TypeScript 以后，项目配置要稍微简单一点。配置好开发环境以后，就可以写代码啦！ 第一个组件我以一个 Header 组件为例，效果如下： 新建一个 Header.tsx 文件和一个 Header.css 文件到 src/components 下。 由于头部栏的标题文字应该是可以修改的，然后右边的 menu 应该是可以自定义的，所以这些数据应该都可以通过 props 传入我们的 Header 组件。 写我们的 Header 组件： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// Header.tsx// 引入 Reactimport * as React from &apos;react&apos;;// 引入我们的组件样式import &apos;./Header.css&apos;;// 定义的接口，用于规范 Header 组件的 props，向外界公开，// 便于在其他组件中引用时实现这个接口，减少错误export interface HeaderProps &#123; title: string; // 必须给定 title，一个 string 类型的值 menus?: MenuItemProps[]; // menus 是可选属性，是一个符合 MenuItemProps 接口规范的对象的数组 height?: string; // 问号都代表可选项 bgColor?: string;&#125;// 这个接口定义了 MenuItem 组件的 props 规范，同时也定义了// HeaderProps 中 menus 数组的元素的规范interface MenuItemProps &#123; name: string; // 给定 menu 的名称 href: string; // 给定 menu 要跳转的链接&#125;// 定义了 Header 组件的 state 的规范interface HeaderState &#123; isVisible: boolean // 代表 Header 组件是否可见&#125;// Header 组件// 注意 React.Component 后面的泛型，就是我们上方定义的接口，它们分别制定了组件的 props 和 state 的规范class Header extends React.Component&lt;HeaderProps, HeaderState&gt; &#123; // 指定组件实例的 state，必须符合 HeaderState 的规范 state = &#123; isVisible: true &#125; render() &#123; const &#123; title, menus = [], height = &apos;50px&apos;, bgColor = &apos;lightblue&apos; &#125; = this.props; // 从 props 获取值，其中可选项都有默认值 const style = &#123; height, backgroundColor: bgColor &#125;; // 构造 Header 内联样式 return this.state.isVisible ? &lt;div style=&#123;style&#125; className=&quot;header&quot;&gt; &lt;span&gt;&#123;title&#125;&lt;/span&gt; &lt;div className=&quot;header-menus&quot;&gt; &#123; menus.map(item =&gt; &lt;MenuItem &#123;...item&#125;/&gt;) &#125; &lt;/div&gt; &lt;/div&gt; : null; &#125;&#125;// MenuItem 组件// state 的规范是一个 object，未指定具体接口类型class MenuItem extends React.Component&lt;MenuItemProps, object&gt; &#123; render() &#123; const &#123; name, href &#125; = this.props; return &lt;a className=&quot;header-menu-item&quot; href=&#123;href&#125; key=&#123;href&#125;&gt; &#123;name&#125; &lt;/a&gt; &#125;&#125;// 最后向外部暴露 Header 组件export default Header; 可以看到 TypeScript 结合 React 其实很好用，尤其在规范 props 的时候很好用，能够避免很多编程时候的错误。而 IDE 的提示能够更加地方便我们开发。写起来何止舒服，简直舒服啊～ 然后在 Header.css 写一下我们的样式： 1234567891011121314151617181920212223242526html,body,div &#123; margin: 0; padding: 0; font-size: 16px;&#125;.header &#123; font-size: 1.5rem; line-height: 1rem; padding: 1rem; box-sizing: border-box; position: relative;&#125;.header-menus &#123; position: absolute; right: 1rem; top: 50%; transform: translateY(-50%);&#125;.header-menu-item &#123; margin: 0 .5rem;&#125; 这里仅仅是做个示例，排版没有在意太多的通用性，大家看看就好～ 然后我们就可以在 index.tsx 中使用我们的 Header 组件了： 1234567891011121314151617181920212223import * as React from &apos;react&apos;;import * as ReactDOM from &apos;react-dom&apos;;import Header, &#123; HeaderProps &#125; from &apos;./components/Header&apos;; // 引入接口规范和组件// 构造 Header 组件的 props，必须符合 HeaderProps 接口规范。// 在写的过程中 IDE 也能给我们很多的提示，方便了开发const headerProps: HeaderProps = &#123; title: &apos;Hello TSX!&apos;, menus: [&#123; name: &apos;menu1&apos;, href: &apos;https://www.zhongdeming.fun&apos; &#125;, &#123; name: &apos;menu2&apos;, href: &apos;https://www.baidu.com&apos; &#125;], bgColor: &apos;lightyellow&apos;&#125;;ReactDOM.render( &lt;Header &#123;...headerProps&#125;/&gt;, document.getElementById(&apos;root&apos;) as HTMLElement); 这样一个组件就写完了，可以感受到 TypeScript 确实能够加速我们的开发，减少开发中的错误。 下面是一些利用 TypeScript 开发的时候 IDE 给出的提示的截图：","categories":[{"name":"React","slug":"React","permalink":"http://zhongdeming.fun/categories/React/"},{"name":"TypeScript","slug":"React/TypeScript","permalink":"http://zhongdeming.fun/categories/React/TypeScript/"}],"tags":[]},{"title":"Array.prototype.reduce 的理解与实现","slug":"reduce-的理解与实现","date":"2018-12-16T06:29:15.000Z","updated":"2021-05-07T21:21:43.640Z","comments":true,"path":"2018/12/16/reduce-的理解与实现/","link":"","permalink":"http://zhongdeming.fun/2018/12/16/reduce-的理解与实现/","excerpt":"Array.prototype.reduce 是 JavaScript 中比较实用的一个函数，但是很多人都没有使用过它，因为 reduce 能做的事情其实 forEach 或者 map 函数也能做，而且比 reduce 好理解。但是 reduce 函数还是值得去了解的。 reduce 函数可以对一个数组进行遍历，然后返回一个累计值，它使用起来比较灵活，下面了解一下它的用法。 reduce 接受两个参数，第二个参数可选： 12@param &#123;Function&#125; callback 迭代数组时，求累计值的回调函数@param &#123;Any&#125; initVal 初始值，可选 其中，callback 函数可以接受四个参数： 1234@param &#123;Any&#125; acc 累计值@param &#123;Any&#125; val 当前遍历的值@param &#123;Number&#125; key 当前遍历值的索引@param &#123;Array&#125; arr 当前遍历的数组","text":"Array.prototype.reduce 是 JavaScript 中比较实用的一个函数，但是很多人都没有使用过它，因为 reduce 能做的事情其实 forEach 或者 map 函数也能做，而且比 reduce 好理解。但是 reduce 函数还是值得去了解的。 reduce 函数可以对一个数组进行遍历，然后返回一个累计值，它使用起来比较灵活，下面了解一下它的用法。 reduce 接受两个参数，第二个参数可选： 12@param &#123;Function&#125; callback 迭代数组时，求累计值的回调函数@param &#123;Any&#125; initVal 初始值，可选 其中，callback 函数可以接受四个参数： 1234@param &#123;Any&#125; acc 累计值@param &#123;Any&#125; val 当前遍历的值@param &#123;Number&#125; key 当前遍历值的索引@param &#123;Array&#125; arr 当前遍历的数组 callback 接受这四个参数，经过处理后返回新的累计值，而这个累计值会作为新的 acc 传递给下一个 callback 处理。直到处理完所有的数组项。得到一个最终的累计值。 reduce 接受的第二个参数是一个初始值，它是可选的。如果我们传递了初始值，那么它会作为 acc 传递给第一个 callback，此时 callback 的第二个参数 val 是数组的第一项；如果我们没有传递初始值给 reduce，那么数组的第一项会作为累计值传递给 callback，数组的第二项会作为当前项传递给 callback。 示例： 对数组求和： 123let arr = [1, 2, 3];let res = arr.reduce((acc, v) =&gt; acc + v);console.log(res); // 6 如果我们传递一个初始值： 123let arr = [1, 2, 3];let res = arr.reduce((acc, v) =&gt; acc + v, 94);console.log(res); // 100 利用 reduce 求和比 forEach 更加简单，代码也更加优雅，只需要清楚 callback 接受哪些参数，代表什么含义就可以了。 我们还可以利用 reduce 做一些其他的事情，比如对数组去重： 123456let arr = [1, 1, 1, 2, 3, 3, 4, 3, 2, 4];let res = arr.reduce((acc, v) =&gt; &#123; if (acc.indexOf(v) &lt; 0) acc.push(v); return acc;&#125;, []);console.log(res); // [1, 2, 3, 4] 统计数组中每一项出现的次数： 1234567let arr = ['Jerry', 'Tom', 'Jerry', 'Cat', 'Mouse', 'Mouse'];let res = arr.reduce((acc, v) =&gt; &#123; if (acc[v] === void 0) acc[v] = 1; else acc[v]++; return acc;&#125;, &#123;&#125;);console.log(res); // &#123;Jerry: 2, Tom: 1, Cat: 1, Mouse: 2&#125; 将二维数组展开成一维数组： 123456789let arr = [[1, 2, 3], 3, 4, [3, 5]];let res = arr.reduce((acc, v) =&gt; &#123; if (v instanceof Array) &#123; return [...acc, ...v]; &#125; else &#123; return [...acc, v]; &#125;&#125;);console.log(res); // [1, 2, 3, 3, 4, 3, 5] 由此可以看出，reduce 函数还是很实用的，但是 reduce 函数兼容性不是特别好，只支持到 IE 9，如果要在 IE 8 及以下使用的话就不行了，所以我们可以自己实现一下，还可以对其做一下扩展，使其能够遍历对象。 首先可以实现一个最基础的 each 函数，作为我们 reduce 的基础： 12345678910111213141516171819/** * 遍历对象或数组，对操作对象的属性或元素做处理 * @param &#123;Object|Array&#125; param 要遍历的对象或数组 * @param &#123;Function&#125; callback 回调函数 */function each(param, callback) &#123; // ...省略参数校验 if (param instanceof Array) &#123; for (var i = 0; i &lt; param.length; i++) &#123; callback(param[i], i, param); &#125; &#125; else if (Object.prototype.toString.call(param) === '[object Object]') &#123; for (var val in param) &#123; callback(param[val], val, param); &#125; &#125; else &#123; throw new TypeError('each 参数错误！'); &#125;&#125; 可以看出 each 可以遍历对象或数组，回调函数接受三个参数： 123@param &#123;Any&#125; v 当前遍历项@param &#123;String|Number&#125; k 当前遍历的索引或键@param &#123;Object|Array&#125; o 当前遍历的对象或者数组 有了这个基础函数，我们可以开始实现我们的 reduce 函数了： 1234567891011121314/** * 迭代数组、类数组对象或对象，返回一个累计值 * @param &#123;Object|Array&#125; param 要迭代的数组、类数组对象或对象 * @param &#123;Function&#125; callback 对每一项进行操作的回调函数，接收四个参数：acc 累加值、v 当前项、k 当前索引、o 当前迭代对象 * @param &#123;Any&#125; initVal 传入的初始值 */function reduce(param, callback, initVal) &#123; var hasInitVal = initVal !== void 0; var acc = hasInitVal ? initVal : param[0]; each(hasInitVal ? param : Array.prototype.slice.call(param, 1), (v, k, o) =&gt; &#123; acc = callback(acc, v, k, o); &#125;); return acc;&#125; 可以看到，我们的 reduce 函数就是在 each 上面封装了一层。根据是否传递了初始值 initVal 来决定遍历的起始项。每次遍历都接受 callback 返回的 acc 值，然后在 reduce 的最后返回 acc 累计值就可以啦！ 当然，这部分代码有一个很严重的 bug，导致了我们的 polyfill 毫无意义，那就是遍历对象时的 for...in。这个语法和在 IE &lt;= 9 环境下存在 bug，会无法获得对象的属性值，这就导致我们所实现的 reduce 无法在 IE 9 以下遍历对象，但是遍历数组还是可以的。对于 for...in 的这个 bug，可以参考 underscore 是怎么实现的，这里暂时不研究了～","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://zhongdeming.fun/categories/JavaScript/"}],"tags":[]},{"title":"ES 6 装饰器与 React 高阶组件","slug":"ES-6-装饰器与-React 高阶组件","date":"2018-12-07T14:04:25.000Z","updated":"2021-05-07T21:21:43.640Z","comments":true,"path":"2018/12/07/ES-6-装饰器与-React 高阶组件/","link":"","permalink":"http://zhongdeming.fun/2018/12/07/ES-6-装饰器与-React 高阶组件/","excerpt":"关于 Decorator 到底是 ES 6 引入的还是 ES 7 引入的我也不是很明白了，两种说法都有，这种问题懒得纠结了……在用的时候发现这个东西很好用，平常用处可能不大，但是结合 React 就很好使了。接下来就讲一讲。 一、环境搭建我搭建了一个 React 开发环境，结合 babel 的插件——babel-plugin-transform-decorators-legacy一起使用，这个插件可以让你写 Decorator。 GitHub 地址：https://github.com/zhongdeming428/HOC 可以通过如下命令克隆： 1$ git clone https://github.com/zhongdeming428/HOC.git","text":"关于 Decorator 到底是 ES 6 引入的还是 ES 7 引入的我也不是很明白了，两种说法都有，这种问题懒得纠结了……在用的时候发现这个东西很好用，平常用处可能不大，但是结合 React 就很好使了。接下来就讲一讲。 一、环境搭建我搭建了一个 React 开发环境，结合 babel 的插件——babel-plugin-transform-decorators-legacy一起使用，这个插件可以让你写 Decorator。 GitHub 地址：https://github.com/zhongdeming428/HOC 可以通过如下命令克隆： 1$ git clone https://github.com/zhongdeming428/HOC.git 克隆下来以后就可以尝试啦！ 二、Decorator 的基本使用装饰器本身就是一个函数，使用起来挺简单，无非就是修饰类或者类的函数。使用 @ 调用，扔在要修饰的类或者类方法前面就可以了。但是在修饰类和类函数的时候又有细微的差异。 123456789class A &#123; @sayB sayA() &#123; console.log('a'); &#125;&#125;function sayB(target, name, descriptor) &#123; // ...&#125; 在使用装饰器装饰类函数的时候，可以接受三个参数。第一个是要修饰的对象，第二个是修饰的属性名，第三个是属性描述符。可以在我搭建的项目中进行尝试。 在用装饰器装饰类的时候，只能够接受一个参数——target。这区别于上面的情况： 1234567@APlusclass A &#123;&#125;function APlus(target, name, descriptor) &#123; // ... 打印一下可以发现 name、descriptor 是 undefined。&#125; 另外，装饰器还可以接受参数，返回一个符合装饰器规范的新函数即可，这样又可以对装饰器的装饰行为进行定制了。比如： 123456789101112131415161718@attach2Prop(&#123; name: 'A' &#125;)class A &#123;&#125;@attach2Prop(&#123; name: 'B' &#125;)class B &#123;&#125;function attach2Prop(obj) &#123; return function(target) &#123; target.prototype.$data = obj; &#125;&#125;console.log((new A()).$data.name);console.log((new B()).$data.name); 结果会输出 A 和 B。 这就就可以用同一个装饰器实现不同行为的装饰了。 那么结合 React 有什么妙用呢？ 三、结合 React 使用（1）简化 React-Redux 的使用以往在使用 react-redux 时，在定义好 UI 组件后，还要定义容器组件： 1234567class UIComponent extends React.Component &#123;&#125;const ContainerComponent = connect(mapState2Props, mapDispatch2Props)(UIComponent);export default ContainerComponent; 有了装饰器之后： 123456@connect(mapState2Props, mapDispatch2Props)class UIComponent extends React.Component &#123;&#125;export default UIComponent; 这样用简化的代码达到了同样的效果，还省去了给容器组件命名的麻烦……代码也更加的整洁。 （2）定制高阶组件上一小节中的容器组件实际上就是一个高阶组件，但是我们自己有时候也要定义一些高阶组件，实现代码的更高层次的复用。 例如：我们做了一个组件库，里面有一部分的组件是有一个功能特征的，那就是可以拖拽；又比如我们做的移动端组件，需要实现一个左滑删除功能。我们需要给每种具有这个特征的组件写一遍拖拽或者左滑删除逻辑吗？ 显然是否定的，我们可以实现一个纯逻辑组件，而非 UI 组件，它的功能就是使得你的 UI 组件具有某种特定功能。比如上面提到的左滑删除或者拖拽。 这个纯逻辑组件就可以是一个装饰器，是一个高阶组件。 在我搭建的开发环境中，就实现了这样一个简单的高阶组件，让你的 UI 组件在鼠标滑入时显示为一只手。 装饰器代码如下： 12345678910// src/decorators/CursorPointer.jsimport React from 'react';export default Component =&gt; class extends React.Component &#123; render() &#123; return &lt;div style=&#123;&#123;cursor: 'pointer', display: 'inline-block'&#125;&#125;&gt; &lt;Component/&gt; &lt;/div&gt; &#125;&#125; 这个装饰器（高阶组件）接受一个 React 组件作为参数，然后返回一个新的 React 组件。实现很简单，就是包裹了一层 div，添加了一个 style，就这么简单。以后所有被它装饰的组件都会具有这个特征。 使用这个装饰器： 12345678910111213import React from 'react';import Clickable from '../decorators/CursorPointer';@Clickableclass ClickablePanel extends React.Component &#123; render() &#123; return &lt;div className=\"panel\"&gt; &lt;/div&gt; &#125;&#125;export default ClickablePanel; 将装饰器与高阶组件相结合，可以大大优化你的 React 代码！","categories":[{"name":"React","slug":"React","permalink":"http://zhongdeming.fun/categories/React/"}],"tags":[]},{"title":"Redux 源码解读","slug":"源码解读","date":"2018-12-05T12:37:32.000Z","updated":"2021-05-07T21:21:43.640Z","comments":true,"path":"2018/12/05/源码解读/","link":"","permalink":"http://zhongdeming.fun/2018/12/05/源码解读/","excerpt":"已经快一年没有碰过 React 全家桶了，最近换了个项目组要用到 React 技术栈，所以最近又复习了一下；捡起旧知识的同时又有了一些新的收获，在这里作文以记之。 在阅读文章之前，最好已经知道如何使用 Redux(不是 React-Redux)。 一、准备环境为了更好的解读源码，我们可以把源码拷贝到本地，然后搭建一个开发环境。Redux 的使用不依赖于 React，所以你完全可以在一个极为简单的 JavaScript 项目中使用它。这里不再赘述开发环境的搭建过程，需要的同学可以直接拷贝我的代码到本地，然后安装依赖，运行项目。 12345$ git clone https://github.com/zhongdeming428/redux &amp;&amp; cd redux$ npm i$ npm run dev","text":"已经快一年没有碰过 React 全家桶了，最近换了个项目组要用到 React 技术栈，所以最近又复习了一下；捡起旧知识的同时又有了一些新的收获，在这里作文以记之。 在阅读文章之前，最好已经知道如何使用 Redux(不是 React-Redux)。 一、准备环境为了更好的解读源码，我们可以把源码拷贝到本地，然后搭建一个开发环境。Redux 的使用不依赖于 React，所以你完全可以在一个极为简单的 JavaScript 项目中使用它。这里不再赘述开发环境的搭建过程，需要的同学可以直接拷贝我的代码到本地，然后安装依赖，运行项目。 12345$ git clone https://github.com/zhongdeming428/redux &amp;&amp; cd redux$ npm i$ npm run dev 二、阅读源码（１）源代码结构忽略项目中的那些说明文档什么的，只看 src 这个源文件目录，其结构如下： 12345678910111213src├── applyMiddleware.js // 应用中间件的 API├── bindActionCreators.js // 转换 actionCreators 的 API├── combineReducers.js // 组合转换 reducer 的 API├── compose.js // 工具函数，用于嵌套调用中间件├── createStore.js // 入口函数，创建 store 的 API├── index.js // redux 项目的入口文件，用于统一暴露所有 API├── test│ └── index.js // 我所创建的用于调试的脚本└── utils // 专门放工具函数的目录 ├── actionTypes.js // 定义了一些 redux 预留的 action type ├── isPlainObject.js // 用于判断是否是纯对象 └── warning.js // 用于抛出合适的警告信息 可以看出来 redux 的源码结构简单清晰明了，几个主要的（也是仅有的） API 被尽可能的分散到了单个的文件模块中，我们只需要挨个的看就行了。 （2）index.js上一小节说到 index.js 是 redux 项目的入口文件，用于暴露所有的 API，所以我们来看看代码： 12345678910111213141516171819202122232425262728293031323334353637import createStore from './createStore'import combineReducers from './combineReducers'import bindActionCreators from './bindActionCreators'import applyMiddleware from './applyMiddleware'import compose from './compose'import warning from './utils/warning'import __DO_NOT_USE__ActionTypes from './utils/actionTypes'// 不同的 API 写在不同的 js 文件中，最后通过 index.js 统一导出。// 这个函数用于判断当前代码是否已经被打包工具（比如 Webpack）压缩过，如果被压缩过的话，// isCrushed 函数的名称会被替换掉。如果被替换了函数名但是 process.env.NODE_ENV 又不等于 production// 的时候，提醒用户使用生产环境下的精简代码。function isCrushed() &#123;&#125;if ( process.env.NODE_ENV !== 'production' &amp;&amp; typeof isCrushed.name === 'string' &amp;&amp; isCrushed.name !== 'isCrushed') &#123; warning( 'You are currently using minified code outside of NODE_ENV === \"production\". ' + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or setting mode to production in webpack (https://webpack.js.org/concepts/mode/) ' + 'to ensure you have the correct code for your production build.' )&#125;// 导出主要的 API。export &#123; createStore, combineReducers, bindActionCreators, applyMiddleware, compose, __DO_NOT_USE__ActionTypes&#125; 我删除了所有的英文注释以减小篇幅，如果大家想看原来的注释，可以去 redux 的项目查看源码。 可以看到在程序的头部引入了所有的 API 模块以及工具函数，然后在底部统一导出了。这一部分比较简单，主要是 isCrushed 函数有点意思。作者用这个函数来判断代码是否被压缩过（判断函数名是否被替换掉了）。 这一部分也引用到了工具函数，由于这几个函数比较简单，所以可以先看看它们是干嘛的。 （3）工具函数除了 compose 函数以外，所有的工具函数都被放在了 utils 目录下。 actionTypes.js 这个工具模块定义了几种 redux 预留的 action type，包括 reducer 替换类型、reducer 初始化类型和随机类型。下面上源码： 12345678910111213141516// 定义了一些 redux 保留的 action type。// 随机字符串确保唯一性。const randomString = () =&gt; Math.random() .toString(36) .substring(7) .split('') .join('.')const ActionTypes = &#123; INIT: `@@redux/INIT$&#123;randomString()&#125;`, REPLACE: `@@redux/REPLACE$&#123;randomString()&#125;`, PROBE_UNKNOWN_ACTION: () =&gt; `@@redux/PROBE_UNKNOWN_ACTION$&#123;randomString()&#125;`&#125;export default ActionTypes 可以看出就是返回了一个 ActionTypes 对象，里面包含三种类型：INIT、REPLACE 和 PROBE_UNKNOW_ACTION。分别对应之前所说的几种类型，为了防止和用户自定义的 action type 相冲突，刻意在 type 里面加入了随机值。在后面的使用中，通过引入 ActionType 对象来进行对比。 isPlainObject.js 这个函数用于判断传入的对象是否是纯对象，因为 redux 要求 action 和 state 是一个纯对象，所以这个函数诞生了。 上源码： 123456789101112131415161718/** * 判断一个参数是否是纯对象，纯对象的定义就是它的构造函数为 Object。 * 比如： &#123; name: 'isPlainObject', type: 'funciton' &#125;。 * 而 isPlainObject 这个函数就不是纯对象，因为它的构造函数是 Function。 * @param &#123;any&#125; obj 要检查的对象。 * @returns &#123;boolean&#125; 返回的检查结果，true 代表是纯对象。 */export default function isPlainObject(obj) &#123; if (typeof obj !== 'object' || obj === null) return false let proto = obj // 获取最顶级的原型，如果就是自身，那么说明是纯对象。 while (Object.getPrototypeOf(proto) !== null) &#123; proto = Object.getPrototypeOf(proto) &#125; return Object.getPrototypeOf(obj) === proto&#125; warning.js 这个函数用于抛出适当的警告，没啥好说的。 12345678910111213141516171819/** * Prints a warning in the console if it exists. * * @param &#123;String&#125; message The warning message. * @returns &#123;void&#125; */export default function warning(message) &#123; /* eslint-disable no-console */ if (typeof console !== 'undefined' &amp;&amp; typeof console.error === 'function') &#123; console.error(message) &#125; /* eslint-enable no-console */ try &#123; // This error was thrown as a convenience so that if you enable // \"break on all exceptions\" in your console, // it would pause the execution at this line. throw new Error(message) &#125; catch (e) &#123;&#125; // eslint-disable-line no-empty&#125; compose.js 这个函数用于嵌套调用中间件（middleware），进行初始化。 12345678910111213141516171819/** * 传入一系列的单参数函数作为参数（funcs 数组），返回一个新的函数，这个函数可以接受 * 多个参数，运行时会将 funcs 数组中的函数从右至左进行调用。 * @param &#123;...Function&#125; funcs 一系列中间件。 * @returns &#123;Function&#125; 返回的结果函数。 * 从右至左调用,比如： compose(f, g, h) 将会返回一个新函数 * (...args) =&gt; f(g(h(...args))). */export default function compose(...funcs) &#123; if (funcs.length === 0) &#123; return arg =&gt; arg &#125; if (funcs.length === 1) &#123; return funcs[0] &#125; // 通过 reduce 方法迭代。 return funcs.reduce((a, b) =&gt; (...args) =&gt; a(b(...args)))&#125; （4）createStore.js看完了工具函数和入口函数，接下来就要正式步入主题了。我们使用 redux 的重要一步就是通过 createStore 方法创建 store。那么接下来看看这个方法是怎么创建 store 的，store 又是个什么东西呢？ 我们看源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217import $$observable from 'symbol-observable'// 后面会讲。import ActionTypes from './utils/actionTypes'// 引入一些预定义的保留的 action type。import isPlainObject from './utils/isPlainObject'// 判断一个对象是否是纯对象。// 使用 redux 最主要的 API，就是这个 createStore，它用于创建一个 redux store，为你提供状态管理。// 它接受三个参数（第二三个可选），第一个是 reducer，用于改变 redux store 的状态；第二个是初始化的 store,// 即最开始时候 store 的快照；第三个参数是由 applyMiddleware 函数返回的 enhancer 对象，使用中间件必须// 提供的参数。export default function createStore(reducer, preloadedState, enhancer) &#123; // 下面这一段基本可以不看，它们是对参数进行适配的。 /*************************************参数适配****************************************/ if ( (typeof preloadedState === 'function' &amp;&amp; typeof enhancer === 'function') || (typeof enhancer === 'function' &amp;&amp; typeof arguments[3] === 'function') ) &#123; // 如果传递了多个 enhancer，抛出错误。 throw new Error( 'It looks like you are passing several store enhancers to ' + 'createStore(). This is not supported. Instead, compose them ' + 'together to a single function' ) &#125; // 如果没有传递默认的 state（preloadedState 为函数类型，enhancer 为未定义类型），那么传递的 // preloadedState 即为 enhancer。 if (typeof preloadedState === 'function' &amp;&amp; typeof enhancer === 'undefined') &#123; enhancer = preloadedState preloadedState = undefined &#125; if (typeof enhancer !== 'undefined') &#123; if (typeof enhancer !== 'function') &#123; // 如果 enhancer 为不为空且非函数类型，报错。 throw new Error('Expected the enhancer to be a function.') &#125; // 使用 enhancer 对 createStore 进行处理，引入中间件。注意此处没有再传递 enhancer 作为参数。实际上 enhancer 会对 createStore 进行处理，然后返回一个实际意义上的 createStore 用于创建 store 对象，参考 applyMiddleware.js。 return enhancer(createStore)(reducer, preloadedState) &#125; // 如果 reducer 不是函数类型，报错。 if (typeof reducer !== 'function') &#123; throw new Error('Expected the reducer to be a function.') &#125; /*********************************************************************************/ // 在函数内部定义一系列局部变量，用于存储数据。 let currentReducer = reducer // 存储当前的 reducer。 let currentState = preloadedState // 用于存储当前的 store，即为 state。 let currentListeners = [] // 用于存储通过 store.subscribe 注册的当前的所有订阅者。 let nextListeners = currentListeners // 新的 listeners 数组，确保不直接修改 listeners。 let isDispatching = false // 当前状态，防止 reducer 嵌套调用。 // 顾名思义，确保 nextListeners 可以被修改，当 nextListeners 与 currentListeners 指向同一个数组的时候 // 让 nextListeners 成为 currentListeners 的副本。防止修改 nextListeners 导致 currentListeners 发生变化。 // 一开始我也不是很明白为什么会存在 nextListeners，因为后面 dispatch 函数中还是直接把 nextListeners 赋值给了 currentListeners。 // 直接使用 currentListeners 也是可以的。后来去 redux 的 repo 搜了搜，发现了一个 issue（https://github.com/reduxjs/redux/issues/2157） 讲述了这个做法的理由。 // 提交这段代码的作者的解释（https://github.com/reduxjs/redux/commit/c031c0a8d900e0e95a4915ecc0f96c6fe2d6e92b）是防止 Array.slice 的滥用，只有在必要的时候调用 Array.slice 方法来复制 listeners。 // 以前的做法是每次 dispatch 都要 slice 一次，导致了性能的降低吧。 function ensureCanMutateNextListeners() &#123; if (nextListeners === currentListeners) &#123; nextListeners = currentListeners.slice() &#125; &#125; // 返回 currentState，即 store 的快照。 function getState() &#123; // 防止在 reducer 中调用该方法，reducer 会接受 state 参数。 if (isDispatching) &#123; throw new Error( 'You may not call store.getState() while the reducer is executing. ' + 'The reducer has already received the state as an argument. ' + 'Pass it down from the top reducer instead of reading it from the store.' ) &#125; return currentState &#125; // store.subscribe 函数，订阅 dispatch。 function subscribe(listener) &#123; if (typeof listener !== 'function') &#123; throw new Error('Expected the listener to be a function.') &#125; // 不允许在 reducer 中进行订阅。 if (isDispatching) &#123; throw new Error( 'You may not call store.subscribe() while the reducer is executing. ' + 'If you would like to be notified after the store has been updated, subscribe from a ' + 'component and invoke store.getState() in the callback to access the latest state. ' + 'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.' ) &#125; let isSubscribed = true // 每次操作 nextListeners 之前先确保可以修改。 ensureCanMutateNextListeners() // 存储订阅者的注册方法。 nextListeners.push(listener) // 返回一个用于注销当前订阅者的函数。 return function unsubscribe() &#123; if (!isSubscribed) &#123; return &#125; if (isDispatching) &#123; throw new Error( 'You may not unsubscribe from a store listener while the reducer is executing. ' + 'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.' ) &#125; isSubscribed = false // 每次操作 nextListeners 之前先确保可以修改。 ensureCanMutateNextListeners() const index = nextListeners.indexOf(listener) nextListeners.splice(index, 1) &#125; &#125; // store.dispatch 函数，用于触发 reducer 修改 state。 function dispatch(action) &#123; if (!isPlainObject(action)) &#123; // action 必须是纯对象。 throw new Error( 'Actions must be plain objects. ' + 'Use custom middleware for async actions.' ) &#125; if (typeof action.type === 'undefined') &#123; // 每个 action 必须包含一个 type 属性，指定修改的类型。 throw new Error( 'Actions may not have an undefined \"type\" property. ' + 'Have you misspelled a constant?' ) &#125; // reducer 内部不允许派发 action。 if (isDispatching) &#123; throw new Error('Reducers may not dispatch actions.') &#125; try &#123; // 调用 reducer 之前，先将标志位置一。 isDispatching = true // 调用 reducer，返回的值即为最新的 state。 currentState = currentReducer(currentState, action) &#125; finally &#123; // 调用完之后将标志位置 0，表示 dispatch 结束。 isDispatching = false &#125; // dispatch 结束之后，执行所有订阅者的函数。 const listeners = (currentListeners = nextListeners) for (let i = 0; i &lt; listeners.length; i++) &#123; const listener = listeners[i] listener() &#125; // 返回当前所使用的 action，这一步是中间件嵌套使用的关键，很重要。 return action &#125; // 一个比较新的 API，用于动态替换当前的 reducers。适用于按需加载，代码拆分等场景。 function replaceReducer(nextReducer) &#123; if (typeof nextReducer !== 'function') &#123; throw new Error('Expected the nextReducer to be a function.') &#125; // 执行默认的 REPLACE 类型的 action。在 combineReducers 函数中有使用到这个类型。 currentReducer = nextReducer dispatch(&#123; type: ActionTypes.REPLACE &#125;) &#125; // 这是为了适配 ECMA TC39 会议的一个有关 Observable 的提案（参考https://github.com/tc39/proposal-observable）所写的一个函数。 // 作用是订阅 store 的变化，适用于所有实现了 Observable 的类库（主要是适配 RxJS）。 // 我找到了引入这个功能的那个 commit：https://github.com/reduxjs/redux/pull/1632。 function observable() &#123; // outerSubscribe 即为外部的 subscribe 函数。 const outerSubscribe = subscribe // 返回一个纯对象，包含 subscribe 方法。 return &#123; subscribe(observer) &#123; if (typeof observer !== 'object' || observer === null) &#123; throw new TypeError('Expected the observer to be an object.') &#125; // 用于给 subscribe 注册的函数，严格按照 Observable 的规范实现，observer 必须有一个 next 属性。 function observeState() &#123; if (observer.next) &#123; observer.next(getState()) &#125; &#125; observeState() const unsubscribe = outerSubscribe(observeState) return &#123; unsubscribe &#125; &#125;, // $$observable 即为 Symbol.observable，也属于 Observable 的规范，返回自身。 [$$observable]() &#123; return this &#125; &#125; &#125; // 初始化时 dispatch 一个 INIT 类型的 action，校验各种情况。 dispatch(&#123; type: ActionTypes.INIT &#125;) // 返回一个 store 对象。 return &#123; dispatch, subscribe, getState, replaceReducer, [$$observable]: observable &#125;&#125; 不难发现，我们的 store 对象就是一个纯 JavaScript 对象。包含几个属性 API，而我们的 state 就存储在 createStore 这个方法内部，是一个局部变量，只能通过 getState 方法访问到。这里实际上是对闭包的利用，所有我们操作的 state 都存储在 getState 方法内部的一个变量里面。直到我们的程序结束（或者说 store 被销毁），createStore 方法才会被回收，里面的变量才会被销毁。 而 subscribe 方法就是对观察者模式的利用（注意不是发布订阅模式，二者有区别，不要混淆），我们通过 subscribe 方法注册我们的函数，我们的函数会给存储到 createStore 方法的一个局部变量当中，每次 dispatch 被调用之后，都会遍历一遍 currentListeners，依次执行其中的方法，达到我们订阅的要求。 （5）combineReducers.js了解了 createStore 到底是怎么一回事，我们再来看看 combineReducers 到底是怎么创建 reducer 的。 我们写 reducer 的时候，实际上是在写一系列函数，然后整个到一个对象的属性上，最后传给 combineReducers 进行处理，处理之后就可以供 createStore 使用了。 例如： 123456789101112131415// 创建我们的 reducers。const _reducers = &#123; items(items = [], &#123; type, payload &#125;) &#123; if (type === 'ADD_ITEMS') items.push(payload); return items; &#125;, isLoading(isLoading = false, &#123; type, payload &#125;) &#123; if (type === 'IS_LOADING') return true; return false; &#125;&#125;;// 交给 combineReducers 处理，适配 createStore。const reducers = combineReducers(_reducers);// createStore 接受 reducers，创建我们需要的 store。const store = createStore(reducers); 那么 combineReducers 对我们的 reducers 对象进行了哪些处理呢？ 下面的代码比较长，希望大家能有耐心。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208import ActionTypes from './utils/actionTypes'import warning from './utils/warning'import isPlainObject from './utils/isPlainObject'/** * 用于获取错误信息的工具函数，如果调用你所定义的某个 reducer 返回了 undefined，那么就调用这个函数 * 抛出合适的错误信息。 * * @param &#123;String&#125; key 你所定义的某个 reducer 的函数名，同时也是 state 的一个属性名。 * * @param &#123;Object&#125; action 调用 reducer 时所使用的 action。 */function getUndefinedStateErrorMessage(key, action) &#123; const actionType = action &amp;&amp; action.type const actionDescription = (actionType &amp;&amp; `action \"$&#123;String(actionType)&#125;\"`) || 'an action' return ( `Given $&#123;actionDescription&#125;, reducer \"$&#123;key&#125;\" returned undefined. ` + `To ignore an action, you must explicitly return the previous state. ` + `If you want this reducer to hold no value, you can return null instead of undefined.` )&#125;/** * 工具函数，用于校验未知键，如果 state 中的某个属性没有对应的 reducer，那么返回报错信息。 * 对于 REPLACE 类型的 action type，则不进行校验。 * @param &#123;Object&#125; inputState * @param &#123;Object&#125; reducers * @param &#123;Object&#125; action * @param &#123;Object&#125; unexpectedKeyCache */function getUnexpectedStateShapeWarningMessage( inputState, reducers, action, unexpectedKeyCache) &#123; const reducerKeys = Object.keys(reducers) const argumentName = action &amp;&amp; action.type === ActionTypes.INIT ? 'preloadedState argument passed to createStore' : 'previous state received by the reducer' // 如果 reducers 长度为 0，返回对应错误信息。 if (reducerKeys.length === 0) &#123; return ( 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.' ) &#125; if (!isPlainObject(inputState)) &#123; return ( `The $&#123;argumentName&#125; has unexpected type of \"` + &#123;&#125;.toString.call(inputState).match(/\\s([a-z|A-Z]+)/)[1] + // &#123;&#125;.toString.call(inputState).match(/\\s([a-z|A-Z]+)/)[1] `\". Expected argument to be an object with the following ` + // 返回的是 inputState 的类型。 `keys: \"$&#123;reducerKeys.join('\", \"')&#125;\"` ) &#125; // 获取所有 State 有而 reducers 没有的属性，加入到 unexpectedKeysCache。 const unexpectedKeys = Object.keys(inputState).filter( key =&gt; !reducers.hasOwnProperty(key) &amp;&amp; !unexpectedKeyCache[key] ) // 加入到 unexpectedKeyCache。 unexpectedKeys.forEach(key =&gt; &#123; unexpectedKeyCache[key] = true &#125;) // 如果是 REPLACE 类型的 action type，不再校验未知键，因为按需加载的 reducers 不需要校验未知键，现在不存在的 reducers 可能下次就加上了。 if (action &amp;&amp; action.type === ActionTypes.REPLACE) return if (unexpectedKeys.length &gt; 0) &#123; return ( `Unexpected $&#123;unexpectedKeys.length &gt; 1 ? 'keys' : 'key'&#125; ` + `\"$&#123;unexpectedKeys.join('\", \"')&#125;\" found in $&#123;argumentName&#125;. ` + `Expected to find one of the known reducer keys instead: ` + `\"$&#123;reducerKeys.join('\", \"')&#125;\". Unexpected keys will be ignored.` ) &#125;&#125;/** * 用于校验所有 reducer 的合理性：传入任意值都不能返回 undefined。 * @param &#123;Object&#125; reducers 你所定义的 reducers 对象。 */function assertReducerShape(reducers) &#123; Object.keys(reducers).forEach(key =&gt; &#123; const reducer = reducers[key] // 获取初始化时的 state。 const initialState = reducer(undefined, &#123; type: ActionTypes.INIT &#125;) if (typeof initialState === 'undefined') &#123; throw new Error( `Reducer \"$&#123;key&#125;\" returned undefined during initialization. ` + `If the state passed to the reducer is undefined, you must ` + `explicitly return the initial state. The initial state may ` + `not be undefined. If you don't want to set a value for this reducer, ` + `you can use null instead of undefined.` ) &#125; // 如果初始化校验通过了，有可能是你定义了 ActionTypes.INIT 的操作。这时候重新用随机值校验。 // 如果返回 undefined，说明用户可能对 INIT type 做了对应处理，这是不允许的。 if ( typeof reducer(undefined, &#123; type: ActionTypes.PROBE_UNKNOWN_ACTION() &#125;) === 'undefined' ) &#123; throw new Error( `Reducer \"$&#123;key&#125;\" returned undefined when probed with a random type. ` + `Don't try to handle $&#123; ActionTypes.INIT &#125; or other actions in \"redux/*\" ` + `namespace. They are considered private. Instead, you must return the ` + `current state for any unknown actions, unless it is undefined, ` + `in which case you must return the initial state, regardless of the ` + `action type. The initial state may not be undefined, but can be null.` ) &#125; &#125;)&#125;// 把你所定义的 reducers 对象转化为一个庞大的汇总函数。// 可以看出，combineReducers 接受一个 reducers 对象作为参数，// 然后返回一个总的函数，作为最终的合法的 reducer，这个 reducer // 接受 action 作为参数，根据 action 的类型遍历调用所有的 reducer。export default function combineReducers(reducers) &#123; // 获取 reducers 所有的属性名。 const reducerKeys = Object.keys(reducers) const finalReducers = &#123;&#125; // 遍历 reducers 的所有属性，剔除所有不合法的 reducer。 for (let i = 0; i &lt; reducerKeys.length; i++) &#123; const key = reducerKeys[i] if (process.env.NODE_ENV !== 'production') &#123; if (typeof reducers[key] === 'undefined') &#123; warning(`No reducer provided for key \"$&#123;key&#125;\"`) &#125; &#125; if (typeof reducers[key] === 'function') &#123; // 将 reducers 中的所有 reducer 拷贝到新的 finalReducers 对象上。 finalReducers[key] = reducers[key] &#125; &#125; // finalReducers 是一个纯净的经过过滤的 reducers 了，重新获取所有属性名。 const finalReducerKeys = Object.keys(finalReducers) let unexpectedKeyCache // unexpectedKeyCache 包含所有 state 中有但是 reducers 中没有的属性。 if (process.env.NODE_ENV !== 'production') &#123; unexpectedKeyCache = &#123;&#125; &#125; let shapeAssertionError try &#123; // 校验所有 reducer 的合理性，缓存错误。 assertReducerShape(finalReducers) &#125; catch (e) &#123; shapeAssertionError = e &#125; // 这就是返回的新的 reducer，一个纯函数。每次 dispatch 一个 action，都要执行一遍 combination 函数， // 进而把你所定义的所有 reducer 都执行一遍。 return function combination(state = &#123;&#125;, action) &#123; if (shapeAssertionError) &#123; // 如果有缓存的错误，抛出。 throw shapeAssertionError &#125; if (process.env.NODE_ENV !== 'production') &#123; // 非生产环境下校验 state 中的属性是否都有对应的 reducer。 const warningMessage = getUnexpectedStateShapeWarningMessage( state, finalReducers, action, unexpectedKeyCache ) if (warningMessage) &#123; warning(warningMessage) &#125; &#125; let hasChanged = false // state 是否改变的标志位。 const nextState = &#123;&#125; // reducer 返回的新 state。 for (let i = 0; i &lt; finalReducerKeys.length; i++) &#123; // 遍历所有的 reducer。 const key = finalReducerKeys[i] // 获取 reducer 名称。 const reducer = finalReducers[key] // 获取 reducer。 const previousStateForKey = state[key] // 旧的 state 值。 const nextStateForKey = reducer(previousStateForKey, action) // 执行 reducer 返回的新的 state[key] 值。 if (typeof nextStateForKey === 'undefined') &#123; // 如果经过了那么多校验，你的 reducer 还是返回了 undefined，那么就要抛出错误信息了。 const errorMessage = getUndefinedStateErrorMessage(key, action) throw new Error(errorMessage) &#125; nextState[key] = nextStateForKey // 把返回的新值添加到 nextState 对象上，这里可以看出来，你所定义的 reducer 的名称就是对应的 state 的属性，所以 reducer 命名要规范！ hasChanged = hasChanged || nextStateForKey !== previousStateForKey // 检验 state 是否发生了变化。 &#125; // 根据标志位返回对应的 state。 return hasChanged ? nextState : state &#125;&#125; （6）applyMiddleware.jscombineReducers 方法代码比较多，但是实际逻辑还是很简单的，接下来这个函数代码不多，但是逻辑要稍微复杂一点，它就是应用中间件的 applyMiddleware 函数。这个函数的思想比较巧妙，值得学习。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import compose from './compose'// 用于应用中间件的函数，可以同时传递多个中间件。中间件的标准形式为：// const middleware = store =&gt; next =&gt; action =&gt; &#123; /*.....*/ return next(action); &#125;export default function applyMiddleware(...middlewares) &#123; // 返回一个函数，接受 createStore 作为参数。args 参数即为 reducer 和 preloadedState。 return createStore =&gt; (...args) =&gt; &#123; // 在函数内部调用 createStore 创建一个 store 对象，这里不会传递 enhancer，因为 applyMiddleware 本身就是在创建一个 enhancer，然后给 createStore 调用。 // 这里实际上是通过 applyMiddleware 把 store 的创建推迟了。为什么要推迟呢？因为要利用 middleWares 做文章，先初始化中间件，重新定义 dispatch，然后再创建 store，这时候创建的 store 所包含的 dispatch 方法就区别于不传递 enhancer 时所创建的 dispatch 方法了,其中包含了中间件所定义的一些逻辑，这就是为什么中间件可以干预 dispatch 的原因。 const store = createStore(...args) // 这里对 dispatch 进行了重新定义，不管传入什么参数，都会报错，这样做的目的是防止你的中间件在初始化的时候就 // 调用 dispatch。 let dispatch = () =&gt; &#123; throw new Error( `Dispatching while constructing your middleware is not allowed. ` + `Other middleware would not be applied to this dispatch.` ) &#125; const middlewareAPI = &#123; getState: store.getState, dispatch: (...args) =&gt; dispatch(...args) // 注意最后 dispatch 的时候不会访问上面报错的那个 dispatch 函数了，因为那个函数被下面的 dispatch 覆盖了。 &#125; // 对于每一个 middleware，都传入 middlewareAPI 进行调用，这就是中间件的初始化。 // 初始化后的中间件返回一个新的函数，这个函数接受 store.dispatch 作为参数，返回一个替换后的 dispatch，作为新的 // store.dispatch。 const chain = middlewares.map(middleware =&gt; middleware(middlewareAPI)) // compose 方法把所有中间件串联起来调用。用最终结果替换 dispatch 函数，之后所使用的所有 store.dispatch 方法都已经是 // 替换了的，加入了新的逻辑。 dispatch = compose(...chain)(store.dispatch) // 初始化中间件以后，把报错的 dispatch 函数覆盖掉。 /** * middle 的标准形式： * const middleware = (&#123; getState, dispatch &#125;) =&gt; next =&gt; action =&gt; &#123; * // .... * return next(action); * &#125; * 这里 next 是经过上一个 middleware 处理了的 dispatch 方法。 * next(action) 返回的仍然是一个 dispatch 方法。 */ return &#123; ...store, dispatch // 全新的 dispatch。 &#125; &#125;&#125; 代码量真的很少，但是真的很巧妙，这里有几点很关键： compose 方法利用 Array.prototype.reduce 实现中间件的嵌套调用，返回一个全新的函数，可以接受新的参数（上一个中间件处理过的 dispatch），最终返回一个全新的包含新逻辑的 dispatch 方法。你看 middleware 经过初始化后返回的函数的格式： 123next =&gt; action =&gt; &#123; return next(action);&#125; 其中 next 可以看成 dispatch，这不就是接受一个 dispatch 作为参数，然后返回一个新的 dispatch 方法吗？原因就是我们可以认为接受 action 作为参数，然后触发 reducer 更改 state 的所有函数都是 dispatch 函数。 middleware 中间件经过初始化以后，返回一个新函数，它接受 dispatch 作为参数，然后返回一个新的 dispatch 又可以供下一个 middleware 调用，这就导致所有的 middleware 可以嵌套调用了！而且最终返回的结果也是一个 dispatch 函数。 最终得到的 dispatch 方法，是把原始的 store.dispatch 方法传递给最后一个 middleware，然后层层嵌套处理，最后经过第一个 middleware 处理过以后所返回的方法。所以我们在调用应用了中间件的 dispatch 函数时，从左至右的经过了 applyMiddleware 方法的所有参数（middleware）的处理。这有点像是包裹和拆包裹的过程。 为什么 action 可以经过所有的中间件处理呢？我们再来看看中间件的基本结构： 123(&#123; dispatch, getState &#125;) =&gt; next =&gt; action =&gt; &#123; return next(action);&#125; 我们可以看到 action 进入函数以后，会经过 next 的处理，并且会返回结果。next 会返回什么呢？因为第一个 next 的值就是 store.dispatch，所以看看 store.dispatch 的源码就知道了。 123456function dispatch(action) &#123; // 省略了一系列操作的代码…… // 返回当前所使用的 action，这一步是中间件嵌套使用的关键。 return action&#125; 没错，store.dispatch 最终返回了 action，由于中间件嵌套调用，所以每个 next 都返回 action，然后又可以供下一个 next 使用，环环相扣，十分巧妙。 这部分描述的有点拗口，语言捉急但又不想画图，各位还是自己多想想好了。 （7）bindActionCreators.js这个方法没有太多好说的，主要作用是减少大家 dispatch reducer 所要写的代码，比如你原来有一个 action： 1234const addItems = item =&gt; (&#123; type: 'ADD_ITEMS', payload: item&#125;); 然后你要调用它的时候： 1store.dispatch(addItems('item value')); 如果你使用 bindActionCreators： 1const _addItems = bindActionCreators(addItems, store.dispatch); 当你要 dispatch reducer 的时候： 1_addItems('item value')； 这样就减少了你要写的重复代码，另外你还可以把所有的 action 写在一个对象里面传递给 bindActionCreators，就像传递给 combineReducers 的对象那样。 下面看看源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 该函数返回一个新的函数，调用新的函数会直接 dispatch ActionCreator 所返回的 action。 * 这个函数是 bindActionCreators 函数的基础，在 bindActionCreators 函数中会把 actionCreators 拆分成一个一个 * 的 ActionCreator，然后调用 bindActionCreator 方法。 * @param &#123;Function&#125; actionCreator 一个返回 action 纯对象的函数。 * @param &#123;Function&#125; dispatch store.dispatch 方法，用于触发 reducer。 */function bindActionCreator(actionCreator, dispatch) &#123; return function() &#123; return dispatch(actionCreator.apply(this, arguments)) &#125;&#125;// 接受一个 actionCreator（或者一个 actionCreators 对象）和一个 dispatch 函数作为参数，// 然后返回一个函数或者一个对象，直接执行这个函数或对象中的函数可以让你不必再调用 dispatch。export default function bindActionCreators(actionCreators, dispatch) &#123; // 如果 actionCreators 是一个函数而非对象，那么直接调用 bindActionCreators 方法进行转换，此时返回 // 结果也是一个函数，执行这个函数会直接 dispatch 对应的 action。 if (typeof actionCreators === 'function') &#123; return bindActionCreator(actionCreators, dispatch) &#125; // actionCreators 既不是函数也不是对象，或者为空时，抛出错误。 if (typeof actionCreators !== 'object' || actionCreators === null) &#123; throw new Error( `bindActionCreators expected an object or a function, instead received $&#123; actionCreators === null ? 'null' : typeof actionCreators &#125;. ` + `Did you write \"import ActionCreators from\" instead of \"import * as ActionCreators from\"?` ) &#125; // 如果 actionCreators 是一个对象，那么它的每一个属性就应该是一个 actionCreator，遍历每一个 actionCreator， // 使用 bindActionCreator 进行转换。 const keys = Object.keys(actionCreators) const boundActionCreators = &#123;&#125; for (let i = 0; i &lt; keys.length; i++) &#123; const key = keys[i] const actionCreator = actionCreators[key] // 把转换结果绑定到 boundActionCreators 对象，最后会返回它。 if (typeof actionCreator === 'function') &#123; boundActionCreators[key] = bindActionCreator(actionCreator, dispatch) &#125; &#125; return boundActionCreators&#125; 这部分挺简单的，主要作用在于把 action creator 转化为可以直接使用的函数。 三、中间件看了源码以后，觉得中间件并没有想象中的那么晦涩难懂了。就是一个基本的格式，然后你在你的中间件里面可以为所欲为，最后调用固定的方法，返回固定的内容就完事了。这就是为什么大多数 redux middleware 的源码都很短小精悍的原因。 看看 redux-thunk 的源码： 1234567891011121314function createThunkMiddleware(extraArgument) &#123; return (&#123; dispatch, getState &#125;) =&gt; next =&gt; action =&gt; &#123; if (typeof action === 'function') &#123; return action(dispatch, getState, extraArgument); &#125; return next(action); &#125;;&#125;const thunk = createThunkMiddleware();thunk.withExtraArgument = createThunkMiddleware;export default thunk; 是不是很短很小？那么到底干了什么让它这么受欢迎呢？ 实际上 redux-thunk 可以被认为就是： 1234567891011// 这就是典型的 middleware 格式。(&#123; dispatch, getState &#125;) =&gt; next =&gt; action =&gt; &#123; // next 就是 dispatch 方法。注释所在的函数就是返回的新的 dispatch。 // 先判断一下 action 是不是一个函数。 if (typeof action === 'function') &#123; // 如果是函数，调用它，传递 dispatch，getState 和 多余的参数作为 aciton 的参数。 return action(dispatch, getState, extraArgument); &#125; // 如果 action 不是函数，直接 nextr调用 action，返回结果就完事儿了。 return next(action);&#125;; 怎么样，是不是很简单？它干的事就是判断了一下 action 的类型，如果是函数就调用，不是函数就用 dispatch 来调用，很简单。 但是它实现的功能很实用，允许我们传递函数作为 store.dispatch 的参数，这个函数的参数应该是固定的，必须符合上面代码的要求，接受 dispatch、getState作为参数，然后这个函数应该返回实际的 action。 我们也可以写一个自己的中间件了： 123(&#123; dispatch, getState &#125;) =&gt; next =&gt; action =&gt; &#123; return action.then ? action.then(next) : next(action);&#125; 这个中间件允许我们传递一个 Promise 对象作为 action，然后会等 action 返回结果（一个真正的 action）之后，再进行 dispatch。 当然由于 action.then() 返回的不是实际上的 action（一个纯对象），所以这个中间件可能没法跟其他中间件一起使用，不然其他中间件接受不到 action 会出问题。这只是个示例，用于说明中间件没那么复杂，但是我们可以利用中间件做很多事情。 如果想要了解更加复杂的 redux 中间件，可以参考： redux-promise redux-saga redux-logger 四、总结 Redux 精妙小巧，主要利用了闭包和观察者模式，然后运用了职责链、适配器等模式构建了一个 store 王国。store 拥有自己的领土，要想获取或改变 store 里面的内容，必须通过 store 的各个函数来实现。 Redux 相比于 Vuex 而言，代码量更小，定制化程度更低，这就导致易用性低于 Vuex，但是可定制性高于 Vuex。这也符合 Vue 和 React 的风格。 Redux 源码比较好懂，读懂源码更易于掌握 Redux 的使用方法，不要被吓倒。 Redux 中间件短小精悍，比较实用。如果从使用方法开始学中间件比较难懂的话，可以尝试从源码学习中间件。 最后，时间紧迫，水平有限，难免存在纰漏或错误，请大家多多包涵、多多指教、共同进步。 欢迎来我的 GitHub 下载项目源码；或者 Follow me。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://zhongdeming.fun/categories/JavaScript/"},{"name":"Redux","slug":"JavaScript/Redux","permalink":"http://zhongdeming.fun/categories/JavaScript/Redux/"}],"tags":[]},{"title":"Vue 异步组件","slug":"异步组件","date":"2018-12-01T08:29:39.000Z","updated":"2021-05-07T21:21:43.640Z","comments":true,"path":"2018/12/01/异步组件/","link":"","permalink":"http://zhongdeming.fun/2018/12/01/异步组件/","excerpt":"最近在做一个 Vue 项目的时候，突然发现了一个有意思的知识点。 有几位客服反馈说在点击某个链接跳转的时候，老是没得反应，导致选不了选项。我就很奇怪，内网环境下是没有问题的，所以代码出问题的可能性不大，怎么外网就有这种问题呢？后来仔细看了一下才发现，原来是运维那边出了点纰漏导致外网有些客户的 JavaScript 资源加载不出来，进而导致无法跳转。这里涉及到了 Vue 的异步组件知识，只有当切换到某个组件时，其单独打包的资源才会被加载。不同于统一打包的情况，这样做可以利用代码切割减少首屏加载时的资源大小，能够提升一定的加载速度，优化用户体验。接下来就自己重新做一下这个异步组件。 以下命令行操作均在 Linux 环境下进行。 一、搭建项目先切换到你的项目根目录下，此时应该是一个空文件夹。 然后用 npm 命令初始化，添加具有一些默认选项的 package.json 文件。 1$ npm init -y 然后开始创建必要的文件： 1$ sudo touch .babelrc index.html","text":"最近在做一个 Vue 项目的时候，突然发现了一个有意思的知识点。 有几位客服反馈说在点击某个链接跳转的时候，老是没得反应，导致选不了选项。我就很奇怪，内网环境下是没有问题的，所以代码出问题的可能性不大，怎么外网就有这种问题呢？后来仔细看了一下才发现，原来是运维那边出了点纰漏导致外网有些客户的 JavaScript 资源加载不出来，进而导致无法跳转。这里涉及到了 Vue 的异步组件知识，只有当切换到某个组件时，其单独打包的资源才会被加载。不同于统一打包的情况，这样做可以利用代码切割减少首屏加载时的资源大小，能够提升一定的加载速度，优化用户体验。接下来就自己重新做一下这个异步组件。 以下命令行操作均在 Linux 环境下进行。 一、搭建项目先切换到你的项目根目录下，此时应该是一个空文件夹。 然后用 npm 命令初始化，添加具有一些默认选项的 package.json 文件。 1$ npm init -y 然后开始创建必要的文件： 1$ sudo touch .babelrc index.html index.html 中写入一下代码，作为固定模板： 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-ch\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Async Components&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; .babelrc 是配置 babel 转译器的，等会再来配置。 接下来创建必要的文件夹： 1$ sudo mkdir -p build dist src/components src/routers 在 build 目录下创建三个文件，作为 Webpack 打包的配置文件： webpack.base.conf.js webpack.dev.conf.js webpack.prod.conf.js 然后安装必要的依赖： 1$ npm i -D babel-loader@7 babel-core babel-preset-env webpack webpack-cli clean-webpack-plugin css-loader html-webpack-plugin vue-loader vue-style-loader vue-template-compiler webpack-dev-server webpack-merge 1$ npm i -S vue vue-router 然后把下面的配置代码扔到对应的配置文件中： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// webpack.base.conf.jsconst path = require('path');const htmlWebpackPlugin = require('html-webpack-plugin');const cleanWebpackPlugin = require('clean-webpack-plugin');const VueLoaderPlugin = require('vue-loader/lib/plugin');module.exports = &#123; target: 'web', entry: &#123; index: path.resolve(__dirname, '../src/index.js') &#125;, output: &#123; filename: '[name].[hash].js', path: path.resolve(__dirname, '../dist/') &#125;, resolve: &#123; extensions: ['.vue', '.js', '.json', '.css'], alias: &#123; '@': path.resolve(__dirname, '../src'), 'vue': 'vue/dist/vue.js', 'components': path.resolve(__dirname, '../src/components') &#125; &#125;, node: &#123; fs: 'empty' &#125;, module: &#123; rules: [ &#123; test: /\\.m?js$/, exclude: /node_modules/, use: 'babel-loader' &#125;, &#123; test: /\\.css$/, use: ['vue-style-loader', 'css-loader'] &#125;, &#123; test: /\\.vue$/, use: 'vue-loader' &#125; ] &#125;, plugins: [ new htmlWebpackPlugin(&#123; inject: true, template: path.resolve(__dirname, '../index.html') &#125;), new cleanWebpackPlugin(['dist'], &#123; root: path.resolve(__dirname, '../'), verbose: true, dry: false &#125;), new VueLoaderPlugin() ]&#125;; 123456789101112131415161718// webpack.dev.conf.jsconst merge = require('webpack-merge');const path = require('path');const baseConfig = require('./webpack.base.conf.js');module.exports = merge(baseConfig, &#123; mode: 'development', devServer: &#123; contentBase: path.resolve(__dirname, '../dist/'), port: 8888, open: true, // hot: true watchOptions: &#123; watch: true &#125; &#125;, devtool: 'inline-source-map'&#125;); 123456789// webpack.prod.conf.jsconst merge = require('webpack-merge');const path = require('path');const baseConfig = require('./webpack.base.conf.js');module.exports = merge(baseConfig, &#123; mode: 'production', devtool: 'source-map'&#125;); 具体怎么配置这里就不赘述了，之前也写过这类型的博客，可以参考一下：基于 Webpack 4 搭建 Vue 开发环境。 然后配置 babel： 在 .babelrc 中写入以下内容： 12345&#123; &quot;presets&quot;: [ &quot;babel-preset-env&quot; ]&#125; 然后就可以准备开发了。 二、开始 Vue 开发。在 src 目录下创建一个 index.js 文件作为打包入口文件，然后： 123456789101112131415// /src/index.jsimport Vue from 'vue';import VueRouter from 'vue-router';import App from './App';import routerConfig from '@/routers';Vue.use(VueRouter);const routers = new VueRouter(routerConfig);new Vue(&#123; el: '#app', components: &#123; App &#125;, router: routers, template: '&lt;div&gt;&lt;App/&gt;&lt;/div&gt;'&#125;); 其中引用了一个同级目录下的 App 作为子组件，App.vue 代码： 1234567891011121314151617181920&lt;template&gt; &lt;div&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;router-link to=&quot;/javascript&quot;&gt;JavaScript&lt;/router-link&gt; &lt;router-link to=&quot;/java&quot;&gt;Java&lt;/router-link&gt; &lt;router-link to=&quot;/python&quot;&gt;Python&lt;/router-link&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &apos;app&apos; &#125;&lt;/script&gt;&lt;style scoped&gt; h1 &#123; color: blue &#125;&lt;/style&gt; 注意到我们的 Vue-Router 配置写在 /src/routers/index.js 中，代码如下： 123456789101112131415161718192021module.exports = &#123; mode: 'hash', routes: [ &#123; path: '/javascript', component: (resolve) =&gt; &#123;require(['components/javascript'], resolve)&#125; &#125;, &#123; path: '/java', component: (resolve) =&gt; &#123;require(['components/java'], resolve)&#125; &#125;, &#123; path: '/python', component: (resolve) =&gt; &#123;require(['components/python'], resolve)&#125; &#125;, &#123; path: '/*', redirect: '/javascript' &#125; ]&#125; 然后在 components 目录下写我们对应的三个组件： 12345678910// java.vue&lt;template&gt; &lt;h1&gt;Java&lt;/h1&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;java&apos;&#125;&lt;/script&gt; 12345678910// javascript.vue&lt;template&gt; &lt;h1&gt;JavaScript&lt;/h1&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;javascript&apos;&#125;&lt;/script&gt; 12345678910// python.vue&lt;template&gt; &lt;h1&gt;Python&lt;/h1&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;python&apos;&#125;&lt;/script&gt; 修改 npm scriptsnpm scripts 的定义如下： 12345\"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"dev\": \"webpack-dev-server --config ./build/webpack.dev.conf.js\", \"build\": \"webpack --config ./build/webpack.prod.conf.js\"&#125;, 最后运行起来本地测试服务器： 1$ npm run dev 打开浏览器的开发者工具，切换到 Network 选项卡，点击不同的链接，可以看到在加载切换路由时，会加载对应打包出来的 js 资源。 运行 npm run build，可以看到打包出来了多个 js 资源文件： 总结 是一个 Webpack 打包 Vue 项目的优化点，通过异步组件，可以切割我们的代码，提升用户体验。 异步组件切割代码实现简单，只需要改变配置 Vue-Router 的方式即可，指定路由对应的组件时，使用如下方式： 123456&#123; path: '/XXX', component: resolve =&gt; &#123; require(['./XXX.vue'], resolve); &#125;&#125;","categories":[{"name":"Webpack","slug":"Webpack","permalink":"http://zhongdeming.fun/categories/Webpack/"},{"name":"Vue","slug":"Webpack/Vue","permalink":"http://zhongdeming.fun/categories/Webpack/Vue/"}],"tags":[]},{"title":"第一个 Servlet","slug":"第一个-Servlet","date":"2018-11-26T12:47:10.000Z","updated":"2021-05-07T21:21:43.640Z","comments":true,"path":"2018/11/26/第一个-Servlet/","link":"","permalink":"http://zhongdeming.fun/2018/11/26/第一个-Servlet/","excerpt":"简单记录一下我从头写一个 Servlet 的过程。 我安装的是 Tomcat 7 版本，在 Ubuntu 18.04 上运行，IDE 为 Intellij IDEA。 首先创建一个 Java Web 项目，进入你的 IDEA，然后点击 Create New Project。如下图所示：","text":"简单记录一下我从头写一个 Servlet 的过程。 我安装的是 Tomcat 7 版本，在 Ubuntu 18.04 上运行，IDE 为 Intellij IDEA。 首先创建一个 Java Web 项目，进入你的 IDEA，然后点击 Create New Project。如下图所示： 选择完毕之后点击下一步。 然后给你的项目取个名字，第一个就叫 HelloWorld 好了。 第三步是新建一个 Java 类文件，在你的 src 路径下，新建包和 Java 类文件，然后在类文件中开始写一个 Servlet。 写一个最简单的 Servlet，只实现一个 Get 请求，这就需要我们的 Servlet 类继承 HttpServlet 父类，然后重写 doGet 方法。 具体代码如下： 123456789101112131415161718package cn.zhongdeming;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;import java.io.Writer;public class HelloWorld extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;// super.doGet(req, resp); Writer writer = resp.getWriter(); ((PrintWriter) writer).print(\"&lt;h1&gt;Hello World!&lt;/h1&gt;&lt;p&gt;This is from a Java Servlet!&lt;/p&gt;\"); &#125;&#125; 在 doGet 方法中，我们通过 resp 对象的 getWriter 方法，获取到了一个 PrintWriter 对象。然后我们可以通过这个对象向客户端浏览器做出回应。 我们传回去了一个字符串，是一个标题和一段文字。 写好了 Servlet 还不够，还要配置 Servlet，让 Tomcat 容器能够知道我们的 Servlet 的信息。 写好我们的 web.xml： 1234567891011121314&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;servlet&gt; &lt;servlet-name&gt;HelloWorld&lt;/servlet-name&gt; &lt;servlet-class&gt;cn.zhongdeming.HelloWorld&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;HelloWorld&lt;/servlet-name&gt; &lt;url-pattern&gt;/HelloWorld&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 需要我们写的代码是 servlet 节点和 servlet-mapping 节点以及它们所有的子节点。分别交代了我们的 HelloWorld Servlet 的位置，以及其对应的前端路由。 接下来我们就可以启动我们的 Tomcat 查看效果了。 点击右上角的运行按钮，启动 Tomcat： 然后在我们的浏览器中输入 localhost:8080/HelloWorld，即可看到效果如下： 注意事项 如果第一次新建 Java Web 项目，还需要配置 IDEA Intellij。具体参考：Intellij 新建 Java Web 项目 IDEA 有可能无法找到 javax.servlet，需要手动导入 Tomcat 安装目录下的 lib 文件夹中的 servlet-api.jar 包。","categories":[{"name":"Java","slug":"Java","permalink":"http://zhongdeming.fun/categories/Java/"}],"tags":[]},{"title":"六种排序算法的JavaScript实现以及总结","slug":"六种排序算法的JavaScript实现以及总结","date":"2018-11-02T13:30:59.000Z","updated":"2021-05-07T21:21:43.640Z","comments":true,"path":"2018/11/02/六种排序算法的JavaScript实现以及总结/","link":"","permalink":"http://zhongdeming.fun/2018/11/02/六种排序算法的JavaScript实现以及总结/","excerpt":"最近几天在系统的复习排序算法，之前都没有系统性的学习过，也没有留下过什么笔记，所以很快就忘了，这次好好地学习一下。 首先说明为了减少限制，以下代码通通运行于Node V8引擎而非浏览器，源码在我的GitHub，感兴趣的话可以下载来然后运行试试。 为了方便对比各个排序算法的性能，这里先写了一个生成大规模数组的方法——generateArray：1234567exports.generateArray = function(length) &#123; let arr = Array(length); for(let i=0; i&lt;length; i++) &#123; arr[i] = Math.random(); &#125; return arr;&#125;; 只需要输入数组长度，即可生成一个符合长度要求的随机数组。","text":"最近几天在系统的复习排序算法，之前都没有系统性的学习过，也没有留下过什么笔记，所以很快就忘了，这次好好地学习一下。 首先说明为了减少限制，以下代码通通运行于Node V8引擎而非浏览器，源码在我的GitHub，感兴趣的话可以下载来然后运行试试。 为了方便对比各个排序算法的性能，这里先写了一个生成大规模数组的方法——generateArray：1234567exports.generateArray = function(length) &#123; let arr = Array(length); for(let i=0; i&lt;length; i++) &#123; arr[i] = Math.random(); &#125; return arr;&#125;; 只需要输入数组长度，即可生成一个符合长度要求的随机数组。 一、冒泡排序冒泡排序也成为沉淀排序(sinking sort)，冒泡排序得名于其排序方式，它遍历整个数组，将数组的每一项与其后一项进行对比，如果不符合要求就交换位置，一共遍历n轮，n为数组的长度。n轮之后，数组得以完全排序。整个过程符合要求的数组项就像气泡从水底冒到水面一样泡到数组末端，所以叫做冒泡排序。 冒泡排序是最简单的排序方法，容易理解、实现简单，但是冒泡排序是效率最低的排序算法，由于算法嵌套了两轮循环（将数组遍历了n遍），所以时间复杂度为O(n^2)。最好的情况下，给出一个已经排序的数组进行冒泡排序，时间复杂度也为O(n)。 特地感谢一下评论中@雪之祈舞的优化，每次冒泡都忽略尾部已经排序好的i项。 JavaScript实现（从小到大排序）：1234567891011121314151617function bubbleSort(arr) &#123; //console.time('BubbleSort'); // 获取数组长度，以确定循环次数。 let len = arr.length; // 遍历数组len次，以确保数组被完全排序。 for(let i=0; i&lt;len; i++) &#123; // 遍历数组的前len-i项，忽略后面的i项（已排序部分）。 for(let j=0; j&lt;len - 1 - i; j++) &#123; // 将每一项与后一项进行对比，不符合要求的就换位。 if(arr[j] &gt; arr[j+1]) &#123; [arr[j+1], arr[j]] = [arr[j], arr[j+1]]; &#125; &#125; &#125; //console.timeEnd('BubbleSort'); return arr;&#125; 代码中的注释部分的代码都用于输出排序时间，供测试使用，下文亦如是。 二、选择排序选择排序是一种原址比较排序法，大致思路： 找到数组中的最小（大）值，并将其放到第一位，然后找到第二小的值放到第二位……以此类推。 JavaScript实现（从小到大排序）：1234567891011121314151617181920function selectionSort(arr) &#123; //console.time('SelectionSort'); // 获取数组长度，确保每一项都被排序。 let len = arr.length; // 遍历数组的每一项。 for(let i=0; i&lt;len; i++) &#123; // 从数组的当前项开始，因为左边部分的数组项已经被排序。 let min = i; for(let j=i; j&lt;len; j++) &#123; if(arr[j]&lt;arr[i]) &#123; min = j; &#125; &#125; if(min !== i) &#123; [arr[min], arr[i]] = [arr[i], arr[min]]; &#125; &#125; //console.timeEnd('SelectionSort'); return arr;&#125; 由于嵌套了两层循环，其时间复杂度也是O(n^2)， 三、插入排序插入排序是最接近生活的排序，因为我们打牌时就差不多是采用的这种排序方法。该方法从数组的第二项开始遍历数组的n-1项（n为数组长度），遍历过程中对于当前项的左边数组项，依次从右到左进行对比，如果左边选项大于（或小于）当前项，则左边选项向右移动，然后继续对比前一项，直到找到不大于（不小于）自身的选项为止，对于所有大于当前项的选项，都在原来位置的基础上向右移动了一项。 示例：1234567891011121314151617181920212223242526// 对于如下数组var arr = [2,1,3,5,4,3];// 从第二项（即arr[1]）开始遍历，// 第一轮：// a[0] &gt;= 1为true，a[0]右移，arr = [2,2,3,5,4,3];// 然后1赋给a[0]，arr = [1,2,3,5,4,3];// 然后第二轮：// a[1] &gt;= 3不成立，该轮遍历结束。// 第三轮;// a[2] &gt;= 5不成立，该轮遍历结束。// 第四轮：// a[3] &gt;= 4为true，a[3]右移，arr = [1,2,3,5,5,3];// a[2] &gt;= 4不成立，将4赋给a[3]，然后结束该轮遍历。arr = [1,2,3,4,5,3];// a[4] &gt;= 3成立，a[4]右移一位，arr = [1,2,3,4,5,5];// arr[3] &gt;= 3成立，arr[3]右移一位，arr = [1,2,3,4,4,5];// arr[2] &gt;= 3成立，arr[2]右移一位，arr = [1,2,3,3,4,5];// arr[1] &gt;= 3不成立，将3赋给a[2]，结束该轮。arr = [1,2,3,3,4,5];// 遍历完成，排序结束。 如果去掉比较时的等号的话，可以减少一些步骤，所以在JavaScript代码中减少了这部分，JavaScript实现（从小到大排序）：123456789101112131415function insertionSort(arr) &#123; //console.time('InsertionSort'); let len = arr.length; for(let i=1; i&lt;len; i++) &#123; let j = i; let tmp = arr[i]; while(j &gt; 0 &amp;&amp; arr[j-1] &gt; tmp) &#123; arr[j] = arr[j-1]; j--; &#125; arr[j] = tmp; &#125; //console.timeEnd('InsertionSort'); return arr;&#125; 插入排序比一般的高级排序算法（快排、堆排）性能要差，但是还是具有以下优点的： 实现起来简单，理解起来不是很复杂。 对于较小的数据集而言比较高效。 相对于其他复杂度为O(n^2)的排序算法（冒泡、选择）而言更加快速。这一点在文章最后的测试中可以看出来。 稳定、及时…… 四、归并排序到目前为止，已经介绍了三种排序方法，包括冒泡排序、选择排序和插入排序。这三种排序方法的时间复杂度都为O(n^2)，其中冒泡排序实现最简单，性能最差，选择排序比冒泡排序稍好，但是还不够，插入排序是这三者中表现最好的，对于小数据集而言效率较高。这些原因导致三者的实用性并不高，都是最基本的简单排序方法，多用于教学，很难用于实际中，从这节开始介绍更加高级的排序算法。 归并排序是第一个可以用于实际的排序算法，前面的三个性能都不够好，归并排序的时间复杂度为O(nlogn)，这一点已经由于前面的三个算法了。 值得注意的是，JavaScript中的Array.prototype.sort方法没有规定使用哪种排序算法，允许浏览器自定义，FireFox使用的是归并排序法，而Chrome使用的是快速排序法。 归并排序的核心思想是分治，分治是通过递归地将问题分解成相同或者类型相关的两个或者多个子问题，直到问题简单到足以解决，然后将子问题的解决方案结合起来，解决原始方案的一种思想。 归并排序通过将复杂的数组分解成足够小的数组（只包含一个元素），然后通过合并两个有序数组（单元素数组可认为是有序数组）来达到综合子问题解决方案的目的。所以归并排序的核心在于如何整合两个有序数组，拆分数组只是一个辅助过程。 示例：1234567891011// 假设有以下数组，对其进行归并排序使其按从小到大的顺序排列：var arr = [8,7,6,5];// 对其进行分解，得到两个数组：[8,7]和[6,5]// 然后继续进行分解，分别再得到两个数组，直到数组只包含一个元素：[8]、[7]、[6]、[5]// 开始合并数组，得到以下两个数组：[7,8]和[5,6]// 继续合并，得到[5,6,7,8]// 排序完成 JavaScript实现（从小到大排序）：1234567891011121314151617181920212223242526272829303132333435363738function mergeSort(arr) &#123; //console.time('MergeSort'); //let count = 0; console.log(main(arr)); //console.timeEnd('MergeSort'); //return count; // 主函数。 function main(arr) &#123; // 记得添加判断，防止无穷递归导致callstack溢出，此外也是将数组进行分解的终止条件。 if(arr.length === 1) return arr; // 从中间开始分解，并构造左边数组和右边数组。 let mid = Math.floor(arr.length/2); let left = arr.slice(0, mid); let right = arr.slice(mid); // 开始递归调用。 return merge(arguments.callee(left), arguments.callee(right)); &#125; // 数组的合并函数，left是左边的有序数组，right是右边的有序数组。 function merge(left, right) &#123; // il是左边数组的一个指针，rl是右边数组的一个指针。 let il = 0, rl = 0, result = []; // 同时遍历左右两个数组，直到有一个指针超出范围。 while(il &lt; left.length &amp;&amp; rl &lt; right.length) &#123; //count++; // 左边数组的当前项如果小于右边数组的当前项，那么将左边数组的当前项推入result，反之亦然，同时将推入过的指针右移。 if(left[il] &lt; right[rl]) &#123; result.push(left[il++]); &#125; else &#123; result.push(right[rl++]); &#125; &#125; // 记得要将未读完的数组的多余部分读到result。 return result.concat(left.slice(il)).concat(right.slice(rl)); &#125;&#125; 注意是因为数组被分解成为了只有一个元素的许多子数组，所以merge函数从单个元素的数组开始合并，当合并的数组的元素个数超过1时，即为有序数组，仍然还可以继续使用merge函数进行合并。 归并排序的性能确实达到了应用级别，但是还是有些不足，因为这里的merge函数新建了一个result数组来盛放合并后的数组，导致空间复杂度增加，这里还可以进行优化，使得数组进行原地排序。 五、快速排序快速排序由Tony Hoare在1959年发明，是当前最为常用的排序方案，如果使用得当，其速度比一般算法可以快两到三倍，比之冒泡排序、选择排序等可以说快成千上万倍。快速排序的复杂度为O(nlogn)，其核心思想也是分而治之，它递归地将大数组分解为小数组，直到数组长度为1，不过与归并排序的区别在于其重点在于数组的分解，而归并排序的重点在于数组的合并。 基本思想： 在数组中选取一个参考点（pivot），然后对于数组中的每一项，大于pivot的项都放到数组右边，小于pivot的项都放到左边，左右两边的数组项可以构成两个新的数组（left和right），然后继续分别对left和right进行分解，直到数组长度为1，最后合并（其实没有合并，因为是在原数组的基础上操作的，只是理论上的进行了数组分解）。 基本步骤： （1）首先，选取数组的中间项作为参考点pivot。 （2）创建左右两个指针left和right，left指向数组的第一项，right指向最后一项，然后移动左指针，直到其值不小于pivot，然后移动右指针，直到其值不大于pivot。 （3）如果left仍然不大于right，交换左右指针的值（指针不交换），然后左指针右移，右指针左移，继续循环直到left大于right才结束，返回left指针的值。 （4）根据上一轮分解的结果（left的值），切割数组得到left和right两个数组，然后分别再分解。 （5）重复以上过程，直到数组长度为1才结束分解。 JavaScript实现（从小到大排序）：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152function quickSort(arr) &#123; let left = 0, right = arr.length - 1; //console.time('QuickSort'); main(arr, left, right); //console.timeEnd('QuickSort'); return arr; function main(arr, left, right) &#123; // 递归结束的条件，直到数组只包含一个元素。 if(arr.length === 1) &#123; // 由于是直接修改arr，所以不用返回值。 return; &#125; // 获取left指针，准备下一轮分解。 let index = partition(arr, left, right); if(left &lt; index - 1) &#123; // 继续分解左边数组。 main(arr, left, index - 1); &#125; if(index &lt; right) &#123; // 分解右边数组。 main(arr, index, right); &#125; &#125; // 数组分解函数。 function partition(arr, left, right) &#123; // 选取中间项为参考点。 let pivot = arr[Math.floor((left + right) / 2)]; // 循环直到left &gt; right。 while(left &lt;= right) &#123; // 持续右移左指针直到其值不小于pivot。 while(arr[left] &lt; pivot) &#123; left++; &#125; // 持续左移右指针直到其值不大于pivot。 while(arr[right] &gt; pivot) &#123; right--; &#125; // 此时左指针的值不小于pivot，右指针的值不大于pivot。 // 如果left仍然不大于right。 if(left &lt;= right) &#123; // 交换两者的值，使得不大于pivot的值在其左侧，不小于pivot的值在其右侧。 [arr[left], arr[right]] = [arr[right], arr[left]]; // 左指针右移，右指针左移准备开始下一轮，防止arr[left]和arr[right]都等于pivot然后导致死循环。 left++; right--; &#125; &#125; // 返回左指针作为下一轮分解的依据。 return left; &#125;&#125; 快速排序相对于归并排序而言加强了分解部分的逻辑，消除了数组的合并工作，并且不用分配新的内存来存放数组合并结果，所以性能更加优秀，是目前最常用的排序方案。 之前还在知乎上看到过一个回答，代码大致如下（从小到大排序）：12345678910function quickSort(arr) &#123; // 当数组长度不大于1时，返回结果，防止callstack溢出。 if(arr.length &lt;= 1) return arr; return [ // 递归调用quickSort，通过Array.prototype.filter方法过滤小于arr[0]的值，注意去掉了arr[0]以防止出现死循环。 ...quickSort(arr.slice(1).filter(item =&gt; item &lt; arr[0])), arr[0], ...quickSort(arr.slice(1).filter(item =&gt; item &gt;= arr[0])) ];&#125; 以上代码有利于对快排思想的理解，但是实际运用效果不太好，不如之前的代码速度快。 六、堆排序如果说快速排序是应用性最强的排序算法，那么我觉得堆排序是趣味性最强的排序方法，非常有意思。 堆排序也是一种很高效的排序方法，因为它把数组作为二叉树排序而得名，可以认为是归并排序的改良方案，它是一种原地排序方法，但是不够稳定，其时间复杂度为O(nlogn)。 实现步骤： （1）由数组构造一个堆结构，该结构满足父节点总是大于（或小于）其子节点。 （2）从堆结构的最右边的叶子节点开始，从右至左、从下至上依次与根节点进行交换，每次交换后，都要再次构建堆结构。值得注意的是每次构建堆结构时，都要忽略已经交换过的非根节点。 数组构建的堆结构： // 数组 var arr = [1,2,3,4,5,6,7]; // 堆结构 1 / \\ 2 3 / \\ / \\ 4 5 6 7 可以发现对于数组下标为i的数组项，其左子节点的值为下标2*i + 1对应的数组项，右子节点的值为下标2*i + 2对应的数组项。 实际上并没有在内存中开辟一块空间构建堆结构来存储数组数据，只是在逻辑上把数组当做二叉树来对待，构建堆结构指的是使其任意父节点的子节点都不大于（不小于）父节点。 JavaScript实现（从小到大排序）：123456789101112131415161718192021222324252627282930313233343536373839404142434445function heapSort(arr) &#123; //console.time('HeapSort'); buildHeap(arr); for(let i=arr.length-1; i&gt;0; i--) &#123; // 从最右侧的叶子节点开始，依次与根节点的值交换。 [arr[i], arr[0]] = [arr[0], arr[i]]; // 每次交换之后都要重新构建堆结构，记得传入i限制范围，防止已经交换的值仍然被重新构建。 heapify(arr, i, 0); &#125; //console.timeEnd('HeapSort'); return arr; function buildHeap(arr) &#123; // 可以观察到中间下标对应最右边叶子节点的父节点。 let mid = Math.floor(arr.length / 2); for(let i=mid; i&gt;=0; i--) &#123; // 将整个数组构建成堆结构以便初始化。 heapify(arr, arr.length, i); &#125; return arr; &#125; // 从i节点开始下标在heapSize内进行堆结构构建的函数。 function heapify(arr, heapSize, i) &#123; // 左子节点下标。 let left = 2 * i + 1, // 右子节点下标。 right = 2 * i + 2, // 假设当前父节点满足要求（比子节点都大）。 largest = i; // 如果左子节点在heapSize内，并且值大于其父节点，那么left赋给largest。 if(left &lt; heapSize &amp;&amp; arr[left] &gt; arr[largest]) &#123; largest = left; &#125; // 如果右子节点在heapSize内，并且值大于其父节点，那么right赋给largest。 if(right &lt; heapSize &amp;&amp; arr[right] &gt; arr[largest]) &#123; largest = right; &#125; if(largest !== i) &#123; // 如果largest被修改了，那么交换两者的值使得构造成一个合格的堆结构。 [arr[largest], arr[i]] = [arr[i], arr[largest]]; // 递归调用自身，将节点i所有的子节点都构建成堆结构。 arguments.callee(arr, heapSize, largest); &#125; return arr; &#125;&#125; 堆排序的性能稍逊于快速排序，但是真的很有意思。 七、性能对比通过console.time()和console.timeEnd()查看排序所用时间，通过generateArray()产生大规模的数据，最终得到如下结论： 通过对冒泡排序的测试，得到以下数据： BubbleSort: 406.567ms 给10000（一万）条数据进行排序，耗时406毫秒。 BubbleSort: 1665.196ms 给20000（两万）条数据进行排序，耗时1.6s。 BubbleSort: 18946.897ms 给50000（五万）条数据进行排序，耗时19s。由于机器不太好，当数据量达到100000时基本就非常漫长了，具体多久也没等过，这已经可以看出来性能非常不好了。 通过对选择排序的测试，得到以下数据： SelectionSort: 1917.083ms 对20000（两万）条数据进行排序，耗时1.9s。 SelectionSort: 12233.060ms 给50000（五万）条数据进行排序时，耗时12.2s，可以看出相对于冒泡排序而言已经有了进步，但是远远不够。还可以看出随着数据量的增长，排序的时间消耗越来越大。 通过对插入排序的测试，得到以下数据： InsertionSort: 273.891ms 对20000（两万）条数据进行排序，耗时0.27s。 InsertionSort: 1500.631ms 对50000（五万）条数据进行排序，耗时1.5s。 InsertionSort: 7467.029ms 对100000（十万）条数据进行排序，耗时7.5秒，对比选择排序，又有了很大的改善，但是仍然不够。 通过对归并排序的测试，得到以下数据： MergeSort: 287.361ms 对100000（十万）条数据进行排序，耗时0.3秒，真的很优秀了hhh， MergeSort: 2354.007ms 对1000000（一百万）条数据进行排序，耗时2.4s，绝对的优秀，难怪FireFox会使用这个来定义Array.prototype.sort方法， MergeSort: 26220.459ms 对10000000（一千万）条数据进行排序，耗时26s，还不错。接下来看快排。 通过对快速排序的测试，得到以下数据： QuickSort: 51.446ms 100000（十万）条数据排序耗时0.05s，达到了可以忽略的境界， QuickSort: 463.528ms 1000000（一百万）条数据排序耗时0.46s，也基本可以忽略，太优秀了， QuickSort: 5181.508ms 10000000（一千万）条数据排序耗时5.2s，完全可以接受。 通过对堆排序的测试，得到以下数据： HeapSort: 3124.188ms 对1000000（一百万）条数据进行排序，耗时3.1s，逊色于快速排序和归并排序，但是对比其他的排序方法还是不错的啦。 HeapSort: 41746.788ms 对10000000（一千万）条数据进行排序，耗时41.7s，不太能接受。 八、结论以前都认为排序方法随便用用无可厚非，现在想想确实挺naive的hhh，想到了以前实习的时候，SQL Server几百万数据几秒钟就排序完成了，这要是用冒泡排序还不得等到两眼发黑？通过这次学习总结排序算法，尤其是对于每种方法性能的测试，我深刻地认识到了算法设计的重要性，只有重视算法的设计、复杂度的对比，才能写出优秀的算法，基于优秀的算法才能写出性能出色的应用！ 此外，由于对于算法复杂度的研究不够深入，理解只停留在表面，所以文中如果存在有错误，恳请大牛不吝赐教！ 最后，我想说一声，支持阮老师！ 九、参考文章 Bubble sort Selection sort Insertion sort Merge sort Quicksort Heapsort 排序算法 算法复杂度分析 学习javascript数据结构与算法(第二版)","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://zhongdeming.fun/categories/JavaScript/"},{"name":"Algorithm","slug":"JavaScript/Algorithm","permalink":"http://zhongdeming.fun/categories/JavaScript/Algorithm/"}],"tags":[]},{"title":"[译] 怎样（以及为什么要）保持你的 Git 提交记录的整洁","slug":"译-怎样（以及为什么要）保持你的-Git-提交记录的整洁","date":"2018-11-02T13:28:45.000Z","updated":"2021-05-07T21:21:43.640Z","comments":true,"path":"2018/11/02/译-怎样（以及为什么要）保持你的-Git-提交记录的整洁/","link":"","permalink":"http://zhongdeming.fun/2018/11/02/译-怎样（以及为什么要）保持你的-Git-提交记录的整洁/","excerpt":"","text":"最近在掘金翻译了一篇文章，主要讲的是 Git 提交记录的维护，确实很有用，感兴趣的同学可以去看一下。链接如下： [译] 怎样（以及为什么要）保持你的 Git 提交记录的整洁 截图：","categories":[{"name":"Git","slug":"Git","permalink":"http://zhongdeming.fun/categories/Git/"},{"name":"译文","slug":"Git/译文","permalink":"http://zhongdeming.fun/categories/Git/译文/"}],"tags":[]},{"title":"Vim 基本命令入门","slug":"Vim-基本命令入门","date":"2018-11-02T13:27:36.000Z","updated":"2021-05-07T21:21:43.640Z","comments":true,"path":"2018/11/02/Vim-基本命令入门/","link":"","permalink":"http://zhongdeming.fun/2018/11/02/Vim-基本命令入门/","excerpt":"最近在学习 Linux，前面的基础知识学习了一下，进入了 Vim 的学习环节。感觉这个编辑器还是可以的，有特色，鼠标都不用，蛮炫酷。对于基本的使用来讲还是很方便的。下面是一些我的学习笔记，大致就是一些常用的命令吧。这个博客就是使用 Vim 写的一个 Markdown 文档，就当是给自己练练手，加深学习的印象了。","text":"最近在学习 Linux，前面的基础知识学习了一下，进入了 Vim 的学习环节。感觉这个编辑器还是可以的，有特色，鼠标都不用，蛮炫酷。对于基本的使用来讲还是很方便的。下面是一些我的学习笔记，大致就是一些常用的命令吧。这个博客就是使用 Vim 写的一个 Markdown 文档，就当是给自己练练手，加深学习的印象了。 Vim 基本概念Vim 是从 vi 发展而来的一个功能强大、高度可定制的文本编辑器，是一款开源的软件。Vim 的基本功能模式如下图： 由图可知，Vim 基本包括三种工作模式：命令模式、插入模式和编辑模式。在终端中通过 vi 命令即可使用 Vim 打开对应文件，从而进入命令模式，此时输入的任何文本信息都会被当做命令，回车即可执行输入的这些命令。要想编辑文本信息，需要进入编辑模式，此时输入命令 a、o、i都可以进入插入模式。其中，a 代表在当前光标位置的后方插入，o 代表在当前光标的下面一行插入，i 代表在当前光标位置的前面插入。此外，A、O、I也可以进入插入模式，但是它们意义与其小写模式正好相反。A 代表在行尾插入，O 代表在当前光标位置的上面一行插入，I 代表在行首开始插入。进入插入模式之后，按“ESC”键即可退出插入模式，回到命令模式。 常用命令插入命令 命令 含义 a 在光标当前所在位置的后面开始插入 A 在光标所在行行尾开始插入 i 在光标当前所在位置的前面开始插入 I 在光标所在行行首开始插入 o 在光标所在行的下一行开始插入 O 在光标所在行的上一行开始插入 定位命令 命令 含义 :set nu 设置行号 :set nonu 取消行号 gg 跳转到第一行 G 跳转到最后一行 nG 跳转到第n行 :n 跳转到第n行 $ 跳转到行尾 0 跳转到行首 其中，值得注意的是，命令 :n 与命令 nG 具有同样的功能，从字面上看，:n 更容易记住，所以我一般使用 :n命令。具体使用方法：1:100 在命令模式下，输入上方的命令，回车就回跳转到第一百行。 这些常用的跳转命令最好记住。 删除命令 命令 含义 x 将光标所在处的字符进行剪切（删除） nx 将光标之后的n的字符进行剪切（删除） dd 将光标所在行进行剪切（删除） ndd 将光标所在行之后的n行进行剪切（删除） dG 将光标所在行到文章末尾进行剪切（删除） D 将光标所在处到行尾进行剪切（删除） :n1,n2d 将n1到n2行内容进行剪切（删除） 常用的是 x、nx、dd 和 ndd。 复制和粘贴 命令 含义 yy 复制当前行 nyy 复制当前行以下的n行 dd 剪切当前行 ndd 剪切当前行之后的n行 p 粘贴在当前光标所在行下 P 粘贴在当前光标所在行上 替换和撤销命令 命令 含义 r 取代光标所在处的字符 R 进入替换模式，类似于 Windows 中的 insert u 撤销上一次操作 注意点： r 只替换当前光标所在处的字符，命令模式下按 r 然后按新的字符。 R 进入替换模式，按 ESC 才能退出。 搜索和搜索替换命令 命令 含义 /string 搜索指定字符串，如果要忽略大小写，先输入命令 :set ic n 搜索指定字符串的下一个位置 :%s/old/new/g 全文替换指定字符串 :n1,n2s/old/new/g 在指定范围内替换指定字符串 注意点： %s代表全文搜索。 n1,n2s代表在n1行到n2行范围内搜索。 g代表不会确认是否替换，如果最后是c的话，就回挨个询问是否替换。 保存和退出命令 命令 含义 :w 保存修改 :w new_filename 另存为指定文件 :wq 保存修改并退出 ZZ 保存修改并退出的快捷键 :q! 不保存修改强制退出 :wq! 保存修改并强制退出 其它使用技巧 命令 含义 :r 文件名 将指定文件的内容导入到光标所在位置 :r !命令 将命令运行结果导入到光标所在位置 :map 快捷键 触发命令 自定义快捷键 :ab old new 在编辑时自动替换一些字符 注意点： :r !命令 是一个很好用的命令，比如:r !date可以把当前日期时间快速导入到当前光标位置。 :map 快捷键 触发命令用于自定义快捷键，在命令模式下，输入“:map ”然后输入“Ctrl+V+P”，会出现“^P”，代表快捷键为“Ctrl+P”。最后一部分触发命令是指按下快捷键后，触发的命令，比如“I#”，这代表快捷方式触发的命令为“I#”，然后按下“ESC”键。含义即为在行首添加“#”井号，快速注释。 连续行注释：n1,n2s/^/#/g，代表将指定范围内的行首替换为“#”井号。其中，“^”代表行首。 :ab是编辑时快速替换命令，当你自定义替换字符串后，当你在编辑模式下输入要替换的字符串时，空格或者回车后，这个就字符串就回立即被你定义的新字符串替换掉，很方便。 小问题记录 习惯了Ctrl+S保存修改，在 Vim 中也喜欢按，结果按了之后就出问题了，无法输入了。解决方法就是按Ctrl+Q，退出锁屏模式。 编辑模式下按Ctrl+Z不是撤销更改，撤销更改应该进入命令模式，按u。编辑模式下按Ctrl+Z是强制将进程加入后台运行，会生成一个“.swap”交换文件。要正常编辑，可以手动删除交换文件，由于交互文件是隐藏文件，所以需要按ls -a查看。 总结以上只是一些基本的 Vim 命令，学会使用这些命令还是能够大大地增强学习乐趣。另外要想学好 Vim，最好每个命令都自己试一试，亲身体验过后，还是觉得它非常方便的。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://zhongdeming.fun/categories/Linux/"},{"name":"Vim","slug":"Linux/Vim","permalink":"http://zhongdeming.fun/categories/Linux/Vim/"}],"tags":[]},{"title":"前端工程师使用 Deepin 笔记","slug":"前端工程师使用-Deepin-笔记","date":"2018-11-02T13:25:42.000Z","updated":"2021-05-07T21:21:43.640Z","comments":true,"path":"2018/11/02/前端工程师使用-Deepin-笔记/","link":"","permalink":"http://zhongdeming.fun/2018/11/02/前端工程师使用-Deepin-笔记/","excerpt":"笔者是一枚前端开发，在学习 Linux 的时候碰到了一个问题 —— 怎么练手？因为自己电脑上面装的是 Windows 系统，所以学习 Linux 的时候没办法进行练习，而敲指令是学习 Linux 最高效的途径，这就需要我装一个 Linux 虚拟机或者双系统了。最开始的时候我用 VMWare 的虚拟机装了个 Ubuntu，后来觉得 Linux 好像确实好用，虚拟机又太耗资源，再加上我的 Windows 越来越卡顿，我决定装一个双系统。","text":"笔者是一枚前端开发，在学习 Linux 的时候碰到了一个问题 —— 怎么练手？因为自己电脑上面装的是 Windows 系统，所以学习 Linux 的时候没办法进行练习，而敲指令是学习 Linux 最高效的途径，这就需要我装一个 Linux 虚拟机或者双系统了。最开始的时候我用 VMWare 的虚拟机装了个 Ubuntu，后来觉得 Linux 好像确实好用，虚拟机又太耗资源，再加上我的 Windows 越来越卡顿，我决定装一个双系统。一开始的时候，我还是安装的 Ubuntu 系统，后来发现真的用 Ubuntu 系统进行工作学习的话，好像还是有很多的困难的，首先是 QQ 官方停止了对 Linux 平台的开发支持，在 Ubuntu 上面很难装 QQ；其次，Ubuntu 的字体什么的对于中文支持都还不够完善；再者，网易云音乐在 Ubuntu 上的表现也不是很好（启动都需要使用 sudo netease-cloud-music 命令来实现，不然点击图标都没得反应）。总之，Ubuntu 对于中国用户的日常使用而言，不太合适（当然人家可能压根就不是为了日常使用而开发的，更不是为了中国人开发的）。为了更好的学习 Linux，在经过了解之后，我决定安装 Deepin 作为我的日常使用系统。这是由武汉深之度科技公司开发的针对中国用户量身定制的 Linux 系统，预装搜狗输入法、QQ、网易云音乐等常用软件，应用商店也是应有尽有（甚至还有 Steam……虽然我没用过，详情见下图），用起来十分舒服。 一、怎么安装 Deepin？好了，讲了这么多，那我们到底该怎么安装 Deepin 双系统呢？ 以 Windows7 为例，大概包括以下几个步骤： （1）磁盘管理，划分出一个大概 60G 的磁盘空间，不需要分配盘符。至于怎么划分磁盘，参考教程。 （2）在 Deepin 官网下载 iso 镜像 以及启动盘制作工具。 （3）将启动盘插入，重启电脑，进入 BIOS，选择从启动盘启动。 （4）按照指引完成安装，记得选择安装在之前划分出来的磁盘，可以选择安装之前将其格式化。 （5）安装完成，Enjoy it！ 这篇文章在 Deepin 系统中完成，所以没办法重温安装过程，只能讲一个安装的大概了。如果需要了解详细，可以参考 Deepin 的官方安装教程，其中还包含视频演示。 二、安装之后要做的事情1. 修改启动项安装系统完成之后，对计算机进行重启，开机时会进入引导界面。进入引导界面之后，可以看到前三个都是 Deepin 的选项，第四个叫做 system setup。选中这一项时，系统会报错，因为这一项是为启动 Windows 做准备的；可能由于 Deepin 的 Bug 问题，一开始是没有 Windows选项的，需要我们进入 Deepin 操作系统之后，在控制中心进行修改。 说是修改，其实也不用做什么。进入 Deepin 之后，点击“控制中心”，右侧边栏会弹出设置界面。然后选择“系统信息”，拉倒最底下可以看到“启动菜单”。随便动一动就好了，比如把一个开关打开然后关掉……这样就行了。再次重启时就可以发现引导界面的最后一项可以正确的显示 Windows 了。 2. 搭建开发环境作为前端开发，我最基本的开发环境包括 VS Code、Git、Node、Python、Vim 等等。现在先安装这几个软件。 安装 Git 和 Vim 比较简单，使用 123456789 $ sudo apt-get install git vim``` 就阔以了。安装 VS Code 有两种方法，一种是在深度商店安装，一种是在 VS Code 官网下载 .deb 包，然后使用 ```bash $ sudo dpkg -i 包名 安装就可以了。两者的区别是官网下载的是最新版，深度商店的版本要落后于官网的版本。 安装 Node 也有两种方式。一种是通过包管理器安装、一种是官网源码安装。两者的区别是包管理器安装之后包名叫做 nodejs 而非 node，运行脚本时也是 nodejs 命令，很不习惯，如果要修改包名还需要使用其它命令更改。 我使用的是源码安装方式。首先在 Node.js 中文网 下载源代码。下载之后使用 1$ tar -zxf node-vxx.x.x.tar.gz 解压源码，然后使用 1$ sudo apt-get install g++ 安装 gcc 源码编译器。 接下来进入解压后的源码文件夹： 1$ cd node-vxx.x.x 运行配置文件： 1$ ./configure 然后开始编译： 1$ make 编译后开始安装： 1$ make install 安装完成之后就可以通过 node -v 查看所安装的 Node 版本是否正确了。 Python 的话，Deepin 本身就安装了 Python，而且 2 和 3 两个版本都有。如果要使用 Python 3.x 运行脚本，需要使用 python3 命令。切记不要卸载系统本身自带的 2 版本的 Python！另外如果要在 VS Code 中调试 Python 代码，配置文件的写法请参考我的另一篇博客。 另外推荐一个清理垃圾的软件，叫做 BleachBit，可以在深度商店直接安装，截图如下：","categories":[{"name":"Linux","slug":"Linux","permalink":"http://zhongdeming.fun/categories/Linux/"}],"tags":[]},{"title":"在 Deepin 中搭建 GitLab","slug":"在-Deepin-中搭建-GitLab","date":"2018-11-02T13:23:02.000Z","updated":"2021-05-07T21:21:43.640Z","comments":true,"path":"2018/11/02/在-Deepin-中搭建-GitLab/","link":"","permalink":"http://zhongdeming.fun/2018/11/02/在-Deepin-中搭建-GitLab/","excerpt":"入职半个月了，一直在接受业务知识以及企业文化知识的培训，下周终于要开始上岗入手项目了。由于公司使用自己搭建的 GitLab 服务作为项目版本控制器，所以我决定学习一下 GitLab，由于这货跟 GitHub 都是基于 Git，所以代码管理方面没有啥区别，主要学习的是 GitLab 服务的搭建。 一、安装步骤输入一下命令更新源，然后安装依赖 openssh-server 和 ca-certificates。12$ sudo apt-get update$ sudo apt-get install -y openssh-server ca-certificates 如果需要邮箱提醒服务，还需要安装 postfix，当然你也可以安装其他邮件服务。","text":"入职半个月了，一直在接受业务知识以及企业文化知识的培训，下周终于要开始上岗入手项目了。由于公司使用自己搭建的 GitLab 服务作为项目版本控制器，所以我决定学习一下 GitLab，由于这货跟 GitHub 都是基于 Git，所以代码管理方面没有啥区别，主要学习的是 GitLab 服务的搭建。 一、安装步骤输入一下命令更新源，然后安装依赖 openssh-server 和 ca-certificates。12$ sudo apt-get update$ sudo apt-get install -y openssh-server ca-certificates 如果需要邮箱提醒服务，还需要安装 postfix，当然你也可以安装其他邮件服务。安装方法：1$ sudo apt-get install -y postfix 如果没有配置过 postfix，那么安装过程中会跳出来配置选项。依次选择“Internet Site” =&gt; “确定” =&gt; 填入服务器域名 =&gt; “确定”。 安装 GitLab 包。 官网教程上面写的是使用 curl 下载一个 Shell 脚本，然后通过这个脚本安装 GitLab，但是实际上访问的时候，会提示 404 不存在的错误，所以此路不通。实际上访问 GitLab 官网的下载页面的时候，也是 404 不存在，不知道为什么官方人员还没有发现这个问题。 这里我使用的是手动安装，先去 GitLab 的 GitLab 仓库下载 deb 包（因为 Deepin 属于 Debian 系），然后通过 dpkg 命令进行安装。 这里最好选择社区版（gitlab-ce）。 下载之后可以有两种方法进行安装： 1.命令行安装 1$ sudo dpkg -i gitlab-ce_xx.x.x-ce.x_amd64.deb 效果如图： 2.右键 deb 包，然后在”打开方式“中选择“深度软件包管理器”就可以了，然后就可以开始安装。 安装之后开始配置 GitLab，使用 gedit 或者 vim 打开 /etc/gitlab/gitlab.rb。然后修改 external_url 的值为你的本机ip，比如“127.0.0.1”。 然后重新配置 GitLab：1$ sudo gitlab-ctl reconfigure 配置完成后通过下面命令查看 GitLab 的服务状况：1$ sudo gitlab-ctl status 如果结果如下，则代表开启成功： ok: run: alertmanager: (pid 9288) 1s ok: run: gitaly: (pid 9297) 0s ok: run: gitlab-monitor: (pid 9311) 0s ok: run: gitlab-workhorse: (pid 9314) 1s ok: run: logrotate: (pid 9331) 0s ok: run: nginx: (pid 9337) 0s ok: run: node-exporter: (pid 9347) 0s ok: run: postgres-exporter: (pid 9349) 1s ok: run: postgresql: (pid 9362) 0s ok: run: prometheus: (pid 9364) 0s ok: run: redis: (pid 9403) 0s ok: run: redis-exporter: (pid 9444) 0s ok: run: sidekiq: (pid 9460) 0s ok: run: unicorn: (pid 9467) 1s 如果结果如下，则代表开启失败，还需要做处理（后文会讲到）： fail: alertmanager: runsv not running fail: gitaly: runsv not running fail: gitlab-monitor: runsv not running fail: gitlab-workhorse: runsv not running fail: logrotate: runsv not running fail: nginx: runsv not running fail: node-exporter: runsv not running fail: postgres-exporter: runsv not running fail: postgresql: runsv not running fail: prometheus: runsv not running fail: redis: runsv not running fail: redis-exporter: runsv not running fail: sidekiq: runsv not running fail: unicorn: runsv not running 如果成功开启了 GitLab 服务，接下来就可以打开你的浏览器，输入“127.0.0.1”或者你在局域网中的 ip 进入 GitLab 的服务界面了。局域网内的其它机器也可以通过你的局域网 IP 访问你机器上的 GitLab 服务，这样就形成了一个私有的 Git 版本管理。 成功后的服务界面： 二、常见问题（1）服务开启失败错误结果显示如下： fail: alertmanager: runsv not running fail: gitaly: runsv not running fail: gitlab-monitor: runsv not running fail: gitlab-workhorse: runsv not running fail: logrotate: runsv not running fail: nginx: runsv not running fail: node-exporter: runsv not running fail: postgres-exporter: runsv not running fail: postgresql: runsv not running fail: prometheus: runsv not running fail: redis: runsv not running fail: redis-exporter: runsv not running fail: sidekiq: runsv not running fail: unicorn: runsv not running 这说明 runsv 服务未开启，通过一下命令开启即可：12345$ systemctl start gitlab-runsvdir.service$ systemctl status gitlab-runsvdir.service$ sudo gitlab-ctl start （２）打开页面时显示 502 错误界面提示“Whoops, GitLab is taking too much time to respond.”，这说明 GitLab 此时占用了过多的内存资源。你需要对服务器进行扩容，或者清理掉一些不需要的且占内存的服务。 （３）GitLab 占用内存过高这个问题基本没有啥办法，只能是扩展内存了，因为开启服务确确实实需要占据大量内存。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://zhongdeming.fun/categories/Linux/"},{"name":"Git","slug":"Linux/Git","permalink":"http://zhongdeming.fun/categories/Linux/Git/"}],"tags":[]},{"title":"浅谈 JavaScript 中的继承模式","slug":"浅谈-JavaScript-中的继承模式","date":"2018-11-02T13:20:28.000Z","updated":"2021-05-07T21:21:43.640Z","comments":true,"path":"2018/11/02/浅谈-JavaScript-中的继承模式/","link":"","permalink":"http://zhongdeming.fun/2018/11/02/浅谈-JavaScript-中的继承模式/","excerpt":"最近在读一本设计模式的书，书中的开头部分就讲了一下 JavaScript 中的继承，阅读之后写下了这篇博客作为笔记。毕竟好记性不如烂笔头。 JavaScript 是一门面向对象的语言，但是 ES6 之前 JavaScript 是没有类这个概念的。即使 ES6 引入了 class，也只是基于 JavaScript 已有的原型继承模式的一个语法糖，并没有为 JavaScript 引入新的面向对象的继承模型。 但是 JavaScript 是一门非常灵活的语言，为了实现类和继承，JavaScript Developers 已经把原型玩出了花，下面介绍一下 JavaScript 中的继承模式。 JavaScript 中已有的继承模式包括以下六种： 类式继承 构造函数式继承 组合式继承 原型式继承 寄生式继承 寄生组合式继承","text":"最近在读一本设计模式的书，书中的开头部分就讲了一下 JavaScript 中的继承，阅读之后写下了这篇博客作为笔记。毕竟好记性不如烂笔头。 JavaScript 是一门面向对象的语言，但是 ES6 之前 JavaScript 是没有类这个概念的。即使 ES6 引入了 class，也只是基于 JavaScript 已有的原型继承模式的一个语法糖，并没有为 JavaScript 引入新的面向对象的继承模型。 但是 JavaScript 是一门非常灵活的语言，为了实现类和继承，JavaScript Developers 已经把原型玩出了花，下面介绍一下 JavaScript 中的继承模式。 JavaScript 中已有的继承模式包括以下六种： 类式继承 构造函数式继承 组合式继承 原型式继承 寄生式继承 寄生组合式继承 一、类式继承 JavaScript 中，每个对象都有一个原型（prototype），在对象本身找不到对应属性的时候，JavaScript 就会去对象的原型上找，所以这就为 JavaScript 实现继承提供了一种方法 —— 我们只需要把父类的属性放在子类的原型上就行了。因为子类中没有对应属性的话，就会使用原型上的属性，即父类的属性，这就达到了继承的目的。1234567891011121314151617// 父类function Person() &#123; this.name = 'Kevin'; this.age = 18;&#125;// 子类function Chinese() &#123; this.feature = 'hard-working';&#125;// 指定子类的原型，实现子类继承父类。Chinese.prototype = new Person();// 实例化子类。var c = new Chinese();// 输出'hard-working'。console.log(c.feature);// 输出'Kevin'。console.log(c.name); 这是一种比较简单直观的继承实现方法，但是存在着问题。所有的子类实例共享了父类实例的属性。如果父类实例的属性是引用类型的值时，将会出现牵一发而动全身的风险。 比如，我们给父类 Person 添加一个 category 的数组属性：12345678910111213141516171819202122// 父类function Person() &#123; this.name = 'Kevin'; this.age = 18; this.category = ['yellow', 'black', 'white'];&#125;// 子类function Chinese() &#123; this.feature = 'hard-working';&#125;// 指定子类的原型，实现子类继承父类。Chinese.prototype = new Person();// 实例化子类。var c1 = new Chinese();var c2 = new Chinese();// 修改 c1 的 category 属性，世界上还有棕色人种。c1.category.push('brown');// 输出 c1 和 c2 的 category 属性。console.log(c1.category);// 结果是 [\"yellow\", \"black\", \"white\", \"brown\"]console.log(c2.category);// 结果是 [\"yellow\", \"black\", \"white\", \"brown\"] 我们只修改了 c1 的 category 属性，但是 c2.category 也跟着变化了，因为它们共享了一个 Person 实例，而这个 Person 实例的 category 值是引用类型的。 这就是一个很严重的缺陷了，这样的继承模式会使得我们的数据变得不可预测。 二、构造函数式继承类式继承的致命缺陷是共享引用类型的属性导致牵一发而动全身，而问题的根源在于我们给子类的原型赋值为父类的一个实例，那现在解决这个问题就有办法了。我们可以麻烦一点，不把父类的实例赋值给原型了，直接赋值给每一个子类实例吧，这样就不会存在共享引用类型属性的问题了。1234567891011121314151617181920// 父类function Person() &#123; this.name = 'Kevin'; this.age = 18; this.category = ['yellow', 'black', 'white'];&#125;// 子类function Chinese() &#123; Person.call(this); this.feature = 'hard-working';&#125;// 实例化子类。var c1 = new Chinese();var c2 = new Chinese();// 修改 c1 的 category 属性。c1.category.push('brown');// 输出 [\"yellow\", \"black\", \"white\", \"brown\"]console.log(c1.category);// 输出 [\"yellow\", \"black\", \"white\"]console.log(c2.category); 可以看到，共享引用类型属性的问题确实解决了。但是这种方法也不太好，因为我们没有利用好原型。每个属性都实例化在实例的本身，造成了资源的浪费，也不符合代码复用的原则。对于一些共享的公用的方法，我们应该绑定在原型上。 三、组合式继承为了解决第二小节的问题，出现了组合式继承。所谓组合式继承，就是综合类式继承和构造函数式继承，结合二者。 比如：12345678910111213141516// 父类function Person() &#123; this.name = 'Kevin'; this.age = 18; this.category = ['yellow', 'black', 'white'];&#125;// 子类function Chinese() &#123; // 基于构造函数式继承。 Person.call(this); this.feature = 'hard-working';&#125;// 基于类式继承。Chinese.prototype = new Person();console.log(new Person());console.log(new Chinese()); 这样就“充分地”利用了原型。 但是什么东西都往原型塞，也是一种浪费。我们在子类构造函数中调用了父类的构造函数，在指定子类的原型时又调用了一遍，既不优雅又浪费资源，所以这种方法也不怎么样。 四、原型式继承这是 2006 年道格拉斯.克罗克福德的一篇文章所提出来的，我们把要继承的属性放在原型中，然后再在实例上定义属性，这样就使得每个实例可以有自己特有的属性，还可以和其他实例共享必要的属性。123456789function inherit(o) &#123; function F()&#123;&#125; F.prototype = o; return new F();&#125;var x = inherit(&#123;name: 'Kevin'&#125;);x.age = 18;// 输出 &#123;name: 'Kevin', age: 18&#125;console.log(x); 这种方法首先定义了一个空白的构造函数，然后为其指定了将要继承的属性，然后返回它的一个实例，最后给每个实例指定属性。 这样节约了很多的资源，每个返回的实例也很干净纯洁。 五、寄生式继承这是一种基于原型式继承的方法，只多了一个步骤，就是给每个实例添加属性。这看起来像是第五小节代码的一种封装。123456789101112131415161718function inherit(o) &#123; function F()&#123;&#125; F.prototype = o; var f = new F(); f.name = 'Kevin'; f.age = 18; return f;&#125;var proto = &#123; sayName: function() &#123; console.log(this.name); &#125;&#125;;var x = inherit(proto);// &#123;name: \"Kevin\", age: 18&#125;console.log(x);// Kevinx.sayName(); 这种继承方式在 underscore 中曾经使用过，具体哪里我也不记得了，感兴趣的同学可以去看看。 六、寄生组合式继承这是一种综合型的方法，结合了寄生式、组合式继承方法。实际上是寄生式、构造函数式、类式继承的综合体。123456789101112131415161718192021222324252627282930// 基于寄生式继承实现的原型赋值，把子类的原型赋值为父类。function inheritProto(SubClass, SuperClass) &#123; function F() &#123;&#125; F.prototype = SuperClass.prototype; var f = new F(); // 赋值 prototype 会丢失 constructor 指向，重新赋值。 f.constructor = SubClass; SubClass.prototype = f;&#125;// 父类function Person() &#123; this.name = 'Kevin'; this.age = 18;&#125;Person.prototype.sayName = function() &#123; console.log(this.name);&#125;;function Chinese() &#123; // 构造函数式继承。 Person.call(this); this.feature = 'hard-working'; this.name = '李国强';&#125;// 类式继承原型。inheritProto(Chinese, Person);var c = new Chinese();console.log(c);// 输出 &#123;name: \"李国强\", age: 18, feature: \"hard-working\"&#125;c.sayName();// 输出 \"李国强\"。 从注释可以看出来，确实综合了三种继承模式。所以这种方法的名字就叫寄生组合式继承。 笔记一篇，时间很仓促，如果有问题欢迎指正！ 所有代码可以复制到浏览器控制台执行查看输出。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://zhongdeming.fun/categories/JavaScript/"}],"tags":[]},{"title":"基于 Webpack 4 搭建 Vue 开发环境","slug":"基于-Webpack-4-搭建-Vue-开发环境","date":"2018-11-02T12:42:01.000Z","updated":"2021-05-07T21:21:43.640Z","comments":true,"path":"2018/11/02/基于-Webpack-4-搭建-Vue-开发环境/","link":"","permalink":"http://zhongdeming.fun/2018/11/02/基于-Webpack-4-搭建-Vue-开发环境/","excerpt":"自从工作之后，就已经很久没有写过博客了。时间被分割得比较碎，积累了一段时间的学习成果，才写下了这篇博客。 之前有写过 Webpack4 的文章，但是都比较偏入门，唯一的一篇实战篇 —— 基于Webpack搭建React开发环境，也是比较简单的，没有涉及到 CSS 抽取，第三方库打包等功能，这篇文章相对而言比较深入。但由于作者水平有限，难免存在谬误之处，欢迎大家指正。 还有没入门的童鞋可以参考我之前的文章： 浅入浅出webpack 基于Webpack搭建React开发环境 一、初始化项目在命令行中敲入如下命令： 1$ mkdir Webpack-Vue &amp;&amp; cd Webpack-Vue &amp;&amp; npm init -y","text":"自从工作之后，就已经很久没有写过博客了。时间被分割得比较碎，积累了一段时间的学习成果，才写下了这篇博客。 之前有写过 Webpack4 的文章，但是都比较偏入门，唯一的一篇实战篇 —— 基于Webpack搭建React开发环境，也是比较简单的，没有涉及到 CSS 抽取，第三方库打包等功能，这篇文章相对而言比较深入。但由于作者水平有限，难免存在谬误之处，欢迎大家指正。 还有没入门的童鞋可以参考我之前的文章： 浅入浅出webpack 基于Webpack搭建React开发环境 一、初始化项目在命令行中敲入如下命令： 1$ mkdir Webpack-Vue &amp;&amp; cd Webpack-Vue &amp;&amp; npm init -y 然后你就可以在你的当前路径下看到一个叫 Webpack-Vue 的文件夹，里面有一个包含默认信息的 package.json 文件，打开并修改这个文件的一些内容。 然后我们在项目文件夹中创建以下几个文件夹： dist src、src/components build Linux 下可以输入一下命令进行快速创建： $ mkdir src src/components dist build -p 其中，dist 用于存放 Webpack 打包后的项目文件、src 用于存放你的源代码文件、build 用于存放 Webpack 打包相关的配置文件。 在 src 下，创建入口文件 index.js。 Linux 下创建的命令： $ touch ./src/index.js 在根目录下创建 index.html 文件，内容如下： 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Webpack Vue Demo&lt;/title&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html;charset=UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"app\"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 这将用于作为我们应用的模板，打包的 js 文件会在 Webpack 插件的处理下插入到这个文件中。 其他配置性文件根据你自己的喜好来添加了，比如 .gitignore 文件等。 二、安装 Webpack要使用 Webpack，第一步当然是先安装。使用以下命令进行安装： $ npm i webpack webpack-cli -D 然后你就可以看到你的项目文件夹中多了一个 node_modules 文件夹，然后 package.json 文件中多了一个 devDependencies 属性。里面包含了安装的依赖名称和依赖版本，现在暂时还只有 webpack 和 webpack-cli。 三、配置最基本的 Webpack这一节我们将着手配置一个具有最基本打包功能的项目，从 src/index.js 开始对项目进行打包。 为了项目结构更加科学合理，我们把所有的 Webpack 配置相关的文件都存放在了 build 目录中。 进入 build 文件夹，然后创建以下几个文件： webpack.base.conf.js webpack.dev.conf.js webpack.prod.conf.js build.js 在 Linux 中，可以敲入如下命令快速创建： $ cd build/ &amp;&amp; touch webpack.base.conf.js webpack.dev.conf.js webpack.prod.conf.js build.js 其中，webpack.base.conf.js 是最基础的打包配置，是开发环境和生产环境都要用到的配置。webpack.dev.conf.js 就是在开发环境要使用的配置。webpack.prod.conf.js 就是在生产环境要使用的配置了。build.js 是通过 Node 接口进行打包的脚本。 接下来我们在对应的文件中写入最基本的配置信息。 （1） webpack.base.conf.js先写最基本的配置信息： 123456789101112131415161718192021const path = require('path');const HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; entry: &#123; bundle: path.resolve(__dirname, '../src/index.js') &#125;, output: &#123; path: path.resolve(__dirname, '../dist'), filename: '[name].[hash].js' &#125;, module: &#123; rules: [ ] &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template: path.resolve(__dirname, '../index.html') &#125;) ]&#125;; （2） webpack.dev.conf.js同样写入最基本的配置信息： 1234567891011const merge = require('webpack-merge');const path = require('path');const baseConfig = require('./webpack.base.conf');module.exports = merge(baseConfig, &#123; mode: 'development', devtool: 'inline-source-map', devServer: &#123; contentBase: path.resolve(__dirname, '../dist'), open: true &#125;&#125;); （3） webpack.prod.conf.js继续写入最基础的配置： 123456789101112131415161718const merge = require('webpack-merge');const CleanWebpackPlugin = require('clean-webpack-plugin');const path = require('path');const baseConfig = require('./webpack.base.conf');module.exports = merge(baseConfig, &#123; mode: 'production', devtool: 'source-map', module: &#123; rules: [] &#125;, plugins: [ new CleanWebpackPlugin(['dist/'], &#123; root: path.resolve(__dirname, '../'), verbose: true, dry: false &#125;) ]&#125;); 注意到我们上面引用了两个新的依赖，需要先进行安装才能使用： $ npm i webpack-merge clean-webpack-plugin webpack-dev-server html-webpack-plugin -D (4) build.js这个脚本用于构建生产环境，开发环境基于 webpack-dev-server 搭建，不写脚本。 接下来，写入我们的打包脚本，通过 Node 调用 Webpack 进行打包。 123456789101112131415const webpack = require('webpack');const config = require('./webpack.prod.conf');webpack(config, (err, stats) =&gt; &#123; if (err || stats.hasErrors()) &#123; // 在这里处理错误 console.error(err); return; &#125; // 处理完成 console.log(stats.toString(&#123; chunks: false, // 使构建过程更静默无输出 colors: true // 在控制台展示颜色 &#125;));&#125;); 这样做的好处是可以利用 Node 做一些其他的事情，另外当 Webpack 配置文件不在项目文件夹根部时方便调用。 （5） npm scripts配置 npm scripts 能够使我们更方便的使用打包命令。 在 package.json 文件的 scripts 属性中，写入如下两条： &quot;build&quot;: &quot;node build/build.js&quot;, &quot;dev&quot;: &quot;webpack-dev-server --inline --progress --config build/webpack.dev.conf.js&quot; 基本的配置写完了，我们测试一下打包效果，在 src/index.js 中写入如下代码： console.log(&apos;index.js!&apos;); 然后在命令行中输入： $ npm run dev 在自动打开的网页中，我打开控制台，我们可以看到输出了一句“index.js”，符合预期。 然后输入构建命令进行构建： $ npm run build 截图如下： 这就表示打包成功了，但是我们还只完成了最基本的打包功能，Vue 还不能使用，接下来我们将这个项目变得更加强大。 四、引入一些基础的 Loader为了方便开发，我们需要引入一些 Loader，以简化我们的写法以及使我们的代码兼容更多的环境。 这一部分可以根据 Webpack 的文档来写，因为都是一些基本的东西，配置起来也不难。 （1）babel-loader为了使我们的 JavaScript 代码兼容更多环境，我们需要使用 babel-loader。 配置方法： 首先安装 babel-loader、babel-preset-env 和 babel-core。需要注意的是，如果你的 babel-loader 是 7.x 版本的话，你的 babel-core 必须是 6.x 版本；如果你的 babel-loader 是 8.x 版本的话，你的 babel-core 必须是 7.x 版本。如果不这样的话，Webpack 会报错。 安装命令如下： $ npm i babel-loader@7 babel-core babel-preset-env -D 然后在 webpack.base.conf.js 的 module.rules 中新增如下对象： 12345&#123; test: /\\.js$/, use: 'babel-loader', exclude: /node_modules/&#125; 我们还需要添加一个配置文件（.babelrc）在根目录下： 12345678910&#123; \"presets\": [ [\"env\", &#123; \"modules\": false, \"targets\": &#123; \"browsers\": [\"&gt; 1%\", \"last 2 versions\", \"not ie &lt;= 8\"] &#125; &#125;] ]&#125; 这就是 babel-preset-env 的作用，帮助我们配置 babel。我们只需要告诉它我们要兼容的情况（目标运行环境），它就会自动把代码转换为兼容对应环境的代码。 以上代码表示我们要求代码兼容最新两个版本的浏览器，不用兼容 IE 8，另外市场份额超过 1% 的浏览器也必须支持。 只需要告诉 babel-preset-env 你想要兼容的环境，它就会自动转换，是不是很爽？再也不用配置那么多了。 接下来我们试一试，把 src/index.js 中的代码改写为： 1234567const x = 'index.js';const y = (x) =&gt; &#123; console.log(x);&#125;y(x); 然后使用 npm run build 进行打包，打包之后的代码中： 1234567var x = 'index.js';var y = function y(x) &#123; console.log(x);&#125;;y(x); 说明我们的代码已经被成功地转换了。 为了做一个对比，未配置 babel 时，转换结果如下： 1234567const x = 'index.js';const y = (x) =&gt; &#123; console.log(x);&#125;y(x); （2）file-loader这个用于将字体文件、图片文件进行模块化。 首先安装 file-loader： $ npm i file-loader -D 然后在 webpack.base.conf.js 中添加如下配置到 module.rules： 123456789101112&#123; test: /\\.(png|svg|jpg|gif)$/, use: [ 'file-loader' ]&#125;,&#123; test: /\\.(woff|woff2|eot|ttf|otf)$/, use: [ 'file-loader' ]&#125; 当然可以简化配置信息，把两个 test 正则合并到一处。 接下来我们配置 vue-loader。 （3） vue-loader为了使用 Vue 单文件组件，我们需要对 .vue 文件进行处理，使用 vue-loader。 首先安装 vue-loader、css-loader、vue-style-loader 和 vue-template-compiler，后者也是必不可少的，少了会报错。 命令： $ npm i vue-loader css-loader vue-style-loader vue-template-compiler -D 然后我们配置 webpack.base.conf.js，写入以下代码到该文件的 module.rules 属性当中： 12345678&#123; test: /\\.vue$/, loader: 'vue-loader'&#125;,&#123; test: /\\.css$/, use: ['vue-style-loader', 'css-loader']&#125; 只有这一处配置是不行的，根据 vue-loader 官网的说明，我们还需要配置一个插件，然后还需要配置 resolve.alias 别名，不然 Webpack 没法找到 Vue 模块。 配置插件，首先在文件头部引入：1const VueLoaderPlugin = require('vue-loader/lib/plugin'); 然后在 plugins 数组中添加这个插件对象：1new VueLoaderPlugin(), 随后我们还要配置别名，将 resolve.alias 配置为如下对象：1234&#123; 'vue$': 'vue/dist/vue.esm.js', '@': path.resolve(__dirname, '../src'),&#125; 这可以使得 Webpack 很方便的找到 Vue，我们在 JavaScript 文件中引入依赖的时候，也可以方便地使用 @ 来代替 src，省去了写文件路径的麻烦。 我们顺便添加一个 resolve.extensions 属性，方便我们引入依赖或者文件的时候可以省略后缀： extensions: [&apos;*&apos;, &apos;.js&apos;, &apos;.json&apos;, &apos;.vue&apos;], extensions 属性是一个数组。这样配置之后，我们在 JavaScript 文件中 import JavaScript 文件、json 文件和 Vue 单文件组件都可以省略后缀。 以上几步都很重要，最好不要省略。 接下来我们验证一下 Vue 单文件组件是否可用。 安装 Vue： $ npm i vue --save 然后修改 index.js 文件内容如下：12345678import Vue from 'vue';import App from './App';new Vue(&#123; el: '#app', template: '&lt;App/&gt;', components: &#123; App &#125;&#125;); 然后在同级目录下创建一个 App.vue 文件，内容如下：123456789101112131415161718&lt;template&gt; &lt;h1&gt;Hello World!&lt;/h1&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: 'App' &#125;&lt;/script&gt;&lt;style&gt; html, body &#123; padding: 0; margin: 0; box-sizing: border-box; font-size: 16px; &#125;&lt;/style&gt; 运行命令 npm run dev 就可以看到一个大大的一级标题 —— Hello World 啦！ 到这里，我们的项目已经可以使用 Vue 单文件组件进行开发了，但是还没有完，我们还有一些任务要做。 五、优化 CSS 代码这里我们使用 postcss 的 autoprefixer 插件为我们的 css 代码自动添加前缀以适应不同的浏览器。 首先安装依赖： $ npm i postcss-loader autoprefixer -D 然后修改 module.rules 中的 css 配置项，修改之后如下:1234&#123; test: /\\.css$/, use: ['vue-style-loader', 'css-loader', 'postcss-loader']&#125; 然后在我们项目的根目录下新增配置文件 postcss.config.js，内容如下：12345module.exports = &#123; plugins: [ require('autoprefixer') ]&#125; 代表我们将要使用 autoprefixer 插件。 之后我们就可以愉快地写代码了，可以自己验证一下是否自动添加了前缀，这里不再赘述。 六、开启热更新Webpack 4 开启热更新相对容易，具体步骤如下： 修改 webpack.dev.conf.js，在 devServer 属性中设置 hot 的值为 true，这就代表开启了热更新。但是只这样做还不够，需要我们添加一个插件，继续修改 webpack.dev.conf.js。 设置其 plugins 属性如下：12345const webpack = require('webpack');// 在文件头部引入 webpack 依赖[ new webpack.HotModuleReplacementPlugin()] 这就开启了 css 热更新（因为 vue-style-loader 封装了 style-loader，热更新开箱即用）,但是 JavaScript 热更新还不能用，每次修改代码我们都会刷新浏览器，所以我们需要继续配置。 为了使得 JavaScript 模块也能进行 HMR，我们需要在我们的 入口文件（index.js） 的底部添加如下代码：123if (module.hot) &#123; module.hot.accept();&#125; 接下来就可以进行 HMR 了。 七、第三方库单独打包每次我们对项目进行打包时，我们都会把引用的第三方依赖给打包一遍，比如 Vue、Vue-Router、React 等等。但是这些库的代码基本都是不会变动的，我们没必要每次打包都构建一次，所以我们最好将这些第三方库提取出来单独打包，这样有利于减少打包时间。 官方插件是 DllPlugin，但是这个插件配置比较繁琐。网上有人推荐一个比较好用的插件 —— autodll-webpack-plugin，确实很好用。 下面是它的配置方法： 首先安装： $ npm i autodll-webpack-plugin -D 然后在 webpack.base.conf.js 中引入：1const AutoDllPlugin = require('autodll-webpack-plugin'); 然后在 plugins 属性中添加这个插件：123456789new AutoDllPlugin(&#123; inject: true, // will inject the DLL bundle to index.html debug: true, filename: '[name]_[hash].js', path: './dll', entry: &#123; vendor: ['vue', 'vue-router', 'vuex'] &#125;&#125;) inject 为 true，插件会自动把打包出来的第三方库文件插入到 HTML。filename 是打包后文件的名称。path 是打包后的路径。entry 是入口，vendor 是你指定的名称，数组内容就是要打包的第三方库的名称，不要写全路径，Webpack 会自动去 node_modules 中找到的。 每次打包，这个插件都会检查注册在 entry 中的第三方库是否发生了变化，如果没有变化，插件就会使用缓存中的打包文件，减少了打包的时间，这时 Hash 也不会变化。 八、提取共同代码：使用 splitChucksPlugin 插件，这是 Webpack 自带的，不用安装第三方依赖。 使用方法： 在 webpack.base.conf.js 的 plugins 属性中添加如下插件对象; new webpack.optimize.SplitChunksPlugin() 这代表你将使用默认的提取配置来提取你的公共代码，如果你不想使用默认配置，请给插件构造函数传入配置对象. 具体怎么配置，请参考冷星大神的博客 —— webpack4——SplitChunksPlugin使用指南，里面关于配置项的作用介绍得很清楚很详细。 九、使用 stylus 预处理器我个人比较喜欢 stylus，因为写起来比较无拘无束，类似 Python，没那么多条条框框，而且用起来也不是很复杂。 引入方法： 首先下载 stylus 和 stylus-loader 依赖： $ npm i stylus stylus-loader -D 然后在配置项 module.rules 中添加一个处理 stylus 文件的配置对象。 配置信息如下：1234&#123; test: /\\.styl(us)$/, use: ['vue-style-loader', 'css-loader', 'postcss-loader', 'stylus-loader']&#125; 接下来只要你在 Vue 单文件组件的 style 标签加上 lang=&#39;stylus&#39;，你就可以使用 stylus 来写 CSS 了。 十、抽取 CSS 到单文件这个功能的配置方法在 Vue Loader 官网交代得很清楚了。 使用的是 mini-css-extract-plugin 插件，首先安装： $ npm i mini-css-extract-plugin -D 然后在配置文件头部引入： const MiniCssExtractPlugin = require(&apos;mini-css-extract-plugin&apos;) 然后当你要抽取 CSS 的时候（比如生产环境打包），你就把原来配置文件中的所有 vue-style-loader 替换为 MiniCssExtractPlugin.loader，其他的什么 css-loader、stylus-loader 等等都不要动。 最后，修改 plugins 选项，插入如下插件：1234new MiniCssExtractPlugin(&#123; filename: \"[name].css\", chunkFilename: \"[id].css\"&#125;) 打包之后，你会发现所有的 CSS 代码都被抽取到了一个单独的 CSS 文件当中。 收获 配置要谨慎，一个错误就可能导致莫名其妙的报错。 学习 Webpack 要多实践，光理论学起来比较抽象。 多查 Webpack 文档，其实很多问题里面都交代清楚了，不要急于到网上找答案。 现成的脚手架是最好的范例，比如 Vue-Cli，create-react-app。多看看它们是怎么配置的，可以学到一些东西。 示例代码放在我的 GitHub 仓库，需要的同学可以自取。 如有错误，敬请指出！","categories":[{"name":"Webpack","slug":"Webpack","permalink":"http://zhongdeming.fun/categories/Webpack/"},{"name":"Vue","slug":"Webpack/Vue","permalink":"http://zhongdeming.fun/categories/Webpack/Vue/"}],"tags":[]},{"title":"Useful CSS Snippets","slug":"Useful-CSS-Snippets","date":"2018-11-02T08:22:03.000Z","updated":"2021-05-07T21:21:43.640Z","comments":true,"path":"2018/11/02/Useful-CSS-Snippets/","link":"","permalink":"http://zhongdeming.fun/2018/11/02/Useful-CSS-Snippets/","excerpt":"看了 30 Seconds CSS，有了许多收获，所以写下了这篇文章，算是收藏一些代码小片段，留作后用。 一、手写 Loading 动画（1）弹性加载动画CSS 代码如下：1234567891011121314151617181920212223242526272829303132.bounce-loading &#123; width: 20rem; height: 10rem; background-color:aqua; display: flex; justify-content: center; align-items: center;&#125;.bounce-loading &gt; div &#123; width: 1rem; height: 1rem; border-radius: 0.5rem; background-color:blueviolet; margin: 0 0.5rem; animation: bounce 1s infinite alternate;&#125;@keyframes bounce &#123; 0% &#123; transform: translateY(0); opacity: 1; &#125; 100% &#123; transform: translateY(2rem); opacity: 0.1; &#125;&#125;.bounce-loading &gt; div:nth-child(2) &#123; animation-delay: 0.2s;&#125;.bounce-loading &gt; div:nth-child(3) &#123; animation-delay: 0.4s;&#125; HTML 代码如下：12345&lt;div class=\"bounce-loading\"&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/div&gt; 效果如下：","text":"看了 30 Seconds CSS，有了许多收获，所以写下了这篇文章，算是收藏一些代码小片段，留作后用。 一、手写 Loading 动画（1）弹性加载动画CSS 代码如下：1234567891011121314151617181920212223242526272829303132.bounce-loading &#123; width: 20rem; height: 10rem; background-color:aqua; display: flex; justify-content: center; align-items: center;&#125;.bounce-loading &gt; div &#123; width: 1rem; height: 1rem; border-radius: 0.5rem; background-color:blueviolet; margin: 0 0.5rem; animation: bounce 1s infinite alternate;&#125;@keyframes bounce &#123; 0% &#123; transform: translateY(0); opacity: 1; &#125; 100% &#123; transform: translateY(2rem); opacity: 0.1; &#125;&#125;.bounce-loading &gt; div:nth-child(2) &#123; animation-delay: 0.2s;&#125;.bounce-loading &gt; div:nth-child(3) &#123; animation-delay: 0.4s;&#125; HTML 代码如下：12345&lt;div class=\"bounce-loading\"&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/div&gt; 效果如下： （2）旋转小圆圈CSS 代码如下：12345678910111213141516.donut-loading &#123; width: 2rem; height: 2rem; border-radius: 2rem; border: 3px solid rgba(0, 0, 0, 0.1); border-left-color: #7983ff; animation: rotate 1s infinite linear;&#125;@keyframes rotate &#123; from &#123; transform: rotate(0deg) &#125; to &#123; transform: rotate(360deg) &#125;&#125; HTML 代码如下：1&lt;div class=\"donut-loading\"&gt;&lt;/div&gt; 效果如下： 二、构建一个宽高比固定的 divCSS 代码如下：1234567891011121314.reactive-height &#123; width: 50%; background-color: aqua;&#125;.reactive-height::before &#123; content: ''; float: left; padding-top: 100%;&#125;.reactive-height::after &#123; content: \"\"; clear: both; display: table;&#125; HTML 代码如下：1&lt;div class=\"reactive-height\"&gt;&lt;/div&gt; 三、自定义滚动条CSS 代码如下： 12345678910111213.custom-scrollbar &#123; width: 40rem; height: 7rem; background-color: aliceblue; overflow-y: scroll;&#125;.custom-scrollbar::-webkit-scrollbar &#123; width: 8px;&#125;.custom-scrollbar::-webkit-scrollbar-thumb &#123; border-radius: 10px; background-color:mediumpurple;&#125; HTML 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738 &lt;div class=\"custom-scrollbar\"&gt; &lt;p&gt; Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Vestibulum tortor quam, feugiat vitae, ultricies eget, tempor sit amet, ante. Donec eu libero sit amet quam egestas semper. Aenean ultricies mi vitae est. Mauris placerat eleifend leo. Quisque sit amet est et sapien ullamcorper pharetra. Vestibulum erat wisi, condimentum sed, commodo vitae, ornare sit amet, wisi. Aenean fermentum, elit eget tincidunt condimentum, eros ipsum rutrum orci, sagittis tempus lacus enim ac dui. Donec non enim in turpis pulvinar facilisis. Ut felis. Praesent dapibus, neque id cursus faucibus, tortor neque egestas augue, eu vulputate magna eros eu erat. Aliquam erat volutpat. Nam dui mi, tincidunt quis, accumsan porttitor, facilisis luctus, metus &lt;/p&gt; &lt;/div&gt;``` 效果截图如下： ![img](https://user-gold-cdn.xitu.io/2018/10/21/1669589eb68aae38?w=991&amp;h=193&amp;f=gif&amp;s=53441)## 四、自定义文本选择时的样式CSS 代码如下：```css .custom-text-selection &#123; width: 50%; &#125; .custom-text-selection::selection &#123; background-color:navy; color: white; &#125; HTML 代码如下： 123456789101112131415161718&lt;p class=\"custom-text-selection\"&gt; Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Vestibulum tortor quam, feugiat vitae, ultricies eget, tempor sit amet, ante. Donec eu libero sit amet quam egestas semper. Aenean ultricies mi vitae est. Mauris placerat eleifend leo. Quisque sit amet est et sapien ullamcorper pharetra. Vestibulum erat wisi, condimentum sed, commodo vitae, ornare sit amet, wisi. Aenean fermentum, elit eget tincidunt condimentum, eros ipsum rutrum orci, sagittis tempus lacus enim ac dui. Donec non enim in turpis pulvinar facilisis. Ut felis. Praesent dapibus, neque id cursus faucibus, tortor neque egestas augue, eu vulputate magna eros eu erat. Aliquam erat volutpat. Nam dui mi, tincidunt quis, accumsan porttitor, facilisis luctus, metus&lt;/p&gt; 效果截图如下： 五、禁止文本被选中CSS 代码如下： 1234.disable-selection &#123; width: 50%; user-select: none;&#125; HTML 代码如下： 123456789101112131415161718&lt;p class=\"disable-selection\"&gt; Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Vestibulum tortor quam, feugiat vitae, ultricies eget, tempor sit amet, ante. Donec eu libero sit amet quam egestas semper. Aenean ultricies mi vitae est. Mauris placerat eleifend leo. Quisque sit amet est et sapien ullamcorper pharetra. Vestibulum erat wisi, condimentum sed, commodo vitae, ornare sit amet, wisi. Aenean fermentum, elit eget tincidunt condimentum, eros ipsum rutrum orci, sagittis tempus lacus enim ac dui. Donec non enim in turpis pulvinar facilisis. Ut felis. Praesent dapibus, neque id cursus faucibus, tortor neque egestas augue, eu vulputate magna eros eu erat. Aliquam erat volutpat. Nam dui mi, tincidunt quis, accumsan porttitor, facilisis luctus, metus&lt;/p&gt; 六、渐变色文本HTML 代码如下：123&lt;p class=\"gradient-text\"&gt; gradient-text&lt;/p&gt; CSS 代码如下：12345.gradient-text &#123; background: -webkit-linear-gradient(pink, red); -webkit-text-fill-color: transparent; -webkit-background-clip: text;&#125; 效果截图如下： 七、Hover 下划线效果该部分实现一个鼠标移入时的下划线变化效果，共用一段 HTML 代码，代码如下：123&lt;p class=\"hover-underline-animation\"&gt; Hover Underline Animation&lt;/p&gt; 各部分实现效果的 CSS 代码各异，将分别给出。 （1）从中间开始变化CSS 代码如下：123456789101112131415.hover-underline-animation &#123; cursor: pointer;&#125;.hover-underline-animation::after &#123; content: ''; width: 100%; height: 2px; display: block; background-color: #7983ff; transform: scaleX(0); transition: transform 0.3s;&#125;.hover-underline-animation:hover::after &#123; transform: scaleX(1);&#125; 效果截图如下： （2）从左至右变化CSS 代码如下：1234567891011121314151617.hover-underline-animation &#123; cursor: pointer;&#125;.hover-underline-animation::after &#123; content: ''; width: 100%; height: 2px; display: block; background-color: #7983ff; transform: scaleX(0); transform-origin: right; transition: transform 0.3s;&#125;.hover-underline-animation:hover::after &#123; transform: scaleX(1); transform-origin: left;&#125; 效果截图如下： （3）实现左入左出、右入右出的效果这一部分 HTML 代码略有不同，为了展示左入左出、右入右出的效果，需要三个元素来实现，所以 HTML 代码多了两个相同的元素：123456789&lt;span class=\"hover-underline-animation\"&gt; Hover Underline Animation&lt;/span&gt;&lt;span class=\"hover-underline-animation\"&gt; Hover Underline Animation&lt;/span&gt;&lt;span class=\"hover-underline-animation\"&gt; Hover Underline Animation&lt;/span&gt; CSS 代码如下;123456789101112131415161718192021.hover-underline-animation &#123; cursor: pointer; position: relative;&#125;.hover-underline-animation::after &#123; content: ''; position: absolute; right: 0; bottom: 0; width: 0%; height: 2px; display: block; background-color: #7983ff; transition: all 0.3s;&#125;.hover-underline-animation:hover::after &#123; width: 100%;&#125;.hover-underline-animation:hover ~ .hover-underline-animation::after &#123; right: 100% !important;&#125; 效果截图如下： 八、:not 选择器HTML 代码如下：123456&lt;ul class=\"not-selector\" type=\"none\"&gt; &lt;li&gt;One&lt;/li&gt; &lt;li&gt;Two&lt;/li&gt; &lt;li&gt;Three&lt;/li&gt; &lt;li&gt;Four&lt;/li&gt;&lt;/ul&gt; CSS 代码如下：1234567891011121314.not-selector &gt; li &#123; width: 20rem; position: relative;&#125;.not-selector &gt; li:not(:last-child)::after &#123; content: \"\"; display: inline-block; background-color: #c3c3c3; height: 0.5px; width: 100%; position: absolute; bottom: 0; left: 0;&#125; 实现效果如下： 九、滚动容器的渐变遮罩HTML 代码如下：1234567891011121314151617181920&lt;div class=\"overflow-scroll-gradient dn\"&gt; &lt;div&gt; Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Vestibulum tortor quam, feugiat vitae, ultricies eget, tempor sit amet, ante. Donec eu libero sit amet quam egestas semper. Aenean ultricies mi vitae est. Mauris placerat eleifend leo. Quisque sit amet est et sapien ullamcorper pharetra. Vestibulum erat wisi, condimentum sed, commodo vitae, ornare sit amet, wisi. Aenean fermentum, elit eget tincidunt condimentum, eros ipsum rutrum orci, sagittis tempus lacus enim ac dui. Donec non enim in turpis pulvinar facilisis. Ut felis. Praesent dapibus, neque id cursus faucibus, tortor neque egestas augue, eu vulputate magna eros eu erat. Aliquam erat volutpat. Nam dui mi, tincidunt quis, accumsan porttitor, facilisis luctus, metus &lt;/div&gt;&lt;/div&gt; CSS 代码如下：12345678910111213141516171819202122232425262728.overflow-scroll-gradient &#123; position: relative;&#125;.overflow-scroll-gradient::before &#123; content: \"\"; display: inline-block; position: absolute; top: 0; left: 0; width: 100%; height: 5rem; background: linear-gradient(rgba(255, 255, 255, 1), rgba(255, 255, 255, 0.001))&#125;.overflow-scroll-gradient::after &#123; content: \"\"; display: inline-block; position: absolute; bottom: 0; left: 0; width: 100%; height: 5rem; background: linear-gradient(rgba(255, 255, 255, 0.001), rgba(255, 255, 255, 1))&#125;.overflow-scroll-gradient &gt; div &#123; width: 15rem; height: 25rem; overflow-y: scroll;&#125; 效果截图如下： 十、使用系统字体获得原生体验HTML 代码：1&lt;p class=\"system-font-stack\"&gt;This text uses the system font.&lt;/p&gt; CSS 代码如下：123.system-font-stack &#123; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen-Sans, Ubuntu, Cantarell, 'Helvetica Neue', Helvetica, Arial, sans-serif;&#125; 我在 Ubuntu 系统下显示效果如下： 十一、圆润的 checkboxHTML 代码如下：1234&lt;div&gt; &lt;input type=\"checkbox\" id=\"toggle\" class=\"offscreen\"&gt; &lt;label for=\"toggle\" class=\"checkbox\"&gt;&lt;/label&gt;&lt;/div&gt; CSS 代码如下：1234567891011121314151617181920212223242526272829.offscreen &#123; display: none;&#125;.checkbox &#123; width: 40px; height: 20px; border-radius: 20px; display: inline-block; background-color: rgba(0, 0, 0, 0.25); position: relative; cursor: pointer;&#125;.checkbox::before &#123; content: \"\"; width: 18px; height: 18px; border-radius: 18px; background-color: white; position: absolute; left: 1px; top: 1px; transition: transform .3s ease;&#125;#toggle:checked + .checkbox &#123; background-color: #7983ff;&#125;#toggle:checked + .checkbox::before &#123; transform: translateX(20px);&#125; 效果截图如下： 十二、绘制一个三角形HTML 代码如下：1&lt;div class=\"triangle\"&gt;&lt;/div&gt; CSS 代码如下：123456.triangle &#123; width: 0; height: 0; border: 1rem solid transparent; border-bottom: 3rem solid blue;&#125; 利用 CSS border 的特性绘制三角形，改变 border 的宽度，可以绘制不同特性的三角形。 十三、过长的文本用省略号代替HTML 代码如下：123&lt;p class=\"truncate-text\"&gt; This text will be truncated with ellipse ......&lt;/p&gt; CSS 代码如下：1234567.truncate-text &#123; width: 19rem; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; background-color: #c3c3c3&#125; 效果截图如下;","categories":[{"name":"CSS","slug":"CSS","permalink":"http://zhongdeming.fun/categories/CSS/"}],"tags":[]}]}