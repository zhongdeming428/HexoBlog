<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  
  <title>解密虚拟 DOM——snabbdom 核心源码解读 | D.M</title>
  <meta name="description" content>
  <meta name="keywords" content="ZhongDeming,zhongdeming428,Blog,Front-End,JavaScript">
  <meta name="HandheldFriendly" content="True">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <link rel="shortcut icon" href="/images/logo.png">
  <link rel="alternate" href="/atom.xml" title="D.M">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="本文源码地址：https://github.com/zhongdeming428/snabbdom  对很多人而言，虚拟 DOM 都是一个很高大上而且远不可及的专有名词，以前我也这么认为，后来在学习 Vue 源码的时候发现 Vue 的虚拟 DOM 方案衍生于本文要讲的 snabbdom 工具，经过阅读源码之后才发现，虚拟 DOM 原来就是这么回事，并没有想象中那么难以理解嘛～ 这篇文章呢，就单独">
<meta name="keywords" content="ZhongDeming,zhongdeming428,Blog,Front-End,JavaScript">
<meta property="og:type" content="article">
<meta property="og:title" content="解密虚拟 DOM——snabbdom 核心源码解读">
<meta property="og:url" content="http://zhongdeming.fun/2019/04/27/snabbdom/index.html">
<meta property="og:site_name" content="D.M">
<meta property="og:description" content="本文源码地址：https://github.com/zhongdeming428/snabbdom  对很多人而言，虚拟 DOM 都是一个很高大上而且远不可及的专有名词，以前我也这么认为，后来在学习 Vue 源码的时候发现 Vue 的虚拟 DOM 方案衍生于本文要讲的 snabbdom 工具，经过阅读源码之后才发现，虚拟 DOM 原来就是这么回事，并没有想象中那么难以理解嘛～ 这篇文章呢，就单独">
<meta property="og:locale" content="Chinese">
<meta property="og:updated_time" content="2021-05-07T21:21:43.640Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="解密虚拟 DOM——snabbdom 核心源码解读">
<meta name="twitter:description" content="本文源码地址：https://github.com/zhongdeming428/snabbdom  对很多人而言，虚拟 DOM 都是一个很高大上而且远不可及的专有名词，以前我也这么认为，后来在学习 Vue 源码的时候发现 Vue 的虚拟 DOM 方案衍生于本文要讲的 snabbdom 工具，经过阅读源码之后才发现，虚拟 DOM 原来就是这么回事，并没有想象中那么难以理解嘛～ 这篇文章呢，就单独">
    
  <link href="https://fonts.googleapis.com/css?family=Inconsolata|Titillium+Web" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Roboto+Mono" rel="stylesheet">
  <link href="//cdn.bootcss.com/node-waves/0.7.5/waves.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/style.css">
  <style>
    *{margin:0;padding:0;}
    img{border:0 none;}
    body{background:#eee;}
    .m-box{margin:0 auto;display:inline-block;padding:20px;background:#fff;}
    .m-box p{margin:0 0 10px;}
    .m-box .icn a{display:block;width:55px;height:35px;background:url('http://l.bst.126.net/rsc/img/weibo.png?035') no-repeat;}
    .m-box .icn .wb1{background-position:10px -216px;}
    .m-box .icn .wb2{background-position:-190px -216px;}
    .m-box .icn .wb3{background:url(http://l.bst.126.net/rsc/img/postshare/tieba24.png) 15px 0 no-repeat;}
    .m-box .icn .wb4{background-position:-88px -215px;}
    .m-box .icn .wb5{background-position:-138px -216px;}
    .m-box .icn .wb6{background-position:-245px -216px;}
    .m-box .icn .wb7{background-position:-300px -216px;}
    .m-box .icn .wb8{background-position:-355px -216px;}
    .m-box .icn .wb9{background-position:-415px -215px;}
  </style>
  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>
</head>
</html>
<body>
  <div id="loading-bar-wrapper">
  <div id="loading-bar"></div>
</div>


  <script>setLoadingBarProgress(20)</script> 
  <header class="l_header">
	<div class='wrapper'>
		<div class="nav-main container container--flex">
			<a class="logo flat-box" href='/' >
				D.M
			</a>
			<div class='menu'>
				<ul class='h-list'>
					
						<li>
							<a class='flat-box nav-home' href='/'>
								Home
							</a>
						</li>
					
						<li>
							<a class='flat-box nav-archives' href='/archives'>
								Archives
							</a>
						</li>
					
						<li>
							<a class='flat-box nav-comments' href='/comments'>
								Comments
							</a>
						</li>
					
						<li>
							<a class='flat-box nav-about' href='/about'>
								About
							</a>
						</li>
					
				</ul>
				<div class='underline'></div>
			</div>
			
				<div class="m_search">
					<form name="searchform" class="form u-search-form">
						<input type="text" class="input u-search-input" placeholder="Search" />
						<span class="icon icon-search"></span>
					</form>
				</div>
			
			<ul class='switcher h-list'>
				
					<li class='s-search'><a href='javascript:void(0)'><span class="icon icon-search flat-box"></span></a></li>
				
				<li class='s-menu'><a href='javascript:void(0)'><span class="icon icon-menu flat-box"></span></a></li>
			</ul>
		</div>
		
		<div class='nav-sub container container--flex'>
			<a class="logo" class="flat-box" href='javascript:void(0)'>
				Word of Forks
			</a>

			<ul class='switcher h-list'>
				<li class='s-comment'><a href='javascript:void(0)'><span class="icon icon-chat_bubble_outline flat-box"></span></a></li>
				<li class='s-top'><a href='javascript:void(0)'><span class="icon icon-arrow_upward flat-box"></span></a></li>
				<li class='s-toc'><a href='javascript:void(0)'><span class="icon icon-format_list_numbered flat-box"></span></a></li>
			</ul>
		</div>
	</div>
</header>
<aside class="menu-phone">
	<nav>
		
			<a href="/" class="nav-home nav">
				Home
			</a>
		
			<a href="/archives" class="nav-archives nav">
				Archives
			</a>
		
			<a href="/comments" class="nav-comments nav">
				Comments
			</a>
		
			<a href="/about" class="nav-about nav">
				About
			</a>
		
	</nav>
</aside>

    <script>setLoadingBarProgress(40);</script>
  <div class="l_body">
    <div class='container clearfix'>
      <div class='l_main'>
        <article id="post-snabbdom"
  class="post white-box article-type-post"
  itemscope itemprop="blogPost">
	<section class='meta'>
	<h2 class="title">
  	<a href="/2019/04/27/snabbdom/">
    	解密虚拟 DOM——snabbdom 核心源码解读
    </a>
  </h2>
	<time>
	  Apr 27, 2019
	</time>
	
    
    <div class='cats'>
        <a href="/categories/JavaScript/">JavaScript</a>
    </div>

	<br>
	<span id="busuanzi_container_page_pv">
		<time>浏览次数：<span id="busuanzi_value_page_pv"></span></time>
 	</span>
	</section>
	
		<section class="toc-wrapper"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#一、snabbdom-核心概念"><span class="toc-number">1.</span> <span class="toc-text">一、snabbdom 核心概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#snabbdom-的一些优点"><span class="toc-number">1.1.</span> <span class="toc-text">snabbdom 的一些优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#modules-的一些优点"><span class="toc-number">1.2.</span> <span class="toc-text">modules 的一些优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#第三方支持很多的优点"><span class="toc-number">1.3.</span> <span class="toc-text">第三方支持很多的优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#核心-API"><span class="toc-number">1.4.</span> <span class="toc-text">核心 API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Module-模块"><span class="toc-number">1.5.</span> <span class="toc-text">Module 模块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Hooks-钩子"><span class="toc-number">1.6.</span> <span class="toc-text">Hooks 钩子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#EventListener"><span class="toc-number">1.7.</span> <span class="toc-text">EventListener</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Thunk"><span class="toc-number">1.8.</span> <span class="toc-text">Thunk</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二、源码目录结构"><span class="toc-number">2.</span> <span class="toc-text">二、源码目录结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三、虚拟-DOM-结构"><span class="toc-number">3.</span> <span class="toc-text">三、虚拟 DOM 结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#四、Hooks-结构"><span class="toc-number">4.</span> <span class="toc-text">四、Hooks 结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#五、Module-结构"><span class="toc-number">5.</span> <span class="toc-text">五、Module 结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#六、h-函数"><span class="toc-number">6.</span> <span class="toc-text">六、h 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#七、snabbdom-ts"><span class="toc-number">7.</span> <span class="toc-text">七、snabbdom.ts</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#八、参考文章"><span class="toc-number">8.</span> <span class="toc-text">八、参考文章</span></a></li></ol></section>
	
	<section class="article typo">
  	<div class="article-entry" itemprop="articleBody">
    	<blockquote>
<p>本文源码地址：<a href="https://github.com/zhongdeming428/snabbdom" target="_blank" rel="noopener">https://github.com/zhongdeming428/snabbdom</a></p>
</blockquote>
<p>对很多人而言，虚拟 DOM 都是一个很高大上而且远不可及的专有名词，以前我也这么认为，后来在学习 Vue 源码的时候发现 Vue 的虚拟 DOM 方案衍生于本文要讲的 snabbdom 工具，经过阅读源码之后才发现，虚拟 DOM 原来就是这么回事，并没有想象中那么难以理解嘛～</p>
<p>这篇文章呢，就单独从 snabbdom 这个库讲起，不涉及其他任何框架，单独从这个库的源码来聊一聊虚拟 DOM。</p>
<blockquote>
<p> 在讲 snabbdom 之前，需要先学习 TypeScript 知识，以及 snabbdom 的基本使用方法。</p>
</blockquote>
<h3 id="一、snabbdom-核心概念"><a href="#一、snabbdom-核心概念" class="headerlink" title="一、snabbdom 核心概念"></a>一、snabbdom 核心概念</h3><p>在学习 snabbdom 源码之前，最好先学会用 snabbdom，至少要掌握 snabbdom 的核心概念，这是阅读框架源码之前基本都要做的准备工作。</p>
<blockquote>
<p>以下内容可以直接到 snabbdom 官方文档了解。</p>
</blockquote>
<a id="more"></a>
<h4 id="snabbdom-的一些优点"><a href="#snabbdom-的一些优点" class="headerlink" title="snabbdom 的一些优点"></a>snabbdom 的一些优点</h4><p>snabbdom 主要具有一下优点：</p>
<ul>
<li>核心部分的源代码只有两百多行（其实不止），容易读懂。</li>
<li>通过 <code>modules</code> 可以很容易地扩展。</li>
<li>钩子函数很丰富，用户可以通过钩子函数直接干涉 Vnode 到 DOM 挂载到最终销毁的全过程。</li>
<li>性能很棒。</li>
<li>容易集成。</li>
</ul>
<h4 id="modules-的一些优点"><a href="#modules-的一些优点" class="headerlink" title="modules 的一些优点"></a>modules 的一些优点</h4><ul>
<li>通过 h 函数，可以很容易地创建 Vnode。</li>
<li>通过 h 函数可以创建 SVG 元素。</li>
<li>事件处理能力强大。</li>
<li>可以通过 Thunks 优化 DOM Diff 和事件。</li>
</ul>
<h4 id="第三方支持很多的优点"><a href="#第三方支持很多的优点" class="headerlink" title="第三方支持很多的优点"></a>第三方支持很多的优点</h4><p>通过一些第三方的插件，可以很容易地支持 JSX、服务端 HTML 输出等等……</p>
<h4 id="核心-API"><a href="#核心-API" class="headerlink" title="核心 API"></a>核心 API</h4><p>较为核心的 API 其实就四个：<code>init</code>、<code>patch</code>、 <code>h</code>和<code>tovnode</code>，通过这四个 API 就可以玩转虚拟 DOM 啦！</p>
<p>下面简单介绍一下这四个核心函数：</p>
<ul>
<li><p><code>init</code>：这是 snabbdom 暴露出来的一个核心函数，通过它我们才能开始使用许多重要的功能。该函数接受一个数组作为参数，数组内都是 <code>module</code>，通过  <code>init</code> 注册了一系列要使用的 module 之后，它会给我们返回一个 <code>patch</code> 函数。</p>
</li>
<li><p><code>patch</code>： 该函数是我们挂载或者更新 vnode 的重要途径。它接受两个参数，第一个参数可以是 HTML 元素或者 vnode，第二个元素只能是 vnode。通过 patch 函数，可以对第一个 vnode 进行更新，或者把 vnode 挂载/更新到 DOM 元素上。</p>
</li>
<li><p><code>tovnode</code>： 用于把真实的 DOM 转化为 vnode，适合把 SSR 生成的 DOM 转化成 vnode，然后进行 DOM 操作。</p>
</li>
<li><p><code>h</code>： 该函数用于创建 vnode，在许多地方都能见到它的身影。它接受三个参数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@param &#123;string&#125; selector|tag 标签名或者选择器</span><br><span class="line">@param &#123;object&#125; data 数据对象，结构在后面讲</span><br><span class="line">@param &#123;vNode[]|string&#125; children 子节点，可以是文本节点</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="Module-模块"><a href="#Module-模块" class="headerlink" title="Module 模块"></a>Module 模块</h4><p>Module 是 snabbdom 的一个核心概念，snabbdom 的核心主干代码只实现了元素、id、class（不包含动态赋值）、元素内容（包括文本节点在内的子节点）这四个方面；而其他诸如 style 样式、class 动态赋值、attr 属性等功能都是通过 Module 扩展的，它们写成了 snabbdom 的内部默认 Module，在需要的时候引用就行了。</p>
<p>那么 Module 究竟是什么呢？</p>
<p>snabbdom 的官方文档已经讲得很清楚了，Module 的本质是一个对象，对象的键由一些钩子（Hooks）的名称组成，键值都是函数，这些函数能够在特定的 vnode/DOM 生命周期触发，并接受规定的参数，能够对周期中的 vnode/DOM 进行操作。</p>
<p>由于 snabbdom 使用 TypeScript 编写，所以在之后看代码的时候，我们可以非常清楚地看到 Module 的组成结构。</p>
<p>内置 Module 有如下几种：</p>
<ul>
<li><code>class</code>：动态控制元素的 class。</li>
<li><code>props</code>：设置 DOM 的一些属性（properties）。</li>
<li><code>attributes</code>：同样用于设置 DOM 属性，但是是 attributes，而且 properties。</li>
<li><code>style</code>：设置 DOM 的样式。</li>
<li><code>dataset</code>：设置自定义属性。</li>
<li><code>customProperties</code>：CSS 的变量，使用方法参考官方文档。</li>
<li><code>delayedProperties</code>：延迟的 CSS 样式，可用于创建动画之类。</li>
</ul>
<h4 id="Hooks-钩子"><a href="#Hooks-钩子" class="headerlink" title="Hooks 钩子"></a>Hooks 钩子</h4><p>snabbdom 提供了丰富的生命周期钩子：</p>
<table>
<thead>
<tr>
<th>钩子名称</th>
<th>触发时机</th>
<th>Arguments to callback</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>pre</code></td>
<td>patch 开始之前。</td>
<td>none</td>
</tr>
<tr>
<td><code>init</code></td>
<td>已经创建了一个 vnode。</td>
<td><code>vnode</code></td>
</tr>
<tr>
<td><code>create</code></td>
<td>已经基于 vnode 创建了一个 DOM，但尚未挂载。</td>
<td><code>emptyVnode, vnode</code></td>
</tr>
<tr>
<td><code>insert</code></td>
<td>创建的 DOM 被挂载了。</td>
<td><code>vnode</code></td>
</tr>
<tr>
<td><code>prepatch</code></td>
<td>一个元素即将被 patch。</td>
<td><code>oldVnode, vnode</code></td>
</tr>
<tr>
<td><code>update</code></td>
<td>元素正在被更新。</td>
<td><code>oldVnode, vnode</code></td>
</tr>
<tr>
<td><code>postpatch</code></td>
<td>元素已经 patch 完毕。</td>
<td><code>oldVnode, vnode</code></td>
</tr>
<tr>
<td><code>destroy</code></td>
<td>一个元素被直接或间接地移除了。间接移除的情况是指被移除元素的子元素。</td>
<td><code>vnode</code></td>
</tr>
<tr>
<td><code>remove</code></td>
<td>一个元素被直接移除了（卸载）。</td>
<td><code>vnode, removeCallback</code></td>
</tr>
<tr>
<td><code>post</code></td>
<td>patch 结束。</td>
<td>none</td>
</tr>
</tbody>
</table>
<p><strong>如何使用钩子呢？</strong></p>
<p>在创建 vnode 的时候，把定义的钩子函数传递给 <code>data.hook</code> 就 OK 了；当然还可以在自定义 Module 中使用钩子，同理定义钩子函数并赋值给 Module 对象就可以了。</p>
<p><strong>注意</strong></p>
<p>Module 中只能使用以下几种钩子：<code>pre</code>, <code>create</code>, <code>update</code>, <code>destroy</code>, <code>remove</code>, <code>post</code>。</p>
<p>而在 vnode 创建中定义的钩子只能是以下几种：<code>init</code>, <code>create</code>, <code>insert</code>, <code>prepatch</code>, <code>update</code>, <code>postpatch</code>, <code>destroy</code>, <code>remove</code>。为什么 <code>pre</code> 和 <code>post</code> 不能使用呢？因为这两个钩子不在 vnode 的生命周期之中，在 vnode 创建之前，pre 已经执行完毕，在 vnode 卸载完毕之后，post 钩子才开始执行。</p>
<h4 id="EventListener"><a href="#EventListener" class="headerlink" title="EventListener"></a>EventListener</h4><p>snabbdom 提供 DOM 事件处理功能，创建 vnode 时，定义好 <code>data.on</code> 即可。比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">h(</span><br><span class="line">	<span class="string">'div'</span>,</span><br><span class="line">    &#123;</span><br><span class="line">        on: &#123;</span><br><span class="line">            click: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">/*...*/</span>&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>如上，就定义了一个 click 事件处理函数。</p>
<p>那么如果我们要预先传入一些自定义的参数那该怎么做呢？此时我们应该通过数组定义 handler：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">h(</span><br><span class="line">	<span class="string">'div'</span>,</span><br><span class="line">    &#123;</span><br><span class="line">        on: &#123;</span><br><span class="line">            click: [</span><br><span class="line">                <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;<span class="comment">/*...*/</span>&#125;,</span><br><span class="line">                data</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>那我们的事件对象如何获取呢？这一点 snabbdom 已经考虑好了，event 对象和 vnode 对象会附加在我们的自定义参数后传入到 handler。</p>
<h4 id="Thunk"><a href="#Thunk" class="headerlink" title="Thunk"></a>Thunk</h4><p>根据官方文档的说明，Thunk 是一种优化策略，可以防止创建重复的 vnode，然后对实际未发生变化的 vnode 做替换或者 patch，造成不必要的性能损耗。在后面的源码分析中，再做详细说明吧。</p>
<h3 id="二、源码目录结构"><a href="#二、源码目录结构" class="headerlink" title="二、源码目录结构"></a>二、源码目录结构</h3><p>在首先查看源代码之前，先分析一下源码的目录结构，好有的放矢的进行阅读，下面是 <code>src</code> 目录下的文件结构：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── helpers</span><br><span class="line">│   └── attachto.ts</span><br><span class="line">├── hooks.ts // 定义了钩子函数的类型</span><br><span class="line">├── htmldomapi.ts	// 定义了一系列 DOM 操作的 API</span><br><span class="line">├── h.ts	// 主要定义了 h 函数</span><br><span class="line">├── is.ts	// 主要定义了一个类型判断辅助函数</span><br><span class="line">├── modules	// 定义内置 module 的目录</span><br><span class="line">│   ├── attributes.ts</span><br><span class="line">│   ├── class.ts</span><br><span class="line">│   ├── dataset.ts</span><br><span class="line">│   ├── eventlisteners.ts</span><br><span class="line">│   ├── hero.ts</span><br><span class="line">│   ├── module.ts</span><br><span class="line">│   ├── props.ts</span><br><span class="line">│   └── style.ts</span><br><span class="line">├── snabbdom.bundle.ts // 导出 h 函数和 patch 函数（注册了所有内置模块）。</span><br><span class="line">├── snabbdom.ts // 导出 init，允许自定义注册模块</span><br><span class="line">├── thunk.ts	// 定义了 thunk</span><br><span class="line">├── tovnode.ts	// 定义了 tovnode 函数</span><br><span class="line">└── vnode.ts	// 定义了 vnode 类型</span><br><span class="line"></span><br><span class="line">2 directories, 18 files</span><br></pre></td></tr></table></figure>
<p>所以看完之后，我们应该有了一个大致的概念，要较好的了解 vnode，我们可以先从 vnode 下手，结合文档的介绍，可以详细了解虚拟 DOM 的结构。</p>
<p>此外还可以从我们使用 snabbdom 的入口处入手，即 snabbdom.ts。</p>
<h3 id="三、虚拟-DOM-结构"><a href="#三、虚拟-DOM-结构" class="headerlink" title="三、虚拟 DOM 结构"></a>三、虚拟 DOM 结构</h3><p>这一小节先了解 vnode 的结构是怎么样的，由于 snabbdom 使用 TypeScript 编写，所以关于变量的结构可以一目了然，打开 <code>vnode.ts</code>，可以看到关于 vnode 的定义：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> VNode &#123;</span><br><span class="line">  sel: <span class="built_in">string</span> | <span class="literal">undefined</span>;</span><br><span class="line">  data: VNodeData | <span class="literal">undefined</span>;</span><br><span class="line">  children: <span class="built_in">Array</span>&lt;VNode | <span class="built_in">string</span>&gt; | <span class="literal">undefined</span>;</span><br><span class="line">  elm: Node | <span class="literal">undefined</span>;</span><br><span class="line">  text: <span class="built_in">string</span> | <span class="literal">undefined</span>;</span><br><span class="line">  key: Key | <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到 vnode 的结构其实比较简单，只有 6 个属性。关于这六个属性，官网已经做了介绍：</p>
<ul>
<li><code>sel</code>：是一种 CSS 选择器，vnode 挂载为 DOM 时，会基于这个属性构造 HTML 元素。</li>
<li><code>data</code>：构造 vnode 的数据属性，在构造 DOM 时会用到里面的数据，data 的结构在 <code>vnode.ts</code> 中可以找到定义，稍后作介绍。</li>
<li><code>children</code>：这是一个 vnode 数组，在 vnode 挂载为 DOM 时，其 children 内的所有 vnode 会被构造为 HTML 元素，进一步挂载到上一级节点下。</li>
<li><code>elm</code>：这是根据当前 vnode 构造的 DOM 元素。</li>
<li><code>text</code>： 当前 vnode 的文本节点内容。</li>
<li><code>key</code>：snabbdom 用 <code>key</code> 和 <code>sel</code> 来区分不同的 vnode，如果两个 vnode 的 <code>sel</code> 和 <code>key</code> 属性都相等，那么可以认为两个 vnode 完全相等，他们之间的更新需要进一步比对。</li>
</ul>
<p>往下翻可以看到 VNodeData 的类型定义：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> VNodeData &#123;</span><br><span class="line">  props?: Props;</span><br><span class="line">  attrs?: Attrs;</span><br><span class="line">  <span class="keyword">class</span>?: Classes;</span><br><span class="line">  style?: VNodeStyle;</span><br><span class="line">  dataset?: Dataset;</span><br><span class="line">  on?: On;</span><br><span class="line">  hero?: Hero;</span><br><span class="line">  attachData?: AttachData;</span><br><span class="line">  hook?: Hooks;</span><br><span class="line">  key?: Key;</span><br><span class="line">  ns?: <span class="built_in">string</span>; <span class="comment">// for SVGs</span></span><br><span class="line">  fn?: <span class="function"><span class="params">()</span> =&gt;</span> VNode; <span class="comment">// for thunks</span></span><br><span class="line">  args?: <span class="built_in">Array</span>&lt;<span class="built_in">any</span>&gt;; <span class="comment">// for thunks</span></span><br><span class="line">  [key: <span class="built_in">string</span>]: <span class="built_in">any</span>; <span class="comment">// for any other 3rd party module</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出来这些属性基本上都是在 Module 中所使用的，用于对 DOM 的一些数据、属性进行定义，后面再进行介绍。</p>
<h3 id="四、Hooks-结构"><a href="#四、Hooks-结构" class="headerlink" title="四、Hooks 结构"></a>四、Hooks 结构</h3><p>打开 <code>hooks.ts</code>，可以看到源码如下：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;VNode&#125; <span class="keyword">from</span> <span class="string">'./vnode'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> PreHook = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">any</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> InitHook = <span class="function">(<span class="params">vNode: VNode</span>) =&gt;</span> <span class="built_in">any</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> CreateHook = <span class="function">(<span class="params">emptyVNode: VNode, vNode: VNode</span>) =&gt;</span> <span class="built_in">any</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> InsertHook = <span class="function">(<span class="params">vNode: VNode</span>) =&gt;</span> <span class="built_in">any</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> PrePatchHook = <span class="function">(<span class="params">oldVNode: VNode, vNode: VNode</span>) =&gt;</span> <span class="built_in">any</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> UpdateHook = <span class="function">(<span class="params">oldVNode: VNode, vNode: VNode</span>) =&gt;</span> <span class="built_in">any</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> PostPatchHook = <span class="function">(<span class="params">oldVNode: VNode, vNode: VNode</span>) =&gt;</span> <span class="built_in">any</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> DestroyHook = <span class="function">(<span class="params">vNode: VNode</span>) =&gt;</span> <span class="built_in">any</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> RemoveHook = <span class="function">(<span class="params">vNode: VNode, removeCallback: (<span class="params"></span>) =&gt; <span class="built_in">void</span></span>) =&gt;</span> <span class="built_in">any</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> PostHook = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">any</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> Hooks &#123;</span><br><span class="line">  pre?: PreHook;</span><br><span class="line">  init?: InitHook;</span><br><span class="line">  create?: CreateHook;</span><br><span class="line">  insert?: InsertHook;</span><br><span class="line">  prepatch?: PrePatchHook;</span><br><span class="line">  update?: UpdateHook;</span><br><span class="line">  postpatch?: PostPatchHook;</span><br><span class="line">  destroy?: DestroyHook;</span><br><span class="line">  remove?: RemoveHook;</span><br><span class="line">  post?: PostHook;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些代码定义了所有钩子函数的结构类型（接受的参数、返回的参数），然后定义了 Hooks 类型，这与我们前面介绍的钩子类型和所接受的参数是一致的。</p>
<h3 id="五、Module-结构"><a href="#五、Module-结构" class="headerlink" title="五、Module 结构"></a>五、Module 结构</h3><p>打开 <code>module.ts</code>，看到源码如下：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;PreHook, CreateHook, UpdateHook, DestroyHook, RemoveHook, PostHook&#125; <span class="keyword">from</span> <span class="string">'../hooks'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> Module &#123;</span><br><span class="line">  pre: PreHook;</span><br><span class="line">  create: CreateHook;</span><br><span class="line">  update: UpdateHook;</span><br><span class="line">  destroy: DestroyHook;</span><br><span class="line">  remove: RemoveHook;</span><br><span class="line">  post: PostHook;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，该模块先引用了上一节代码定义的一系列钩子的类型，然后用这些类型进一步定义了 Module。能够看出来 module 实际上就是几种钩子函数组成的一个对象，用于干涉 DOM 的构造。</p>
<h3 id="六、h-函数"><a href="#六、h-函数" class="headerlink" title="六、h 函数"></a>六、<code>h</code> 函数</h3><p><code>h</code> 函数是一个大名鼎鼎的函数，在各个框架中都有这个函数的身影。它的愿意是 <code>hyperscript</code>，意思是创造 <code>HyperText</code> 的 <code>JavaScript</code>，当然包括创造 <code>HTML</code> 的 <code>JavaScript</code>。在 snabbdom 中也不例外，<code>h</code> 函数旨在接受一系列参数，然后构造对应的 vnode，其返回的 vnode 最终会被渲染成 HTML 元素。</p>
<p>看看源代码：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">h</span>(<span class="params">sel: <span class="built_in">string</span></span>): <span class="title">VNode</span></span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">h</span>(<span class="params">sel: <span class="built_in">string</span>, data: VNodeData</span>): <span class="title">VNode</span></span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">h</span>(<span class="params">sel: <span class="built_in">string</span>, children: VNodeChildren</span>): <span class="title">VNode</span></span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">h</span>(<span class="params">sel: <span class="built_in">string</span>, data: VNodeData, children: VNodeChildren</span>): <span class="title">VNode</span></span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">h</span>(<span class="params">sel: <span class="built_in">any</span>, b?: <span class="built_in">any</span>, c?: <span class="built_in">any</span></span>): <span class="title">VNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data: VNodeData = &#123;&#125;, children: <span class="built_in">any</span>, text: <span class="built_in">any</span>, i: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">if</span> (c !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    data = b;</span><br><span class="line">    <span class="keyword">if</span> (is.array(c)) &#123; children = c; &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (is.primitive(c)) &#123; text = c; &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c &amp;&amp; c.sel) &#123; children = [c]; &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (b !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (is.array(b)) &#123; children = b; &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (is.primitive(b)) &#123; text = b; &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (b &amp;&amp; b.sel) &#123; children = [b]; &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; data = b; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (children !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; children.length; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (is.primitive(children[i])) children[i] = vnode(<span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, children[i], <span class="literal">undefined</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    sel[<span class="number">0</span>] === <span class="string">'s'</span> &amp;&amp; sel[<span class="number">1</span>] === <span class="string">'v'</span> &amp;&amp; sel[<span class="number">2</span>] === <span class="string">'g'</span> &amp;&amp;</span><br><span class="line">    (sel.length === <span class="number">3</span> || sel[<span class="number">3</span>] === <span class="string">'.'</span> || sel[<span class="number">3</span>] === <span class="string">'#'</span>)</span><br><span class="line">  ) &#123;</span><br><span class="line">    addNS(data, children, sel);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> vnode(sel, data, children, text, <span class="literal">undefined</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> h;</span><br></pre></td></tr></table></figure>
<p>可以看到前面很大一段都是函数重载，所以不用太关注，只用关注到最后一行：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> vnode(sel, data, children, text, <span class="literal">undefined</span>);</span><br></pre></td></tr></table></figure>
<p>在适配好参数之后，<code>h</code>函数调用了 vnode 函数，实现了 vnode 的创建，而 vnode 函数更简单，就是一个工厂函数：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">vnode</span>(<span class="params">sel: <span class="built_in">string</span> | <span class="literal">undefined</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                      data: <span class="built_in">any</span> | <span class="literal">undefined</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                      children: <span class="built_in">Array</span>&lt;VNode | <span class="built_in">string</span>&gt; | <span class="literal">undefined</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                      text: <span class="built_in">string</span> | <span class="literal">undefined</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                      elm: Element | Text | <span class="literal">undefined</span></span>): <span class="title">VNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> key = data === <span class="literal">undefined</span> ? <span class="literal">undefined</span> : data.key;</span><br><span class="line">  <span class="keyword">return</span> &#123;sel: sel, data: data, children: children,</span><br><span class="line">          text: text, elm: elm, key: key&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它来自于 <code>vnode.ts</code>。</p>
<p>总之我们知道 <code>h</code> 函数接受相应的参数，返回一个 vnode 就行了。</p>
<h3 id="七、snabbdom-ts"><a href="#七、snabbdom-ts" class="headerlink" title="七、snabbdom.ts"></a>七、snabbdom.ts</h3><blockquote>
<p>在讲 snabbdom.ts 之前，本来应该先了解  htmldomapi.ts 的，但是这个模块全都是对于 HTML 元素 API 的封装，没有讲解的必要，所以阅读本章之前，读者自行阅读 htmldomapi.ts 源码即可。</p>
</blockquote>
<p>这是整个项目的核心所在，也是定义入口函数的重要文件，这个文件大概有接近 400 行，主要定义了一些工具函数以及一个入口函数。</p>
<p>打开 <code>snabbdom.ts</code> ，最早看到的就是一些简单的类型定义，我们也先来了解一下：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isUndef</span>(<span class="params">s: <span class="built_in">any</span></span>): <span class="title">boolean</span> </span>&#123; <span class="keyword">return</span> s === <span class="literal">undefined</span>; &#125; <span class="comment">// 判断 s 是否为 undefined。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断 s 是否已定义（不为 undefined）。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isDef</span>(<span class="params">s: <span class="built_in">any</span></span>): <span class="title">boolean</span> </span>&#123; <span class="keyword">return</span> s !== <span class="literal">undefined</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个 VNodeQueue 队列，实际上是 vnode 数组，代表要挂载的 vnode。</span></span><br><span class="line"><span class="keyword">type</span> VNodeQueue = <span class="built_in">Array</span>&lt;VNode&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个空的 vnode，用于传递给 craete 钩子（查看第一节）。</span></span><br><span class="line"><span class="keyword">const</span> emptyNode = vnode(<span class="string">''</span>, &#123;&#125;, [], <span class="literal">undefined</span>, <span class="literal">undefined</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断两个 vnode 是否重复，依据是 key 和 sel。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sameVnode</span>(<span class="params">vnode1: VNode, vnode2: VNode</span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> vnode1.key === vnode2.key &amp;&amp; vnode1.sel === vnode2.sel;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否是 vnode。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isVnode</span>(<span class="params">vnode: <span class="built_in">any</span></span>): <span class="title">vnode</span> <span class="title">is</span> <span class="title">VNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> vnode.sel !== <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个对象，用于映射 childen 数组中 vnode 的 key 和其 index 索引。</span></span><br><span class="line"><span class="keyword">type</span> KeyToIndexMap = &#123;[key: <span class="built_in">string</span>]: <span class="built_in">number</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// T 是一个对象，其中的每一个键都被映射到 ArraysOf 类型，键值是 T 键值的数组集合。</span></span><br><span class="line"><span class="keyword">type</span> ArraysOf&lt;T&gt; = &#123;</span><br><span class="line">  [K <span class="keyword">in</span> keyof T]: (T[K])[];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参照上面的注释。</span></span><br><span class="line"><span class="keyword">type</span> ModuleHooks = ArraysOf&lt;Module&gt;;</span><br></pre></td></tr></table></figure>
<p>看完了基本类型的定义，可以继续看 init 函数：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params">modules: <span class="built_in">Array</span>&lt;Partial&lt;Module&gt;&gt;, domApi?: DOMAPI</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i: <span class="built_in">number</span>, j: <span class="built_in">number</span>, cbs = (&#123;&#125; <span class="keyword">as</span> ModuleHooks);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> api: DOMAPI = domApi !== <span class="literal">undefined</span> ? domApi : htmlDomApi;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; hooks.length; ++i) &#123;</span><br><span class="line">    cbs[hooks[i]] = [];</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; modules.length; ++j) &#123;</span><br><span class="line">      <span class="keyword">const</span> hook = modules[j][hooks[i]];</span><br><span class="line">      <span class="keyword">if</span> (hook !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">        (cbs[hooks[i]] <span class="keyword">as</span> <span class="built_in">Array</span>&lt;<span class="built_in">any</span>&gt;).push(hook);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">	</span><br><span class="line">  <span class="comment">// 这中间定义了一大堆工具函数，稍后做选择性分析……此处省略。</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// init 函数返回的 patch 函数，用于挂载或者更新 DOM。</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">patch</span>(<span class="params">oldVnode: VNode | Element, vnode: VNode</span>): <span class="title">VNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> i: <span class="built_in">number</span>, elm: Node, parent: Node;</span><br><span class="line">    <span class="keyword">const</span> insertedVnodeQueue: VNodeQueue = [];</span><br><span class="line">    <span class="comment">// 先执行完钩子函数对象中的所有 pre 回调。</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cbs.pre.length; ++i) cbs.pre[i]();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!isVnode(oldVnode)) &#123;</span><br><span class="line">      <span class="comment">// 如果不是 VNode，那此时以旧的 DOM 为模板构造一个空的 VNode。</span></span><br><span class="line">      oldVnode = emptyNodeAt(oldVnode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sameVnode(oldVnode, vnode)) &#123;</span><br><span class="line">      <span class="comment">// 如果 oldVnode 和 vnode 是同一个 vnode（相同的 key 和相同的选择器），那么更新 oldVnode。</span></span><br><span class="line">      patchVnode(oldVnode, vnode, insertedVnodeQueue);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果 vnode 不同于 oldVnode，那么直接替换掉 oldVnode 对应的 DOM。</span></span><br><span class="line">      elm = oldVnode.elm <span class="keyword">as</span> Node;</span><br><span class="line">      parent = api.parentNode(elm); <span class="comment">// oldVnode 对应 DOM 的父节点。</span></span><br><span class="line"></span><br><span class="line">      createElm(vnode, insertedVnodeQueue);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (parent !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果 oldVnode 的对应 DOM 有父节点，并且有同级节点，那就在其同级节点之后插入 vnode 的对应 DOM。</span></span><br><span class="line">        api.insertBefore(parent, vnode.elm <span class="keyword">as</span> Node, api.nextSibling(elm));</span><br><span class="line">        <span class="comment">// 在把 vnode 的对应 DOM 插入到 oldVnode 的父节点内后，移除 oldVnode 的对应 DOM，完成替换。</span></span><br><span class="line">        removeVnodes(parent, [oldVnode], <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insertedVnodeQueue.length; ++i) &#123;</span><br><span class="line">      <span class="comment">// 执行 insert 钩子。因为 module 不包括 insert 钩子，所以不必执行 cbs...</span></span><br><span class="line">      (((insertedVnodeQueue[i].data <span class="keyword">as</span> VNodeData).hook <span class="keyword">as</span> Hooks).insert <span class="keyword">as</span> <span class="built_in">any</span>)(insertedVnodeQueue[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行 post 钩子，代表 patch 操作完成。</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cbs.post.length; ++i) cbs.post[i]();</span><br><span class="line">    <span class="comment">// 最终返回 vnode。</span></span><br><span class="line">    <span class="keyword">return</span> vnode;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到 init 函数其实不仅可以接受一个 module 数组作为参数，还可以接受一个 domApi 作为参数，这在官方文档上是没有说明的。可以理解为 snabbdom 允许我们自定义 dom 的一些操作函数，在这个过程中对 DOM 的构造进行干预，只需要我们传递的 domApi 的结构符合预定义就可以了，此处不再细表。</p>
<p>然后可以看到的就是两个嵌套着的循环，大致意思是遍历 hooks 和 modules，构造一个 <code>ModuleHooks</code> 类型的 cbs 变量，那这是什么意思呢？</p>
<p>hooks 定义如下：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hooks: (keyof Module)[] = [<span class="string">'create'</span>, <span class="string">'update'</span>, <span class="string">'remove'</span>, <span class="string">'destroy'</span>, <span class="string">'pre'</span>, <span class="string">'post'</span>];</span><br></pre></td></tr></table></figure>
<p>那就是把每个 module 中对应的钩子函数整理到 cbs 钩子名称对应的数组中去，比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> module1 = &#123;</span><br><span class="line">    create() &#123; <span class="comment">/*...*/</span> &#125;,</span><br><span class="line">    update() &#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> module2 = &#123;</span><br><span class="line">    create() &#123; <span class="comment">/*...*/</span> &#125;,</span><br><span class="line">    update() &#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 经过整理之后……</span></span><br><span class="line"><span class="comment">// cbs 如下：</span></span><br><span class="line">&#123;</span><br><span class="line">    create: [create1, create2],</span><br><span class="line">    update: [update1, update2]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种结构类似于发布——订阅模式的事件中心，以事件名作为键，键值是事件处理函数组成的数组，在事件发生时，数组中的函数会依次执行，与此处一致。</p>
<p>在处理好 hooks 之后，init 内部定义了一系列工具函数，此处暂不讲解，先往后看。</p>
<p>init 处理到最后返回的使我们预期的 patch 函数，该函数是我们使用 snabbdom 的重要入口，其具体定义如下：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// init 函数返回的 patch 函数，用于挂载或者更新 DOM。</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">patch</span>(<span class="params">oldVnode: VNode | Element, vnode: VNode</span>): <span class="title">VNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i: <span class="built_in">number</span>, elm: Node, parent: Node;</span><br><span class="line">  <span class="keyword">const</span> insertedVnodeQueue: VNodeQueue = [];</span><br><span class="line">  <span class="comment">// 先执行完钩子函数对象中的所有 pre 回调。</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cbs.pre.length; ++i) cbs.pre[i]();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (!isVnode(oldVnode)) &#123;</span><br><span class="line">    <span class="comment">// 如果不是 VNode，那此时以旧的 DOM 为模板构造一个空的 VNode。</span></span><br><span class="line">    oldVnode = emptyNodeAt(oldVnode);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (sameVnode(oldVnode, vnode)) &#123;</span><br><span class="line">    <span class="comment">// 如果 oldVnode 和 vnode 是同一个 vnode（相同的 key 和相同的选择器），那么更新 oldVnode。</span></span><br><span class="line">    patchVnode(oldVnode, vnode, insertedVnodeQueue);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果 vnode 不同于 oldVnode，那么直接替换掉 oldVnode 对应的 DOM。</span></span><br><span class="line">    elm = oldVnode.elm <span class="keyword">as</span> Node;</span><br><span class="line">    parent = api.parentNode(elm); <span class="comment">// oldVnode 对应 DOM 的父节点。</span></span><br><span class="line"></span><br><span class="line">    createElm(vnode, insertedVnodeQueue);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (parent !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果 oldVnode 的对应 DOM 有父节点，并且有同级节点，那就在其同级节点之后插入 vnode 的对应 DOM。</span></span><br><span class="line">      api.insertBefore(parent, vnode.elm <span class="keyword">as</span> Node, api.nextSibling(elm));</span><br><span class="line">      <span class="comment">// 在把 vnode 的对应 DOM 插入到 oldVnode 的父节点内后，移除 oldVnode 的对应 DOM，完成替换。</span></span><br><span class="line">      removeVnodes(parent, [oldVnode], <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insertedVnodeQueue.length; ++i) &#123;</span><br><span class="line">    <span class="comment">// 执行 insert 钩子。因为 module 不包括 insert 钩子，所以不必执行 cbs...</span></span><br><span class="line">    (((insertedVnodeQueue[i].data <span class="keyword">as</span> VNodeData).hook <span class="keyword">as</span> Hooks).insert <span class="keyword">as</span> <span class="built_in">any</span>)(insertedVnodeQueue[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 执行 post 钩子，代表 patch 操作完成。</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cbs.post.length; ++i) cbs.post[i]();</span><br><span class="line">  <span class="comment">// 最终返回 vnode。</span></span><br><span class="line">  <span class="keyword">return</span> vnode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到在 patch 执行的一开始，就遍历了 cbs 中的所有 pre 钩子，也就是所有 module 中定义的 pre 函数。执行完了 pre 钩子，代表 patch 过程已经开始了。</p>
<p>接下来首先判断 oldVnode 是不是 vnode 类型，如果不是，就代表 oldVnode 是一个 HTML 元素，那我们就要把他转化为一个 vnode，方便后面的更新，更新完毕之后再进行挂载。转化为 vnode 的方式很简单，直接将其 DOM 结构挂载到 vnode 的 elm 属性，然后构造好 sel 即可。</p>
<p>随后，通过 <code>sameVnode</code> 判断是否是同一个 “vnode”。如果不是，那么就可以直接把两个 vnode 代表的 DOM 元素进行直接替换；如果是“同一个” vnode，那么就需要进行下一步对比，看看到底有哪些地方需要更新，可以看做是一个 DOM Diff 过程。所以这里出现了 snabbdom 的一个小诀窍，通过 sel 和 key 区分 vnode，不相同的 vnode 可以直接替换，不进行下一步的替换。这样做在很大程度上避免了一些没有必要的比较，节约了性能。</p>
<p>完成上面的步骤之后，就已经把 vnode 挂载到 DOM 上了，完成这个步骤之后，需要执行 vnode 的 insert 钩子，告诉所有的模块：一个 DOM 已经挂载了！</p>
<p>最后，执行所有的 post 钩子并返回 vnode，通知所有模块整个 patch 过程已经结束啦！</p>
<p>不难发现重点在于当 oldVnode 和 vnode 是同一个 vnode 时如何进行更新。这就自然而然的涉及到了 <code>patchVnode</code> 函数，该函数结构如下：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patchVnode</span>(<span class="params">oldVnode: VNode, vnode: VNode, insertedVnodeQueue: VNodeQueue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i: <span class="built_in">any</span>, hook: <span class="built_in">any</span>;</span><br><span class="line">  <span class="keyword">if</span> (isDef(i = vnode.data) &amp;&amp; isDef(hook = i.hook) &amp;&amp; isDef(i = hook.prepatch)) &#123;</span><br><span class="line">    <span class="comment">// 如果 vnode.data.hook.prepatch 不为空，则执行 prepatch 钩子。</span></span><br><span class="line">    i(oldVnode, vnode);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> elm = vnode.elm = (oldVnode.elm <span class="keyword">as</span> Node);</span><br><span class="line">  <span class="keyword">let</span> oldCh = oldVnode.children;</span><br><span class="line">  <span class="keyword">let</span> ch = vnode.children;</span><br><span class="line">  <span class="comment">// 如果两个 vnode 是真正意义上的相等，那完全就不用更新了。</span></span><br><span class="line">  <span class="keyword">if</span> (oldVnode === vnode) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (vnode.data !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果 vnode 的 data 不为空，那么执行 update。</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cbs.update.length; ++i) cbs.update[i](oldVnode, vnode);</span><br><span class="line">    i = vnode.data.hook;</span><br><span class="line">    <span class="comment">// 执行 vnode.data.hook.update 钩子。</span></span><br><span class="line">    <span class="keyword">if</span> (isDef(i) &amp;&amp; isDef(i = i.update)) i(oldVnode, vnode);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isUndef(vnode.text)) &#123;</span><br><span class="line">    <span class="comment">// 如果 vnode.text 未定义。</span></span><br><span class="line">    <span class="keyword">if</span> (isDef(oldCh) &amp;&amp; isDef(ch)) &#123;</span><br><span class="line">      <span class="comment">// 如果都有 children，那就更新 children。</span></span><br><span class="line">      <span class="keyword">if</span> (oldCh !== ch) updateChildren(elm, oldCh <span class="keyword">as</span> <span class="built_in">Array</span>&lt;VNode&gt;, ch <span class="keyword">as</span> <span class="built_in">Array</span>&lt;VNode&gt;, insertedVnodeQueue);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(ch)) &#123;</span><br><span class="line">      <span class="comment">// 如果 oldVnode 是文本节点，而更新后 vnode 包含 children；</span></span><br><span class="line">      <span class="comment">// 那就先移除 oldVnode 的文本节点，然后添加 vnode。</span></span><br><span class="line">      <span class="keyword">if</span> (isDef(oldVnode.text)) api.setTextContent(elm, <span class="string">''</span>);</span><br><span class="line">      addVnodes(elm, <span class="literal">null</span>, ch <span class="keyword">as</span> <span class="built_in">Array</span>&lt;VNode&gt;, <span class="number">0</span>, (ch <span class="keyword">as</span> <span class="built_in">Array</span>&lt;VNode&gt;).length - <span class="number">1</span>, insertedVnodeQueue);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldCh)) &#123;</span><br><span class="line">      <span class="comment">// 如果 oldVnode 有 children，而新的 vnode 只有文本节点；</span></span><br><span class="line">      <span class="comment">// 那就移除 vnode 即可。</span></span><br><span class="line">      removeVnodes(elm, oldCh <span class="keyword">as</span> <span class="built_in">Array</span>&lt;VNode&gt;, <span class="number">0</span>, (oldCh <span class="keyword">as</span> <span class="built_in">Array</span>&lt;VNode&gt;).length - <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldVnode.text)) &#123;</span><br><span class="line">      <span class="comment">// 如果更新前后，vnode 都没有 children，那么就添加空的文本节点，因为大前提是 vnode.text === undefined。</span></span><br><span class="line">      api.setTextContent(elm, <span class="string">''</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldVnode.text !== vnode.text) &#123;</span><br><span class="line">    <span class="comment">// 定义了 vnode.text，并且 vnode 的 text 属性不同于 oldVnode 的 text 属性。</span></span><br><span class="line">    <span class="keyword">if</span> (isDef(oldCh)) &#123;</span><br><span class="line">      <span class="comment">// 如果 oldVnode 具有 children 属性（具有 vnode），那么移除所有 vnode。</span></span><br><span class="line">      removeVnodes(elm, oldCh <span class="keyword">as</span> <span class="built_in">Array</span>&lt;VNode&gt;, <span class="number">0</span>, (oldCh <span class="keyword">as</span> <span class="built_in">Array</span>&lt;VNode&gt;).length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置文本内容。</span></span><br><span class="line">    api.setTextContent(elm, vnode.text <span class="keyword">as</span> <span class="built_in">string</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isDef(hook) &amp;&amp; isDef(i = hook.postpatch)) &#123;</span><br><span class="line">    <span class="comment">// 完成了更新，调用 postpatch 钩子函数。</span></span><br><span class="line">    i(oldVnode, vnode);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数是用于更新 vnode 的主要函数，所以 vnode 的主要生命周期都在这个函数内完成。首先执行的钩子就是 prepatch，表示元素即将被 patch。然后会判断 vnode 是否包含 data 属性，如果包含则说明需要先更新 data，这时候会调用所有的 update 钩子（包括模块内的和 vnode 自带的 update 钩子），在 update 钩子内完成 data 的合并更新。在 children 更新之后，还会调用 postpatch 钩子，表示 patch 过程已经执行完毕。</p>
<p>接下来从 text 入手，这一大块的注释都在代码里面写得很清楚了，这里不再赘述。重点在于 oldVnode 和 vnode 都有 children 属性的时候，如何更新 children？接下来看 <code>updateChildren</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateChildren</span>(<span class="params">parentElm: Node,</span></span></span><br><span class="line"><span class="function"><span class="params">                          oldCh: <span class="built_in">Array</span>&lt;VNode&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">                          newCh: <span class="built_in">Array</span>&lt;VNode&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">                          insertedVnodeQueue: VNodeQueue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> oldStartIdx = <span class="number">0</span>, newStartIdx = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> oldEndIdx = oldCh.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> oldStartVnode = oldCh[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">let</span> oldEndVnode = oldCh[oldEndIdx];</span><br><span class="line">  <span class="keyword">let</span> newEndIdx = newCh.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> newStartVnode = newCh[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">let</span> newEndVnode = newCh[newEndIdx];</span><br><span class="line">  <span class="keyword">let</span> oldKeyToIdx: <span class="built_in">any</span>;</span><br><span class="line">  <span class="keyword">let</span> idxInOld: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">let</span> elmToMove: VNode;</span><br><span class="line">  <span class="keyword">let</span> before: <span class="built_in">any</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从两端开始开始遍历 children。</span></span><br><span class="line">  <span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">    <span class="keyword">if</span> (oldStartVnode == <span class="literal">null</span>) &#123;</span><br><span class="line">      oldStartVnode = oldCh[++oldStartIdx]; <span class="comment">// Vnode might have been moved left</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldEndVnode == <span class="literal">null</span>) &#123;</span><br><span class="line">      oldEndVnode = oldCh[--oldEndIdx];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newStartVnode == <span class="literal">null</span>) &#123;</span><br><span class="line">      newStartVnode = newCh[++newStartIdx];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newEndVnode == <span class="literal">null</span>) &#123;</span><br><span class="line">      newEndVnode = newCh[--newEndIdx];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newStartVnode)) &#123; <span class="comment">// 如果是同一个 vnode。</span></span><br><span class="line">      patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue); <span class="comment">// 更新旧的 vnode。</span></span><br><span class="line">      oldStartVnode = oldCh[++oldStartIdx];</span><br><span class="line">      newStartVnode = newCh[++newStartIdx];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newEndVnode)) &#123; <span class="comment">// 同上，但是是从尾部开始的。</span></span><br><span class="line">      patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);</span><br><span class="line">      oldEndVnode = oldCh[--oldEndIdx];</span><br><span class="line">      newEndVnode = newCh[--newEndIdx];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newEndVnode)) &#123; <span class="comment">// Vnode moved right</span></span><br><span class="line">      patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);</span><br><span class="line">      api.insertBefore(parentElm, oldStartVnode.elm <span class="keyword">as</span> Node, api.nextSibling(oldEndVnode.elm <span class="keyword">as</span> Node));</span><br><span class="line">      oldStartVnode = oldCh[++oldStartIdx];</span><br><span class="line">      newEndVnode = newCh[--newEndIdx];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newStartVnode)) &#123; <span class="comment">// Vnode moved left</span></span><br><span class="line">      patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);</span><br><span class="line">      api.insertBefore(parentElm, oldEndVnode.elm <span class="keyword">as</span> Node, oldStartVnode.elm <span class="keyword">as</span> Node);</span><br><span class="line">      oldEndVnode = oldCh[--oldEndIdx];</span><br><span class="line">      newStartVnode = newCh[++newStartIdx];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (oldKeyToIdx === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="comment">// 创造一个 hash 结构，用键映射索引。</span></span><br><span class="line">        oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);</span><br><span class="line">      &#125;</span><br><span class="line">      idxInOld = oldKeyToIdx[newStartVnode.key <span class="keyword">as</span> <span class="built_in">string</span>]; <span class="comment">// 通过 key 来获取对应索引。</span></span><br><span class="line">      <span class="keyword">if</span> (isUndef(idxInOld)) &#123; <span class="comment">// New element</span></span><br><span class="line">        <span class="comment">// 如果找不到索引，那就是新元素。</span></span><br><span class="line">        api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm <span class="keyword">as</span> Node);</span><br><span class="line">        newStartVnode = newCh[++newStartIdx];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 找到对应的 child vnode。</span></span><br><span class="line">        elmToMove = oldCh[idxInOld];</span><br><span class="line">        <span class="keyword">if</span> (elmToMove.sel !== newStartVnode.sel) &#123;</span><br><span class="line">          <span class="comment">// 如果新旧 vnode 的选择器不能对应，那就直接插入到旧 vnode 之前。</span></span><br><span class="line">          api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm <span class="keyword">as</span> Node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 选择器匹配上了，可以直接更新。</span></span><br><span class="line">          patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);</span><br><span class="line">          oldCh[idxInOld] = <span class="literal">undefined</span> <span class="keyword">as</span> <span class="built_in">any</span>; <span class="comment">// 已更新的旧 vnode 赋值为 undefined。</span></span><br><span class="line">          api.insertBefore(parentElm, (elmToMove.elm <span class="keyword">as</span> Node), oldStartVnode.elm <span class="keyword">as</span> Node);</span><br><span class="line">        &#125;</span><br><span class="line">        newStartVnode = newCh[++newStartIdx];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (oldStartIdx &lt;= oldEndIdx || newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">    <span class="comment">// 没匹配上的多余的就直接插入到 DOM 咯。</span></span><br><span class="line">    <span class="keyword">if</span> (oldStartIdx &gt; oldEndIdx) &#123;</span><br><span class="line">      <span class="comment">// newCh 里面有新的 vnode，直接插入到 DOM。</span></span><br><span class="line">      before = newCh[newEndIdx+<span class="number">1</span>] == <span class="literal">null</span> ? <span class="literal">null</span> : newCh[newEndIdx+<span class="number">1</span>].elm;</span><br><span class="line">      addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// newCh 里面的 vnode 比 oldCh 里面的少，说明有元素被删除了。</span></span><br><span class="line">      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>updateVnode</code> 函数在一开始就从 children 数组的首尾两端开始遍历。可以看到在遍历开始的时候会有一堆的 null 判断，为什么呢？因为后面会把已经更新的 vnode children 赋值为 undefined。</p>
<p>判断完 null 之后，会比较新旧 children 内的节点是否“相同”（排列组合共有四种比较方式），如果相同，那就继续调用 patchNode 更新节点，更新完之后就可以插入 DOM 了；如果四中情况都匹配不到，那么就通过之前建立的 key 与索引之间的映射来寻找新旧 children 数组中对应 child vnode 的索引，找到之后再进行具体操作。关于具体的操作，代码中已经注释了～</p>
<p>对于遍历之后多余的 vnode，再分情况进行比较；如果 oldCh 多于 newCh，那说明该操作删除了部分 DOM。如果 oldCh 少于 newCh，那说明有新增的 DOM。</p>
<p>关于 <code>updateChildren</code> 函数的讲述，这篇文章的讲述更为详细：<a href="https://www.cnblogs.com/xuntu/p/6800547.html" target="_blank" rel="noopener">vue的Virtual Dom实现- snabbdom解密</a> ，大家可以去读一下～</p>
<p>讲完最重要的这个函数，整个核心部分基本上是弄完了，不难发现 snabbdom 的秘诀就在于使用：</p>
<ul>
<li>使用虚拟 DOM 模拟真实 DOM，JavaScript 内存操作性能大大优于 DOM 操作，所以性能比较好。</li>
<li>Diff 算法比较好，只比较同级 vnode，不会循环遍历去比较，而且采用 key 和 sel 标记 vnode，大大优化比较速度。这一做法类似于 Immutable，使用 hash 比较代替对象的循环递归比较，大大降低时间复杂度。</li>
</ul>
<p>最后还有一个小问题，这个贯穿许多函数的 <code>insertedVnodeQueue</code> 数组是干嘛的？它只在 <code>createElm</code> 函数中进行 push 操作，然后在最后的 insert 钩子中进行遍历。仔细一想就可以发现，这个插入 vnode 队列存起来的是一个 children 的左右子 children，看下面一段代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">h(</span><br><span class="line">	<span class="string">'div'</span>,</span><br><span class="line">    &#123;&#125;,</span><br><span class="line">    [</span><br><span class="line">        h(<span class="comment">/*...*/</span>),</span><br><span class="line">        h(<span class="comment">/*...*/</span>),</span><br><span class="line">        h(<span class="comment">/*...*/</span>)</span><br><span class="line">    ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>可以看到 div 下面包含了三个 children，那么当这个 div 元素被插入到 DOM 时，它的三个子 children 也会触发 insert 事件，所以在插入 vnode 时，会遍历其所有 children，然后每个 vnode 都会放入到队列中，在插入之后再统一执行 insert 钩子。</p>
<p>以上，就写这么多吧～多的也没时间写了。</p>
<h3 id="八、参考文章"><a href="#八、参考文章" class="headerlink" title="八、参考文章"></a>八、参考文章</h3><ul>
<li><a href="https://www.cnblogs.com/xuntu/p/6800547.html" target="_blank" rel="noopener">vue的Virtual Dom实现- snabbdom解密</a></li>
</ul>

  	</div>
	  
		
	
		<div class="art-item-footer">
				
					<span class="art-item-left"><i class="icon icon-chevron-thin-left"></i>prev：<a href="/2019/05/06/WebPerf101/" rel="prev"  title="常见 Web 性能优化方式">
						常见 Web 性能优化方式 
					</a></span>
				
				
					<span class="art-item-right">next：<a href="/2019/04/13/浅谈-JSONP/" rel="next"  title="浅谈 JSONP">
						浅谈 JSONP
					</a><i class="icon icon-chevron-thin-right"></i></span>
				
		</div>
	
	</section>
	
	<div class="m-box">
		<div class="icn"><a  class="wb1" onclick="shareToSinaWB(event)"></a></div>
	</div>
	<div class="m-box">
		<div class="icn"><a class="wb2" onclick="shareToQzone(event)"></a></div>
	</div>
	<div class="m-box">
		<div class="icn"><a class="wb3" onclick="shareToTieba(event)"></a></div>
	</div>
	<div class="m-box">
		<div class="icn"><a class="wb4" onclick="shareToDouban(event)"></a></div>
	</div>
	<div class="m-box">
		<div class="icn"><a class="wb6" onclick="shareToRenren(event)"></a></div>
	</div>
	<div class="m-box">
		<div class="icn"><a class="wb7" onclick="shareToKaixin(event)"></a></div>
	</div>
	<div class="m-box">
		<div class="icn"><a class="wb8" onclick="shareToFacebook(event)"></a></div>
	</div>
	<div class="m-box">
		<div class="icn"><a class="wb9" onclick="shareToTwitter(event)"></a></div>
	</div>
	<div class="comment"></div>
</article>
<script>
	window.subData = {
		title: '解密虚拟 DOM——snabbdom 核心源码解读',
		tools: true
	}
</script>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="https://cdnjs.loli.net/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
<!--Valine 的核心代码库-->
<!-- <script src="/js/Valine.min.js"></script> -->
<script src='//unpkg.com/valine/dist/Valine.min.js'></script>
<script>
	new Valine({
		// AV 对象来自上面引入av-min.js(老司机们不要开车➳♡゛扎心了老铁)
		av: AV,
		el: '.comment',
		emoticon_url: 'https://cloud.panjunwen.com/alu',
		emoticon_list: ["吐.png", "期待.png", "高兴.png", "吐血倒地.png", "哭泣.png", "欢呼.png"],
		appId: 'dEN3oH01uVTVRJFwuWKzucX3-gzGzoHsz', // 这里填写上面得到的APP ID
		appKey: 'l11XssvYyHKpzcePOV03e2WJ', // 这里填写上面得到的APP KEY
		placeholder: 'ヾﾉ≧∀≦)o来啊，快活啊!', // 留言框占位提示文字
	});
	var _title,_source,_sourceUrl,_pic,_showcount,_desc,_summary,_site,
			_width = 600,
			_height = 600,
			_top = (screen.height-_height)/2,
			_left = (screen.width-_width)/2,
			_url = window.location.href,
			_pic = 'https://github.com/zhongdeming428/HexoBlog/blob/master/Blogs/source/images/logo.png?raw=true';
	//分享到新浪微博
	function shareToSinaWB(event){
			event.preventDefault();
			var _shareUrl = 'http://v.t.sina.com.cn/share/share.php?&appkey=895033136';     //真实的appkey，必选参数
			_shareUrl += '&url='+ encodeURIComponent(_url||document.location);     //参数url设置分享的内容链接|默认当前页location，可选参数
			_shareUrl += '&title=' + encodeURIComponent(_title||document.title);    //参数title设置分享的标题|默认当前页标题，可选参数
			_shareUrl += '&source=' + encodeURIComponent(_source||'');
			_shareUrl += '&sourceUrl=' + encodeURIComponent(_sourceUrl||'');
			_shareUrl += '&content=' + 'utf-8';   //参数content设置页面编码gb2312|utf-8，可选参数
			_shareUrl += '&pic=' + encodeURIComponent(_pic||'');  //参数pic设置图片链接|默认为空，可选参数
			window.open(_shareUrl,'_blank','width='+_width+',height='+_height+',top='+_top+',left='+_left+',toolbar=no,menubar=no,scrollbars=no, resizable=1,location=no,status=0');
	}
	//分享到QQ空间
	function shareToQzone(event){
			event.preventDefault();
			var _shareUrl = 'http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?';
			_shareUrl += 'url=' + encodeURIComponent(_url||document.location);   //参数url设置分享的内容链接|默认当前页location
			_shareUrl += '&showcount=' + _showcount||0;      //参数showcount是否显示分享总数,显示：'1'，不显示：'0'，默认不显示
			_shareUrl += '&desc=' + encodeURIComponent(_desc||'分享的描述');    //参数desc设置分享的描述，可选参数
			_shareUrl += '&summary=' + encodeURIComponent(_summary||'分享摘要');    //参数summary设置分享摘要，可选参数
			_shareUrl += '&title=' + encodeURIComponent(_title||document.title);    //参数title设置分享标题，可选参数
			_shareUrl += '&site=' + encodeURIComponent(_site||'');   //参数site设置分享来源，可选参数
			_shareUrl += '&pics=' + encodeURIComponent(_pic||'');   //参数pics设置分享图片的路径，多张图片以＂|＂隔开，可选参数
			window.open(_shareUrl,'_blank','width='+_width+',height='+_height+',top='+_top+',left='+_left+',toolbar=no,menubar=no,scrollbars=no,resizable=1,location=no,status=0');
	}
	//分享到百度贴吧
	function shareToTieba(event){
			event.preventDefault();
			var _shareUrl = 'http://tieba.baidu.com/f/commit/share/openShareApi?';
			_shareUrl += 'title=' + encodeURIComponent(_title||document.title);  //分享的标题
			_shareUrl += '&url=' + encodeURIComponent(_url||document.location);  //分享的链接
			_shareUrl += '&pic=' + encodeURIComponent(_pic||'');    //分享的图片
			window.open(_shareUrl,'_blank','width='+_width+',height='+_height+',left='+_left+',top='+_top+',toolbar=no,menubar=no,scrollbars=no,resizable=1,location=no,status=0');
	}
	//分享到豆瓣
	function shareToDouban(event){
			event.preventDefault();
			var _shareUrl = 'http://shuo.douban.com/!service/share?';
			_shareUrl += 'href=' + encodeURIComponent(_url||location.href);    //分享的链接
			_shareUrl += '&name=' + encodeURIComponent(_title||document.title);    //分享的标题
			_shareUrl += '&image=' + encodeURIComponent(_pic||'');    //分享的图片
			window.open(_shareUrl,'_blank','width='+_width+',height='+_height+',left='+_left+',top='+_top+',toolbar=no,menubar=no,scrollbars=no,resizable=1,location=no,status=0');
	}
	//分享到腾讯微博
	function shareToQQwb(event){
			event.preventDefault();
			var _shareUrl = 'http://v.t.qq.com/share/share.php?';
			_shareUrl += 'title=' + encodeURIComponent(_title||document.title);    //分享的标题
			_shareUrl += '&url=' + encodeURIComponent(_url||location.href);    //分享的链接
			_shareUrl += '&appkey=5bd32d6f1dff4725ba40338b233ff155';    //在腾迅微博平台创建应用获取微博AppKey
			_shareUrl += '&site=' + encodeURIComponent(_site||'');   //分享来源
			_shareUrl += '&pic=' + encodeURIComponent(_pic||'');    //分享的图片，如果是多张图片，则定义var _pic='图片url1|图片url2|图片url3....'
			window.open(_shareUrl,'_blank','width='+_width+',height='+_height+',left='+_left+',top='+_top+',toolbar=no,menubar=no,scrollbars=no,resizable=1,location=no,status=0');
	}
	//分享到人人网
	function shareToRenren(event){
			event.preventDefault();
			var _shareUrl = 'http://share.renren.com/share/buttonshare.do?';
			_shareUrl += 'link=' + encodeURIComponent(_url||location.href);   //分享的链接
			_shareUrl += '&title=' + encodeURIComponent(_title||document.title);     //分享的标题
			window.open(_shareUrl,'_blank','width='+_width+',height='+_height+',left='+_left+',top='+_top+',toolbar=no,menubar=no,scrollbars=no,resizable=1,location=no,status=0');
	}
	//分享到开心网
	function shareToKaixin(event){
			event.preventDefault();
			var _shareUrl = 'http://www.kaixin001.com/rest/records.php?';
			_shareUrl += 'url=' + encodeURIComponent(_url||location.href);    //分享的链接
			_shareUrl += '&content=' + encodeURIComponent('分享的文字');    //需要分享的文字，当文字为空时，自动抓取分享网址的title
			_shareUrl += '&pic=' + encodeURIComponent(_pic||'');     //分享的图片,多个使用半角逗号分隔
			_shareUrl += '&showcount=0';    //是否显示分享数，显示：'1'，不显示：'0'
			_shareUrl += '&style=11';      //显示的样式，必选参数
			_shareUrl += '&aid=' + encodeURIComponent(_site||'');    //显示分享来源
			window.open(_shareUrl,'_blank','width='+_width+',height='+_height+',left='+_left+',top='+_top+',toolbar=no,menubar=no,scrollbars=no,resizable=1,location=no,status=0');
	}
	function shareToKaixin2(event){
			event.preventDefault();
			var _shareUrl = 'http://www.kaixin001.com/repaste/share.php?';
			_shareUrl += 'rtitle=' + encodeURIComponent(_title||document.title);   //分享的标题
			window.open(_shareUrl,'_blank','width='+_width+',height='+_height+',left='+_left+',top='+_top+',toolbar=no,menubar=no,scrollbars=no,resizable=1,location=no,status=0');
	}
	//分享到facebook
	function shareToFacebook(event){
			event.preventDefault();
			var _shareUrl = 'http://www.facebook.com/sharer/sharer.php?';
			_shareUrl += 'u=' + encodeURIComponent(_url||location.href);    //分享的链接
			_shareUrl += '&t=' + encodeURIComponent(_title||document.title);    //分享的标题
			window.open(_shareUrl,'_blank','width='+_width+',height='+_height+',left='+_left+',top='+_top+',toolbar=no,menubar=no,scrollbars=no,resizable=1,location=no,status=0');
	}
	//分享到facebook
	function shareToFacebook(event){
			event.preventDefault();
			var _shareUrl = 'http://www.facebook.com/sharer/sharer.php?';
			_shareUrl += 'u=' + encodeURIComponent(_url||location.href);    //分享的链接
			_shareUrl += '&t=' + encodeURIComponent(_title||document.title);    //分享的标题
			window.open(_shareUrl,'_blank','width='+_width+',height='+_height+',left='+_left+',top='+_top+',toolbar=no,menubar=no,scrollbars=no,resizable=1,location=no,status=0');
	}
	//分享到Twitter
	function shareToTwitter(event){
			event.preventDefault();
			var _shareUrl = 'http://twitter.com/intent/tweet?';
			_shareUrl += 'url=' + encodeURIComponent(_url||location.href);    //分享的链接
			_shareUrl += '&text=' + encodeURIComponent(_title||document.title);    //分享的标题
			window.open(_shareUrl,'_blank','width='+_width+',height='+_height+',left='+_left+',top='+_top+',toolbar=no,menubar=no,scrollbars=no,resizable=1,location=no,status=0');
	}
</script>
      </div>
      <aside class='l_side'>
        
  <section class='m_widget about'>

<img class='avatar waves-image' src='/images/avatar.jpeg' />

<div class='header'>DM Zhong</div>
<div class='content'>
<div class='desc'>Learn & Live</div>
</div>
</section>

  <section class='m_widget links'>
<div class='header'>Links</div>
<div class='content'>
    <ul class="entry">
    
        <li><a class="flat-box" target="_blank" href="https://juejin.im/user/59424035128fe1006a1c3747">
            <div class='name'>掘金</div>
        </a></li>
    
        <li><a class="flat-box" target="_blank" href="https://www.cnblogs.com/DM428/">
            <div class='name'>博客园</div>
        </a></li>
    
        <li><a class="flat-box" target="_blank" href="https://m.weibo.cn/profile/5198069647">
            <div class='name'>新浪微博</div>
        </a></li>
    
        <li><a class="flat-box" target="_blank" href="https://github.com/zhongdeming428/Blog/issues">
            <div class='name'>原博客地址</div>
        </a></li>
    
    </ul>
</div>
</section>

  <section class='m_widget categories'>
<div class='header'>Categories</div>
<div class='content'>
    
    <ul class="entry">
    
        <li><a class="flat-box" href="/categories/JavaScript/Algorithm/"><div class='name'>Algorithm</div><div class='badget'>1</div></a></li>
    
        <li><a class="flat-box" href="/categories/CSS/"><div class='name'>CSS</div><div class='badget'>1</div></a></li>
    
        <li><a class="flat-box" href="/categories/Linux/Git/"><div class='name'>Git</div><div class='badget'>1</div></a></li>
    
        <li><a class="flat-box" href="/categories/Git/"><div class='name'>Git</div><div class='badget'>1</div></a></li>
    
        <li><a class="flat-box" href="/categories/HTTP/"><div class='name'>HTTP</div><div class='badget'>1</div></a></li>
    
        <li><a class="flat-box" href="/categories/HTTP/Hapijs/"><div class='name'>Hapijs</div><div class='badget'>1</div></a></li>
    
        <li><a class="flat-box" href="/categories/Java/"><div class='name'>Java</div><div class='badget'>1</div></a></li>
    
        <li><a class="flat-box" href="/categories/Nodejs/JavaScript/"><div class='name'>JavaScript</div><div class='badget'>1</div></a></li>
    
        <li><a class="flat-box" href="/categories/JavaScript/"><div class='name'>JavaScript</div><div class='badget'>6</div></a></li>
    
        <li><a class="flat-box" href="/categories/Vue/JavaScript/"><div class='name'>JavaScript</div><div class='badget'>1</div></a></li>
    
        <li><a class="flat-box" href="/categories/Linux/"><div class='name'>Linux</div><div class='badget'>3</div></a></li>
    
        <li><a class="flat-box" href="/categories/Nodejs/"><div class='name'>Nodejs</div><div class='badget'>1</div></a></li>
    
        <li><a class="flat-box" href="/categories/React/"><div class='name'>React</div><div class='badget'>3</div></a></li>
    
        <li><a class="flat-box" href="/categories/React/React-Router/"><div class='name'>React-Router</div><div class='badget'>1</div></a></li>
    
        <li><a class="flat-box" href="/categories/JavaScript/Redux/"><div class='name'>Redux</div><div class='badget'>1</div></a></li>
    
        <li><a class="flat-box" href="/categories/React/TypeScript/"><div class='name'>TypeScript</div><div class='badget'>1</div></a></li>
    
        <li><a class="flat-box" href="/categories/Linux/Vim/"><div class='name'>Vim</div><div class='badget'>1</div></a></li>
    
        <li><a class="flat-box" href="/categories/Vue/"><div class='name'>Vue</div><div class='badget'>1</div></a></li>
    
        <li><a class="flat-box" href="/categories/Webpack/Vue/"><div class='name'>Vue</div><div class='badget'>2</div></a></li>
    
        <li><a class="flat-box" href="/categories/Web-性能优化/"><div class='name'>Web 性能优化</div><div class='badget'>1</div></a></li>
    
        <li><a class="flat-box" href="/categories/Webpack/"><div class='name'>Webpack</div><div class='badget'>2</div></a></li>
    
        <li><a class="flat-box" href="/categories/Git/译文/"><div class='name'>译文</div><div class='badget'>1</div></a></li>
    
    </ul>
    
</div>
</section>

  


      </aside>
      <script>setLoadingBarProgress(60);</script>
    </div>
  </div>
  <footer id="footer" class="clearfix">

	<div class="social-wrapper">
  	
      
        <a href="https://github.com/zhongdeming428" class="social github"
          target="_blank" rel="external">
          <span class="icon icon-github"></span>
        </a>
      
        <a href="https://twitter.com/zhongdeming428" class="social twitter"
          target="_blank" rel="external">
          <span class="icon icon-twitter"></span>
        </a>
      
        <a href="/atom.xml" class="social rss"
          target="_blank" rel="external">
          <span class="icon icon-rss"></span>
        </a>
      
    
  </div>
  
  <div>Theme <a href='https://github.com/stkevintan/hexo-theme-material-flow' class="codename">MaterialFlow</a> designed by <a href="http://keyin.me/" target="_blank">Kevin Tan</a>.</div>
  
</footer>


  <script>setLoadingBarProgress(80);</script>
  

<script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
<script src='//cdn.bootcss.com/node-waves/0.7.5/waves.min.js'></script>
<script src="//cdn.bootcss.com/scrollReveal.js/3.3.2/scrollreveal.min.js"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
<script src="/js/jquery.fitvids.js"></script>
<script>
	var GOOGLE_CUSTOM_SEARCH_API_KEY = "";
	var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "";
	var ALGOLIA_API_KEY = "";
	var ALGOLIA_APP_ID = "";
	var ALGOLIA_INDEX_NAME = "";
  var AZURE_SERVICE_NAME = "";
  var AZURE_INDEX_NAME = "";
  var AZURE_QUERY_KEY = "";
  var BAIDU_API_ID = "";
  var SEARCH_SERVICE = "hexo";
  var ROOT = "/"||"/";
  if(!ROOT.endsWith('/'))ROOT += '/';
</script>
<script src="/js/search.js"></script>
<script src="/js/app.js"></script>


  <script>setLoadingBarProgress(100);</script>
  <script>
    !function(){"use strict";function e(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}function t(e,t){return e(t={exports:{}},t.exports),t.exports}var n=t(function(e,t){Object.defineProperty(t,"__esModule",{value:!0});var n=1;t.default=function(){return""+n++},e.exports=t.default});e(n);var o=t(function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:30,n=null;return function(){for(var o=this,i=arguments.length,r=Array(i),a=0;a<i;a++)r[a]=arguments[a];clearTimeout(n),n=setTimeout(function(){e.apply(o,r)},t)}},e.exports=t.default});e(o);var i=t(function(e,t){Object.defineProperty(t,"__esModule",{value:!0});t.SizeSensorId="size-sensor-id",t.SensorStyle="display:block;position:absolute;top:0;left:0;height:100%;width:100%;overflow:hidden;pointer-events:none;z-index:-1;opacity:0",t.SensorClassName="size-sensor-object"});e(i);i.SizeSensorId,i.SensorStyle,i.SensorClassName;var r=t(function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.createSensor=void 0;var n,r=(n=o)&&n.__esModule?n:{default:n};t.createSensor=function(e){var t=void 0,n=[],o=(0,r.default)(function(){n.forEach(function(t){t(e)})}),a=function(){t&&t.parentNode&&(t.contentDocument.defaultView.removeEventListener("resize",o),t.parentNode.removeChild(t),t=void 0,n=[])};return{element:e,bind:function(r){t||(t=function(){"static"===getComputedStyle(e).position&&(e.style.position="relative");var t=document.createElement("object");return t.onload=function(){t.contentDocument.defaultView.addEventListener("resize",o),o()},t.setAttribute("style",i.SensorStyle),t.setAttribute("class",i.SensorClassName),t.type="text/html",e.appendChild(t),t.data="about:blank",t}()),-1===n.indexOf(r)&&n.push(r)},destroy:a,unbind:function(e){var o=n.indexOf(e);-1!==o&&n.splice(o,1),0===n.length&&t&&a()}}}});e(r);r.createSensor;var a=t(function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.createSensor=void 0;var n,i=(n=o)&&n.__esModule?n:{default:n};t.createSensor=function(e){var t=void 0,n=[],o=(0,i.default)(function(){n.forEach(function(t){t(e)})}),r=function(){t.disconnect(),n=[],t=void 0};return{element:e,bind:function(i){t||(t=function(){var t=new ResizeObserver(o);return t.observe(e),o(),t}()),-1===n.indexOf(i)&&n.push(i)},destroy:r,unbind:function(e){var o=n.indexOf(e);-1!==o&&n.splice(o,1),0===n.length&&t&&r()}}}});e(a);a.createSensor;var s=t(function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.createSensor=void 0;t.createSensor="undefined"!=typeof ResizeObserver?a.createSensor:r.createSensor});e(s);s.createSensor;var u=t(function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.removeSensor=t.getSensor=void 0;var o,r=(o=n)&&o.__esModule?o:{default:o};var a={};t.getSensor=function(e){var t=e.getAttribute(i.SizeSensorId);if(t&&a[t])return a[t];var n=(0,r.default)();e.setAttribute(i.SizeSensorId,n);var o=(0,s.createSensor)(e);return a[n]=o,o},t.removeSensor=function(e){var t=e.element.getAttribute(i.SizeSensorId);e.element.removeAttribute(i.SizeSensorId),e.destroy(),t&&a[t]&&delete a[t]}});e(u);u.removeSensor,u.getSensor;var c=t(function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.clear=t.bind=void 0;t.bind=function(e,t){var n=(0,u.getSensor)(e);return n.bind(t),function(){n.unbind(t)}},t.clear=function(e){var t=(0,u.getSensor)(e);(0,u.removeSensor)(t)}});e(c);var l=c.clear,d=c.bind,v=window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.msRequestAnimationFrame||window.oRequestAnimationFrame||function(e){return window.setTimeout(e,1e3/60)},f=window.cancelAnimationFrame||window.webkitCancelAnimationFrame||window.mozCancelAnimationFrame||window.msCancelAnimationFrame||window.oCancelAnimationFrame||window.clearTimeout,m=function(e){return new Array(e).fill(0).map(function(e,t){return t})},h=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var o in n)Object.prototype.hasOwnProperty.call(n,o)&&(e[o]=n[o])}return e},y=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}();var p,w;new(function(){function e(t,n){var o=this;!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),this.randomPoints=function(){return m(o.c.count).map(function(){return{x:Math.random()*o.canvas.width,y:Math.random()*o.canvas.height,xa:2*Math.random()-1,ya:2*Math.random()-1,max:6e3}})},this.el=t,this.c=h({zIndex:-1,opacity:.5,color:"0,0,0",count:99},n),this.canvas=this.newCanvas(),this.context=this.canvas.getContext("2d"),this.points=this.randomPoints(),this.current={x:null,y:null,max:2e4},this.all=this.points.concat([this.current]),this.bindEvent(),this.requestFrame(this.drawCanvas)}return y(e,[{key:"bindEvent",value:function(){var e=this;d(this.el,function(){e.canvas.width=e.el.clientWidth,e.canvas.height=e.el.clientHeight}),this.onmousemove=window.onmousemove,window.onmousemove=function(t){e.current.x=t.clientX-e.el.offsetLeft+document.scrollingElement.scrollLeft,e.current.y=t.clientY-e.el.offsetTop+document.scrollingElement.scrollTop,e.onmousemove&&e.onmousemove(t)},this.onmouseout=window.onmouseout,window.onmouseout=function(){e.current.x=null,e.current.y=null,e.onmouseout&&e.onmouseout()}}},{key:"newCanvas",value:function(){"static"===getComputedStyle(this.el).position&&(this.el.style.position="relative");var e,t=document.createElement("canvas");return t.style.cssText="display:block;position:absolute;top:0;left:0;height:100%;width:100%;overflow:hidden;pointer-events:none;z-index:"+(e=this.c).zIndex+";opacity:"+e.opacity,t.width=this.el.clientWidth,t.height=this.el.clientHeight,this.el.appendChild(t),t}},{key:"requestFrame",value:function(e){var t=this;this.tid=v(function(){return e.call(t)})}},{key:"drawCanvas",value:function(){var e=this,t=this.context,n=this.canvas.width,o=this.canvas.height,i=this.current,r=this.points,a=this.all;t.clearRect(0,0,n,o);var s=void 0,u=void 0,c=void 0,l=void 0,d=void 0,v=void 0;r.forEach(function(r,f){for(r.x+=r.xa,r.y+=r.ya,r.xa*=r.x>n||r.x<0?-1:1,r.ya*=r.y>o||r.y<0?-1:1,t.fillRect(r.x-.5,r.y-.5,1,1),u=f+1;u<a.length;u++)null!==(s=a[u]).x&&null!==s.y&&(l=r.x-s.x,d=r.y-s.y,(v=l*l+d*d)<s.max&&(s===i&&v>=s.max/2&&(r.x-=.03*l,r.y-=.03*d),c=(s.max-v)/s.max,t.beginPath(),t.lineWidth=c/2,t.strokeStyle="rgba("+e.c.color+","+(c+.2)+")",t.moveTo(r.x,r.y),t.lineTo(s.x,s.y),t.stroke()))}),this.requestFrame(this.drawCanvas)}},{key:"destroy",value:function(){l(this.el),window.onmousemove=this.onmousemove,window.onmouseout=this.onmouseout,f(this.tid),this.canvas.parentNode.removeChild(this.canvas)}}]),e}())(document.body,(p=document.getElementsByTagName("script"),{zIndex:(w=p[p.length-1]).getAttribute("zIndex"),opacity:w.getAttribute("opacity"),color:w.getAttribute("color"),count:Number(w.getAttribute("count"))||99}))}();
  </script>
</body>
</html>
